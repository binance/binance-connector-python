"""
Binance Derivatives Trading Portfolio Margin REST API

OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_derivatives_trading_portfolio_margin.rest_api.api import TradeApi
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelAllCmOpenConditionalOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelAllCmOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelAllUmOpenConditionalOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelAllUmOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelCmConditionalOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelCmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelMarginAccountAllOpenOrdersOnASymbolResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelMarginAccountOcoOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelMarginAccountOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelUmConditionalOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CancelUmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CmAccountTradeListResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    CmPositionAdlQuantileEstimationResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    GetUmFuturesBnbBurnStatusResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountBorrowResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountNewOcoResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountRepayResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountRepayDebtResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountTradeListResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ModifyCmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ModifyUmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmConditionalOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllCmConditionalOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllCmOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllCurrentCmOpenConditionalOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllCurrentCmOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllCurrentUmOpenConditionalOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllCurrentUmOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllMarginAccountOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllUmConditionalOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryAllUmOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCmConditionalOrderHistoryResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCmModifyOrderHistoryResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCurrentCmOpenConditionalOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCurrentCmOpenOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCurrentMarginOpenOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCurrentUmOpenConditionalOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryCurrentUmOpenOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryMarginAccountOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryMarginAccountsAllOcoResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryMarginAccountsOcoResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryMarginAccountsOpenOcoResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUmConditionalOrderHistoryResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUmModifyOrderHistoryResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUmOrderResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUsersCmForceOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUsersMarginForceOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUsersUmForceOrdersResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ToggleBnbBurnOnUmFuturesTradeResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    UmAccountTradeListResponse,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    UmPositionAdlQuantileEstimationResponse,
)


from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountNewOcoSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountNewOcoStopLimitTimeInForceEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountNewOcoNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    MarginAccountNewOcoSideEffectTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ModifyCmOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ModifyCmOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ModifyUmOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    ModifyUmOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmConditionalOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmConditionalOrderStrategyTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmConditionalOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmConditionalOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmConditionalOrderWorkingTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewCmOrderNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderSideEffectTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewMarginOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderStrategyTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderWorkingTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmConditionalOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    NewUmOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUsersCmForceOrdersAutoCloseTypeEnum,
)
from binance_sdk_derivatives_trading_portfolio_margin.rest_api.models import (
    QueryUsersUmForceOrdersAutoCloseTypeEnum,
)


class TestTradeApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = TradeApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_cm_open_conditional_orders_success(self, mock_get_signature):
        """Test cancel_all_cm_open_conditional_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": "200",
            "msg": "The operation of cancel all conditional open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_cm_open_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllCmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelAllCmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = CancelAllCmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = CancelAllCmOpenConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_cm_open_conditional_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_cm_open_conditional_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": "200",
            "msg": "The operation of cancel all conditional open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_cm_open_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllCmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelAllCmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = CancelAllCmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = CancelAllCmOpenConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_cm_open_conditional_orders_missing_required_param_symbol(self):
        """Test that cancel_all_cm_open_conditional_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_cm_open_conditional_orders(**params)

    def test_cancel_all_cm_open_conditional_orders_server_error(self):
        """Test that cancel_all_cm_open_conditional_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_cm_open_conditional_orders = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_cm_open_conditional_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_cm_open_orders_success(self, mock_get_signature):
        """Test cancel_all_cm_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_cm_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllCmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllCmOpenOrdersResponse, "from_dict"):
            expected = CancelAllCmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllCmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_cm_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_cm_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_cm_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllCmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllCmOpenOrdersResponse, "from_dict"):
            expected = CancelAllCmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllCmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_cm_open_orders_missing_required_param_symbol(self):
        """Test that cancel_all_cm_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_cm_open_orders(**params)

    def test_cancel_all_cm_open_orders_server_error(self):
        """Test that cancel_all_cm_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_cm_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_cm_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_um_open_conditional_orders_success(self, mock_get_signature):
        """Test cancel_all_um_open_conditional_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": "200",
            "msg": "The operation of cancel all conditional open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_um_open_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllUmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelAllUmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = CancelAllUmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = CancelAllUmOpenConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_um_open_conditional_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_um_open_conditional_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": "200",
            "msg": "The operation of cancel all conditional open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_um_open_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllUmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelAllUmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = CancelAllUmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = CancelAllUmOpenConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_um_open_conditional_orders_missing_required_param_symbol(self):
        """Test that cancel_all_um_open_conditional_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_um_open_conditional_orders(**params)

    def test_cancel_all_um_open_conditional_orders_server_error(self):
        """Test that cancel_all_um_open_conditional_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_um_open_conditional_orders = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_um_open_conditional_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_um_open_orders_success(self, mock_get_signature):
        """Test cancel_all_um_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_um_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllUmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllUmOpenOrdersResponse, "from_dict"):
            expected = CancelAllUmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllUmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_um_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_um_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_um_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllUmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllUmOpenOrdersResponse, "from_dict"):
            expected = CancelAllUmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllUmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_um_open_orders_missing_required_param_symbol(self):
        """Test that cancel_all_um_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_um_open_orders(**params)

    def test_cancel_all_um_open_orders_server_error(self):
        """Test that cancel_all_um_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_um_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_um_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_cm_conditional_order_success(self, mock_get_signature):
        """Test cancel_cm_conditional_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "newClientStrategyId": "myOrder1",
            "strategyId": 123445,
            "strategyStatus": "CANCELED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "11",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD",
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_cm_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelCmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelCmConditionalOrderResponse, "from_dict")
        ):
            expected = CancelCmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = CancelCmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_cm_conditional_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_cm_conditional_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "new_client_strategy_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "myOrder1",
            "strategyId": 123445,
            "strategyStatus": "CANCELED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "11",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD",
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_cm_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelCmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelCmConditionalOrderResponse, "from_dict")
        ):
            expected = CancelCmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = CancelCmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_cm_conditional_order_missing_required_param_symbol(self):
        """Test that cancel_cm_conditional_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_cm_conditional_order(**params)

    def test_cancel_cm_conditional_order_server_error(self):
        """Test that cancel_cm_conditional_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_cm_conditional_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_cm_conditional_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_cm_order_success(self, mock_get_signature):
        """Test cancel_cm_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 283194212,
            "origQty": "2",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1571110484038,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelCmOrderResponse, "from_dict"):
            expected = CancelCmOrderResponse.from_dict(expected_response)
        else:
            expected = CancelCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_cm_order_success_with_optional_params(self, mock_get_signature):
        """Test cancel_cm_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 283194212,
            "origQty": "2",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1571110484038,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelCmOrderResponse, "from_dict"):
            expected = CancelCmOrderResponse.from_dict(expected_response)
        else:
            expected = CancelCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_cm_order_missing_required_param_symbol(self):
        """Test that cancel_cm_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_cm_order(**params)

    def test_cancel_cm_order_server_error(self):
        """Test that cancel_cm_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_cm_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_cm_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_margin_account_all_open_orders_on_a_symbol_success(
        self, mock_get_signature
    ):
        """Test cancel_margin_account_all_open_orders_on_a_symbol() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "origClientOrderId": "E6APeyTJvkMvLMYMqu1KQ4",
                "orderId": 11,
                "orderListId": -1,
                "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                "price": "0.089853",
                "origQty": "0.178622",
                "executedQty": "0.000000",
                "cummulativeQuoteQty": "0.000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
            },
            {
                "orderListId": 1929,
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "2inzWQdDvZLHbbAmAozX2N",
                "transactionTime": 1585230948299,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 20,
                        "clientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 21,
                        "clientOrderId": "461cPg51vQjV3zIMOXNz39",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                        "orderId": 20,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "price": "0.668611",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "0.378131",
                        "icebergQty": "0.017083",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "461cPg51vQjV3zIMOXNz39",
                        "orderId": 21,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "price": "0.008791",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "icebergQty": "0.639962",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_margin_account_all_open_orders_on_a_symbol(
            **params
        )

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMarginAccountAllOpenOrdersOnASymbolResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelMarginAccountAllOpenOrdersOnASymbolResponse, "from_dict")
        ):
            expected = CancelMarginAccountAllOpenOrdersOnASymbolResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                CancelMarginAccountAllOpenOrdersOnASymbolResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_margin_account_all_open_orders_on_a_symbol_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_margin_account_all_open_orders_on_a_symbol() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "origClientOrderId": "E6APeyTJvkMvLMYMqu1KQ4",
                "orderId": 11,
                "orderListId": -1,
                "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                "price": "0.089853",
                "origQty": "0.178622",
                "executedQty": "0.000000",
                "cummulativeQuoteQty": "0.000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
            },
            {
                "orderListId": 1929,
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "2inzWQdDvZLHbbAmAozX2N",
                "transactionTime": 1585230948299,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 20,
                        "clientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 21,
                        "clientOrderId": "461cPg51vQjV3zIMOXNz39",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                        "orderId": 20,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "price": "0.668611",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "0.378131",
                        "icebergQty": "0.017083",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "461cPg51vQjV3zIMOXNz39",
                        "orderId": 21,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "price": "0.008791",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "icebergQty": "0.639962",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_margin_account_all_open_orders_on_a_symbol(
            **params
        )

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMarginAccountAllOpenOrdersOnASymbolResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelMarginAccountAllOpenOrdersOnASymbolResponse, "from_dict")
        ):
            expected = CancelMarginAccountAllOpenOrdersOnASymbolResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                CancelMarginAccountAllOpenOrdersOnASymbolResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_cancel_margin_account_all_open_orders_on_a_symbol_missing_required_param_symbol(
        self,
    ):
        """Test that cancel_margin_account_all_open_orders_on_a_symbol() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_margin_account_all_open_orders_on_a_symbol(**params)

    def test_cancel_margin_account_all_open_orders_on_a_symbol_server_error(self):
        """Test that cancel_margin_account_all_open_orders_on_a_symbol() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_margin_account_all_open_orders_on_a_symbol = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_margin_account_all_open_orders_on_a_symbol(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_margin_account_oco_orders_success(self, mock_get_signature):
        """Test cancel_margin_account_oco_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "ALL_DONE",
            "listOrderStatus": "ALL_DONE",
            "listClientOrderId": "C3wyj4WVEktd7u9aVBRXcN",
            "transactionTime": 1574040868128,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "price": "1.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "SELL",
                    "stopPrice": "1.00000000",
                },
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "price": "3.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "SELL",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_margin_account_oco_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMarginAccountOcoOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelMarginAccountOcoOrdersResponse, "from_dict")
        ):
            expected = CancelMarginAccountOcoOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelMarginAccountOcoOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_margin_account_oco_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_margin_account_oco_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_list_id": 1,
            "list_client_order_id": "1",
            "new_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "ALL_DONE",
            "listOrderStatus": "ALL_DONE",
            "listClientOrderId": "C3wyj4WVEktd7u9aVBRXcN",
            "transactionTime": 1574040868128,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "price": "1.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "SELL",
                    "stopPrice": "1.00000000",
                },
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "price": "3.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "SELL",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_margin_account_oco_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMarginAccountOcoOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelMarginAccountOcoOrdersResponse, "from_dict")
        ):
            expected = CancelMarginAccountOcoOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelMarginAccountOcoOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_margin_account_oco_orders_missing_required_param_symbol(self):
        """Test that cancel_margin_account_oco_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_margin_account_oco_orders(**params)

    def test_cancel_margin_account_oco_orders_server_error(self):
        """Test that cancel_margin_account_oco_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_margin_account_oco_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_margin_account_oco_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_margin_account_order_success(self, mock_get_signature):
        """Test cancel_margin_account_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "symbol": "LTCBTC",
            "orderId": 28,
            "origClientOrderId": "myOrder1",
            "clientOrderId": "cancelMyOrder1",
            "price": "1.00000000",
            "origQty": "10.00000000",
            "executedQty": "8.00000000",
            "cummulativeQuoteQty": "8.00000000",
            "status": "CANCELED",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "SELL",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_margin_account_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMarginAccountOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelMarginAccountOrderResponse, "from_dict")
        ):
            expected = CancelMarginAccountOrderResponse.from_dict(expected_response)
        else:
            expected = CancelMarginAccountOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_margin_account_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_margin_account_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "new_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "symbol": "LTCBTC",
            "orderId": 28,
            "origClientOrderId": "myOrder1",
            "clientOrderId": "cancelMyOrder1",
            "price": "1.00000000",
            "origQty": "10.00000000",
            "executedQty": "8.00000000",
            "cummulativeQuoteQty": "8.00000000",
            "status": "CANCELED",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "SELL",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_margin_account_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMarginAccountOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelMarginAccountOrderResponse, "from_dict")
        ):
            expected = CancelMarginAccountOrderResponse.from_dict(expected_response)
        else:
            expected = CancelMarginAccountOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_margin_account_order_missing_required_param_symbol(self):
        """Test that cancel_margin_account_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_margin_account_order(**params)

    def test_cancel_margin_account_order_server_error(self):
        """Test that cancel_margin_account_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_margin_account_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_margin_account_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_um_conditional_order_success(self, mock_get_signature):
        """Test cancel_um_conditional_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "newClientStrategyId": "myOrder1",
            "strategyId": 123445,
            "strategyStatus": "CANCELED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "11",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_um_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelUmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelUmConditionalOrderResponse, "from_dict")
        ):
            expected = CancelUmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = CancelUmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_um_conditional_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_um_conditional_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "new_client_strategy_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "myOrder1",
            "strategyId": 123445,
            "strategyStatus": "CANCELED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "11",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_um_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelUmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CancelUmConditionalOrderResponse, "from_dict")
        ):
            expected = CancelUmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = CancelUmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_um_conditional_order_missing_required_param_symbol(self):
        """Test that cancel_um_conditional_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_um_conditional_order(**params)

    def test_cancel_um_conditional_order_server_error(self):
        """Test that cancel_um_conditional_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_um_conditional_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_um_conditional_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_um_order_success(self, mock_get_signature):
        """Test cancel_um_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 4611875134427365000,
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "symbol": "BTCUSDT",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1571110484038,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelUmOrderResponse, "from_dict"):
            expected = CancelUmOrderResponse.from_dict(expected_response)
        else:
            expected = CancelUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_um_order_success_with_optional_params(self, mock_get_signature):
        """Test cancel_um_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 4611875134427365000,
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "symbol": "BTCUSDT",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1571110484038,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelUmOrderResponse, "from_dict"):
            expected = CancelUmOrderResponse.from_dict(expected_response)
        else:
            expected = CancelUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_um_order_missing_required_param_symbol(self):
        """Test that cancel_um_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_um_order(**params)

    def test_cancel_um_order_server_error(self):
        """Test that cancel_um_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_um_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_um_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_cm_account_trade_list_success(self, mock_get_signature):
        """Test cm_account_trade_list() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_200626",
                "id": 6,
                "orderId": 28,
                "pair": "BTCUSD",
                "side": "SELL",
                "price": "8800",
                "qty": "1",
                "realizedPnl": "0",
                "marginAsset": "BTC",
                "baseQty": "0.01136364",
                "commission": "0.00000454",
                "commissionAsset": "BTC",
                "time": 1590743483586,
                "positionSide": "BOTH",
                "buyer": False,
                "maker": False,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cm_account_trade_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CmAccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CmAccountTradeListResponse, "from_dict"):
            expected = CmAccountTradeListResponse.from_dict(expected_response)
        else:
            expected = CmAccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cm_account_trade_list_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cm_account_trade_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "pair": "pair_example",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "symbol": "BTCUSD_200626",
                "id": 6,
                "orderId": 28,
                "pair": "BTCUSD",
                "side": "SELL",
                "price": "8800",
                "qty": "1",
                "realizedPnl": "0",
                "marginAsset": "BTC",
                "baseQty": "0.01136364",
                "commission": "0.00000454",
                "commissionAsset": "BTC",
                "time": 1590743483586,
                "positionSide": "BOTH",
                "buyer": False,
                "maker": False,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cm_account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CmAccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CmAccountTradeListResponse, "from_dict"):
            expected = CmAccountTradeListResponse.from_dict(expected_response)
        else:
            expected = CmAccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cm_account_trade_list_server_error(self):
        """Test that cm_account_trade_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.cm_account_trade_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cm_account_trade_list()

    @patch("binance_common.utils.get_signature")
    def test_cm_position_adl_quantile_estimation_success(self, mock_get_signature):
        """Test cm_position_adl_quantile_estimation() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_200925",
                "adlQuantile": {"LONG": 3, "SHORT": 3, "HEDGE": 0},
            },
            {
                "symbol": "BTCUSD_201225",
                "adlQuantile": {"LONG": 1, "SHORT": 2, "BOTH": 0},
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cm_position_adl_quantile_estimation()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CmPositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CmPositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = CmPositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = CmPositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cm_position_adl_quantile_estimation_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cm_position_adl_quantile_estimation() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "symbol": "BTCUSD_200925",
                "adlQuantile": {"LONG": 3, "SHORT": 3, "HEDGE": 0},
            },
            {
                "symbol": "BTCUSD_201225",
                "adlQuantile": {"LONG": 1, "SHORT": 2, "BOTH": 0},
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cm_position_adl_quantile_estimation(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CmPositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CmPositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = CmPositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = CmPositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cm_position_adl_quantile_estimation_server_error(self):
        """Test that cm_position_adl_quantile_estimation() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.cm_position_adl_quantile_estimation = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cm_position_adl_quantile_estimation()

    @patch("binance_common.utils.get_signature")
    def test_get_um_futures_bnb_burn_status_success(self, mock_get_signature):
        """Test get_um_futures_bnb_burn_status() successfully with required parameters only."""

        expected_response = {"feeBurn": True}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_um_futures_bnb_burn_status()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/feeBurn" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetUmFuturesBnbBurnStatusResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetUmFuturesBnbBurnStatusResponse, "from_dict")
        ):
            expected = GetUmFuturesBnbBurnStatusResponse.from_dict(expected_response)
        else:
            expected = GetUmFuturesBnbBurnStatusResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_um_futures_bnb_burn_status_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_um_futures_bnb_burn_status() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = {"feeBurn": True}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_um_futures_bnb_burn_status(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/feeBurn" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetUmFuturesBnbBurnStatusResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetUmFuturesBnbBurnStatusResponse, "from_dict")
        ):
            expected = GetUmFuturesBnbBurnStatusResponse.from_dict(expected_response)
        else:
            expected = GetUmFuturesBnbBurnStatusResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_um_futures_bnb_burn_status_server_error(self):
        """Test that get_um_futures_bnb_burn_status() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_um_futures_bnb_burn_status = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_um_futures_bnb_burn_status()

    @patch("binance_common.utils.get_signature")
    def test_margin_account_borrow_success(self, mock_get_signature):
        """Test margin_account_borrow() successfully with required parameters only."""

        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }

        expected_response = {"tranId": 100000001}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_borrow(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/marginLoan" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountBorrowResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarginAccountBorrowResponse, "from_dict"):
            expected = MarginAccountBorrowResponse.from_dict(expected_response)
        else:
            expected = MarginAccountBorrowResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_margin_account_borrow_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test margin_account_borrow() successfully with optional parameters."""

        params = {"asset": "asset_example", "amount": 1.0, "recv_window": 5000}

        expected_response = {"tranId": 100000001}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_borrow(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/marginLoan" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountBorrowResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarginAccountBorrowResponse, "from_dict"):
            expected = MarginAccountBorrowResponse.from_dict(expected_response)
        else:
            expected = MarginAccountBorrowResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_margin_account_borrow_missing_required_param_asset(self):
        """Test that margin_account_borrow() raises RequiredError when 'asset' is missing."""
        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.margin_account_borrow(**params)

    def test_margin_account_borrow_missing_required_param_amount(self):
        """Test that margin_account_borrow() raises RequiredError when 'amount' is missing."""
        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.margin_account_borrow(**params)

    def test_margin_account_borrow_server_error(self):
        """Test that margin_account_borrow() raises an error when the server returns an error."""

        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.margin_account_borrow = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.margin_account_borrow(**params)

    @patch("binance_common.utils.get_signature")
    def test_margin_account_new_oco_success(self, mock_get_signature):
        """Test margin_account_new_oco() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "JYVpp3F0f5CAG15DhtrqLp",
            "transactionTime": 1563417480525,
            "symbol": "LTCBTC",
            "marginBuyBorrowAmount": "5",
            "marginBuyBorrowAsset": "BTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                    "transactTime": 1563417480525,
                    "price": "0.000000",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS",
                    "side": "BUY",
                    "stopPrice": "0.960664",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                    "transactTime": 1563417480525,
                    "price": "0.036435",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "BUY",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_new_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order/oco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == MarginAccountNewOcoSideEnum["BUY"].value
        assert normalized["quantity"] == 1.0
        assert normalized["price"] == 1.0
        assert normalized["stopPrice"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountNewOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarginAccountNewOcoResponse, "from_dict"):
            expected = MarginAccountNewOcoResponse.from_dict(expected_response)
        else:
            expected = MarginAccountNewOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_margin_account_new_oco_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test margin_account_new_oco() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
            "list_client_order_id": "1",
            "limit_client_order_id": "1",
            "limit_iceberg_qty": 1.0,
            "stop_client_order_id": "1",
            "stop_limit_price": 1.0,
            "stop_iceberg_qty": 1.0,
            "stop_limit_time_in_force": MarginAccountNewOcoStopLimitTimeInForceEnum[
                "GTC"
            ].value,
            "new_order_resp_type": MarginAccountNewOcoNewOrderRespTypeEnum["ACK"].value,
            "side_effect_type": MarginAccountNewOcoSideEffectTypeEnum[
                "NO_SIDE_EFFECT"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "JYVpp3F0f5CAG15DhtrqLp",
            "transactionTime": 1563417480525,
            "symbol": "LTCBTC",
            "marginBuyBorrowAmount": "5",
            "marginBuyBorrowAsset": "BTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                    "transactTime": 1563417480525,
                    "price": "0.000000",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS",
                    "side": "BUY",
                    "stopPrice": "0.960664",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                    "transactTime": 1563417480525,
                    "price": "0.036435",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "BUY",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_new_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order/oco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountNewOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarginAccountNewOcoResponse, "from_dict"):
            expected = MarginAccountNewOcoResponse.from_dict(expected_response)
        else:
            expected = MarginAccountNewOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_margin_account_new_oco_missing_required_param_symbol(self):
        """Test that margin_account_new_oco() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.margin_account_new_oco(**params)

    def test_margin_account_new_oco_missing_required_param_side(self):
        """Test that margin_account_new_oco() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.margin_account_new_oco(**params)

    def test_margin_account_new_oco_missing_required_param_quantity(self):
        """Test that margin_account_new_oco() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        params["quantity"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.margin_account_new_oco(**params)

    def test_margin_account_new_oco_missing_required_param_price(self):
        """Test that margin_account_new_oco() raises RequiredError when 'price' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        params["price"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'price'"):
            self.client.margin_account_new_oco(**params)

    def test_margin_account_new_oco_missing_required_param_stop_price(self):
        """Test that margin_account_new_oco() raises RequiredError when 'stop_price' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        params["stop_price"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'stop_price'"
        ):
            self.client.margin_account_new_oco(**params)

    def test_margin_account_new_oco_server_error(self):
        """Test that margin_account_new_oco() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": MarginAccountNewOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.margin_account_new_oco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.margin_account_new_oco(**params)

    @patch("binance_common.utils.get_signature")
    def test_margin_account_repay_success(self, mock_get_signature):
        """Test margin_account_repay() successfully with required parameters only."""

        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }

        expected_response = {"tranId": 100000001}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_repay(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/repayLoan" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountRepayResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarginAccountRepayResponse, "from_dict"):
            expected = MarginAccountRepayResponse.from_dict(expected_response)
        else:
            expected = MarginAccountRepayResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_margin_account_repay_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test margin_account_repay() successfully with optional parameters."""

        params = {"asset": "asset_example", "amount": 1.0, "recv_window": 5000}

        expected_response = {"tranId": 100000001}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_repay(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/repayLoan" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountRepayResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarginAccountRepayResponse, "from_dict"):
            expected = MarginAccountRepayResponse.from_dict(expected_response)
        else:
            expected = MarginAccountRepayResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_margin_account_repay_missing_required_param_asset(self):
        """Test that margin_account_repay() raises RequiredError when 'asset' is missing."""
        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.margin_account_repay(**params)

    def test_margin_account_repay_missing_required_param_amount(self):
        """Test that margin_account_repay() raises RequiredError when 'amount' is missing."""
        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.margin_account_repay(**params)

    def test_margin_account_repay_server_error(self):
        """Test that margin_account_repay() raises an error when the server returns an error."""

        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.margin_account_repay = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.margin_account_repay(**params)

    @patch("binance_common.utils.get_signature")
    def test_margin_account_repay_debt_success(self, mock_get_signature):
        """Test margin_account_repay_debt() successfully with required parameters only."""

        params = {
            "asset": "asset_example",
        }

        expected_response = {
            "amount": "0.10000000",
            "asset": "BNB",
            "specifyRepayAssets": ["USDT", "BTC"],
            "updateTime": 1636371437000,
            "success": True,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_repay_debt(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/repay-debt" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["asset"] == "asset_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountRepayDebtResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(MarginAccountRepayDebtResponse, "from_dict")
        ):
            expected = MarginAccountRepayDebtResponse.from_dict(expected_response)
        else:
            expected = MarginAccountRepayDebtResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_margin_account_repay_debt_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test margin_account_repay_debt() successfully with optional parameters."""

        params = {
            "asset": "asset_example",
            "amount": "amount_example",
            "specify_repay_assets": "specify_repay_assets_example",
            "recv_window": 5000,
        }

        expected_response = {
            "amount": "0.10000000",
            "asset": "BNB",
            "specifyRepayAssets": ["USDT", "BTC"],
            "updateTime": 1636371437000,
            "success": True,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_repay_debt(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/repay-debt" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountRepayDebtResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(MarginAccountRepayDebtResponse, "from_dict")
        ):
            expected = MarginAccountRepayDebtResponse.from_dict(expected_response)
        else:
            expected = MarginAccountRepayDebtResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_margin_account_repay_debt_missing_required_param_asset(self):
        """Test that margin_account_repay_debt() raises RequiredError when 'asset' is missing."""
        params = {
            "asset": "asset_example",
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.margin_account_repay_debt(**params)

    def test_margin_account_repay_debt_server_error(self):
        """Test that margin_account_repay_debt() raises an error when the server returns an error."""

        params = {
            "asset": "asset_example",
        }

        mock_error = Exception("ResponseError")
        self.client.margin_account_repay_debt = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.margin_account_repay_debt(**params)

    @patch("binance_common.utils.get_signature")
    def test_margin_account_trade_list_success(self, mock_get_signature):
        """Test margin_account_trade_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "commission": "0.00006000",
                "commissionAsset": "BTC",
                "id": 34,
                "isBestMatch": True,
                "isBuyer": False,
                "isMaker": False,
                "orderId": 39324,
                "price": "0.02000000",
                "qty": "3.00000000",
                "symbol": "BNBBTC",
                "time": 1561973357171,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/myTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(MarginAccountTradeListResponse, "from_dict")
        ):
            expected = MarginAccountTradeListResponse.from_dict(expected_response)
        else:
            expected = MarginAccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_margin_account_trade_list_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test margin_account_trade_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "commission": "0.00006000",
                "commissionAsset": "BTC",
                "id": 34,
                "isBestMatch": True,
                "isBuyer": False,
                "isMaker": False,
                "orderId": 39324,
                "price": "0.02000000",
                "qty": "3.00000000",
                "symbol": "BNBBTC",
                "time": 1561973357171,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/myTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginAccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(MarginAccountTradeListResponse, "from_dict")
        ):
            expected = MarginAccountTradeListResponse.from_dict(expected_response)
        else:
            expected = MarginAccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_margin_account_trade_list_missing_required_param_symbol(self):
        """Test that margin_account_trade_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.margin_account_trade_list(**params)

    def test_margin_account_trade_list_server_error(self):
        """Test that margin_account_trade_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.margin_account_trade_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.margin_account_trade_list(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_cm_order_success(self, mock_get_signature):
        """Test modify_cm_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSD_PERP",
            "pair": "BTCUSD",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumBase": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "LONG",
            "origType": "LIMIT",
            "updateTime": 1629182711600,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == ModifyCmOrderSideEnum["BUY"].value
        assert normalized["quantity"] == 1.0
        assert normalized["price"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyCmOrderResponse, "from_dict"):
            expected = ModifyCmOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_cm_order_success_with_optional_params(self, mock_get_signature):
        """Test modify_cm_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "order_id": 1,
            "orig_client_order_id": "1",
            "price_match": ModifyCmOrderPriceMatchEnum["NONE"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSD_PERP",
            "pair": "BTCUSD",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumBase": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "LONG",
            "origType": "LIMIT",
            "updateTime": 1629182711600,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyCmOrderResponse, "from_dict"):
            expected = ModifyCmOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_cm_order_missing_required_param_symbol(self):
        """Test that modify_cm_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.modify_cm_order(**params)

    def test_modify_cm_order_missing_required_param_side(self):
        """Test that modify_cm_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.modify_cm_order(**params)

    def test_modify_cm_order_missing_required_param_quantity(self):
        """Test that modify_cm_order() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["quantity"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.modify_cm_order(**params)

    def test_modify_cm_order_missing_required_param_price(self):
        """Test that modify_cm_order() raises RequiredError when 'price' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["price"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'price'"):
            self.client.modify_cm_order(**params)

    def test_modify_cm_order_server_error(self):
        """Test that modify_cm_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyCmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.modify_cm_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_cm_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_um_order_success(self, mock_get_signature):
        """Test modify_um_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSDT",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumQuote": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "LONG",
            "origType": "LIMIT",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "updateTime": 1629182711600,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == ModifyUmOrderSideEnum["BUY"].value
        assert normalized["quantity"] == 1.0
        assert normalized["price"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyUmOrderResponse, "from_dict"):
            expected = ModifyUmOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_um_order_success_with_optional_params(self, mock_get_signature):
        """Test modify_um_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "order_id": 1,
            "orig_client_order_id": "1",
            "price_match": ModifyUmOrderPriceMatchEnum["NONE"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSDT",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumQuote": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "LONG",
            "origType": "LIMIT",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "updateTime": 1629182711600,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyUmOrderResponse, "from_dict"):
            expected = ModifyUmOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_um_order_missing_required_param_symbol(self):
        """Test that modify_um_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.modify_um_order(**params)

    def test_modify_um_order_missing_required_param_side(self):
        """Test that modify_um_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.modify_um_order(**params)

    def test_modify_um_order_missing_required_param_quantity(self):
        """Test that modify_um_order() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["quantity"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.modify_um_order(**params)

    def test_modify_um_order_missing_required_param_price(self):
        """Test that modify_um_order() raises RequiredError when 'price' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["price"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'price'"):
            self.client.modify_um_order(**params)

    def test_modify_um_order_server_error(self):
        """Test that modify_um_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyUmOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.modify_um_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_um_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_cm_conditional_order_success(self, mock_get_signature):
        """Test new_cm_conditional_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewCmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewCmConditionalOrderStrategyTypeEnum["STOP"].value,
        }

        expected_response = {
            "newClientStrategyId": "testOrder",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_cm_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewCmConditionalOrderSideEnum["BUY"].value
        assert (
            normalized["strategyType"]
            == NewCmConditionalOrderStrategyTypeEnum["STOP"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewCmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewCmConditionalOrderResponse, "from_dict"):
            expected = NewCmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = NewCmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_cm_conditional_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test new_cm_conditional_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewCmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewCmConditionalOrderStrategyTypeEnum["STOP"].value,
            "position_side": NewCmConditionalOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewCmConditionalOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "working_type": NewCmConditionalOrderWorkingTypeEnum["MARK_PRICE"].value,
            "price_protect": "False",
            "new_client_strategy_id": "1",
            "stop_price": 1.0,
            "activation_price": 1.0,
            "callback_rate": 1.0,
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "testOrder",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_cm_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewCmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewCmConditionalOrderResponse, "from_dict"):
            expected = NewCmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = NewCmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_cm_conditional_order_missing_required_param_symbol(self):
        """Test that new_cm_conditional_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewCmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewCmConditionalOrderStrategyTypeEnum["STOP"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_cm_conditional_order(**params)

    def test_new_cm_conditional_order_missing_required_param_side(self):
        """Test that new_cm_conditional_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewCmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewCmConditionalOrderStrategyTypeEnum["STOP"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_cm_conditional_order(**params)

    def test_new_cm_conditional_order_missing_required_param_strategy_type(self):
        """Test that new_cm_conditional_order() raises RequiredError when 'strategy_type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewCmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewCmConditionalOrderStrategyTypeEnum["STOP"].value,
        }
        params["strategy_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'strategy_type'"
        ):
            self.client.new_cm_conditional_order(**params)

    def test_new_cm_conditional_order_server_error(self):
        """Test that new_cm_conditional_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewCmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewCmConditionalOrderStrategyTypeEnum["STOP"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_cm_conditional_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_cm_conditional_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_cm_order_success(self, mock_get_signature):
        """Test new_cm_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewCmOrderSideEnum["BUY"].value,
            "type": NewCmOrderTypeEnum["LIMIT"].value,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.0",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "MARKET",
            "updateTime": 1566818724722,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewCmOrderSideEnum["BUY"].value
        assert normalized["type"] == NewCmOrderTypeEnum["LIMIT"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewCmOrderResponse, "from_dict"):
            expected = NewCmOrderResponse.from_dict(expected_response)
        else:
            expected = NewCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_cm_order_success_with_optional_params(self, mock_get_signature):
        """Test new_cm_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewCmOrderSideEnum["BUY"].value,
            "type": NewCmOrderTypeEnum["LIMIT"].value,
            "position_side": NewCmOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewCmOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "price_match": NewCmOrderPriceMatchEnum["NONE"].value,
            "new_client_order_id": "1",
            "new_order_resp_type": NewCmOrderNewOrderRespTypeEnum["ACK"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.0",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "MARKET",
            "updateTime": 1566818724722,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewCmOrderResponse, "from_dict"):
            expected = NewCmOrderResponse.from_dict(expected_response)
        else:
            expected = NewCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_cm_order_missing_required_param_symbol(self):
        """Test that new_cm_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewCmOrderSideEnum["BUY"].value,
            "type": NewCmOrderTypeEnum["LIMIT"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_cm_order(**params)

    def test_new_cm_order_missing_required_param_side(self):
        """Test that new_cm_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewCmOrderSideEnum["BUY"].value,
            "type": NewCmOrderTypeEnum["LIMIT"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_cm_order(**params)

    def test_new_cm_order_missing_required_param_type(self):
        """Test that new_cm_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewCmOrderSideEnum["BUY"].value,
            "type": NewCmOrderTypeEnum["LIMIT"].value,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_cm_order(**params)

    def test_new_cm_order_server_error(self):
        """Test that new_cm_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewCmOrderSideEnum["BUY"].value,
            "type": NewCmOrderTypeEnum["LIMIT"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_cm_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_cm_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_margin_order_success(self, mock_get_signature):
        """Test new_margin_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewMarginOrderSideEnum["BUY"].value,
            "type": NewMarginOrderTypeEnum["LIMIT"].value,
        }

        expected_response = {
            "symbol": "BTCUSDT",
            "orderId": 28,
            "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
            "transactTime": 1507725176595,
            "price": "1.00000000",
            "origQty": "10.00000000",
            "executedQty": "10.00000000",
            "cummulativeQuoteQty": "10.00000000",
            "status": "FILLED",
            "timeInForce": "GTC",
            "type": "MARKET",
            "side": "SELL",
            "marginBuyBorrowAmount": "5",
            "marginBuyBorrowAsset": "BTC",
            "fills": [
                {
                    "price": "4000.00000000",
                    "qty": "1.00000000",
                    "commission": "4.00000000",
                    "commissionAsset": "USDT",
                },
                {
                    "price": "3999.00000000",
                    "qty": "5.00000000",
                    "commission": "19.99500000",
                    "commissionAsset": "USDT",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_margin_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewMarginOrderSideEnum["BUY"].value
        assert normalized["type"] == NewMarginOrderTypeEnum["LIMIT"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewMarginOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewMarginOrderResponse, "from_dict"):
            expected = NewMarginOrderResponse.from_dict(expected_response)
        else:
            expected = NewMarginOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_margin_order_success_with_optional_params(self, mock_get_signature):
        """Test new_margin_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewMarginOrderSideEnum["BUY"].value,
            "type": NewMarginOrderTypeEnum["LIMIT"].value,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
            "new_client_order_id": "1",
            "new_order_resp_type": NewMarginOrderNewOrderRespTypeEnum["ACK"].value,
            "iceberg_qty": 1.0,
            "side_effect_type": NewMarginOrderSideEffectTypeEnum[
                "NO_SIDE_EFFECT"
            ].value,
            "time_in_force": NewMarginOrderTimeInForceEnum["GTC"].value,
            "self_trade_prevention_mode": NewMarginOrderSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "auto_repay_at_cancel": True,
            "recv_window": 5000,
        }

        expected_response = {
            "symbol": "BTCUSDT",
            "orderId": 28,
            "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
            "transactTime": 1507725176595,
            "price": "1.00000000",
            "origQty": "10.00000000",
            "executedQty": "10.00000000",
            "cummulativeQuoteQty": "10.00000000",
            "status": "FILLED",
            "timeInForce": "GTC",
            "type": "MARKET",
            "side": "SELL",
            "marginBuyBorrowAmount": "5",
            "marginBuyBorrowAsset": "BTC",
            "fills": [
                {
                    "price": "4000.00000000",
                    "qty": "1.00000000",
                    "commission": "4.00000000",
                    "commissionAsset": "USDT",
                },
                {
                    "price": "3999.00000000",
                    "qty": "5.00000000",
                    "commission": "19.99500000",
                    "commissionAsset": "USDT",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_margin_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewMarginOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewMarginOrderResponse, "from_dict"):
            expected = NewMarginOrderResponse.from_dict(expected_response)
        else:
            expected = NewMarginOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_margin_order_missing_required_param_symbol(self):
        """Test that new_margin_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewMarginOrderSideEnum["BUY"].value,
            "type": NewMarginOrderTypeEnum["LIMIT"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_margin_order(**params)

    def test_new_margin_order_missing_required_param_side(self):
        """Test that new_margin_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewMarginOrderSideEnum["BUY"].value,
            "type": NewMarginOrderTypeEnum["LIMIT"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_margin_order(**params)

    def test_new_margin_order_missing_required_param_type(self):
        """Test that new_margin_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewMarginOrderSideEnum["BUY"].value,
            "type": NewMarginOrderTypeEnum["LIMIT"].value,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_margin_order(**params)

    def test_new_margin_order_server_error(self):
        """Test that new_margin_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewMarginOrderSideEnum["BUY"].value,
            "type": NewMarginOrderTypeEnum["LIMIT"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_margin_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_margin_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_um_conditional_order_success(self, mock_get_signature):
        """Test new_um_conditional_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewUmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewUmConditionalOrderStrategyTypeEnum["STOP"].value,
        }

        expected_response = {
            "newClientStrategyId": "testOrder",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_um_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewUmConditionalOrderSideEnum["BUY"].value
        assert (
            normalized["strategyType"]
            == NewUmConditionalOrderStrategyTypeEnum["STOP"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewUmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewUmConditionalOrderResponse, "from_dict"):
            expected = NewUmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = NewUmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_um_conditional_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test new_um_conditional_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewUmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewUmConditionalOrderStrategyTypeEnum["STOP"].value,
            "position_side": NewUmConditionalOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewUmConditionalOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "working_type": NewUmConditionalOrderWorkingTypeEnum["MARK_PRICE"].value,
            "price_protect": "False",
            "new_client_strategy_id": "1",
            "stop_price": 1.0,
            "activation_price": 1.0,
            "callback_rate": 1.0,
            "price_match": NewUmConditionalOrderPriceMatchEnum["NONE"].value,
            "self_trade_prevention_mode": NewUmConditionalOrderSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "good_till_date": 56,
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "testOrder",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_um_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewUmConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewUmConditionalOrderResponse, "from_dict"):
            expected = NewUmConditionalOrderResponse.from_dict(expected_response)
        else:
            expected = NewUmConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_um_conditional_order_missing_required_param_symbol(self):
        """Test that new_um_conditional_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewUmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewUmConditionalOrderStrategyTypeEnum["STOP"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_um_conditional_order(**params)

    def test_new_um_conditional_order_missing_required_param_side(self):
        """Test that new_um_conditional_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewUmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewUmConditionalOrderStrategyTypeEnum["STOP"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_um_conditional_order(**params)

    def test_new_um_conditional_order_missing_required_param_strategy_type(self):
        """Test that new_um_conditional_order() raises RequiredError when 'strategy_type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewUmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewUmConditionalOrderStrategyTypeEnum["STOP"].value,
        }
        params["strategy_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'strategy_type'"
        ):
            self.client.new_um_conditional_order(**params)

    def test_new_um_conditional_order_server_error(self):
        """Test that new_um_conditional_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewUmConditionalOrderSideEnum["BUY"].value,
            "strategy_type": NewUmConditionalOrderStrategyTypeEnum["STOP"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_um_conditional_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_um_conditional_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_um_order_success(self, mock_get_signature):
        """Test new_um_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewUmOrderSideEnum["BUY"].value,
            "type": NewUmOrderTypeEnum["LIMIT"].value,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.00000",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "type": "MARKET",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
            "updateTime": 1566818724722,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewUmOrderSideEnum["BUY"].value
        assert normalized["type"] == NewUmOrderTypeEnum["LIMIT"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewUmOrderResponse, "from_dict"):
            expected = NewUmOrderResponse.from_dict(expected_response)
        else:
            expected = NewUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_um_order_success_with_optional_params(self, mock_get_signature):
        """Test new_um_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewUmOrderSideEnum["BUY"].value,
            "type": NewUmOrderTypeEnum["LIMIT"].value,
            "position_side": NewUmOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewUmOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "new_client_order_id": "1",
            "new_order_resp_type": NewUmOrderNewOrderRespTypeEnum["ACK"].value,
            "price_match": NewUmOrderPriceMatchEnum["NONE"].value,
            "self_trade_prevention_mode": NewUmOrderSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "good_till_date": 56,
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.00000",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "type": "MARKET",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
            "updateTime": 1566818724722,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewUmOrderResponse, "from_dict"):
            expected = NewUmOrderResponse.from_dict(expected_response)
        else:
            expected = NewUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_um_order_missing_required_param_symbol(self):
        """Test that new_um_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewUmOrderSideEnum["BUY"].value,
            "type": NewUmOrderTypeEnum["LIMIT"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_um_order(**params)

    def test_new_um_order_missing_required_param_side(self):
        """Test that new_um_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewUmOrderSideEnum["BUY"].value,
            "type": NewUmOrderTypeEnum["LIMIT"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_um_order(**params)

    def test_new_um_order_missing_required_param_type(self):
        """Test that new_um_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewUmOrderSideEnum["BUY"].value,
            "type": NewUmOrderTypeEnum["LIMIT"].value,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_um_order(**params)

    def test_new_um_order_server_error(self):
        """Test that new_um_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewUmOrderSideEnum["BUY"].value,
            "type": NewUmOrderTypeEnum["LIMIT"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_um_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_um_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_all_cm_conditional_orders_success(self, mock_get_signature):
        """Test query_all_cm_conditional_orders() successfully with required parameters only."""

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "TRIGGERED",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSD",
                "orderId": 12123343534,
                "status": "NEW",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "triggerTime": 1566818724750,
                "timeInForce": "GTC",
                "type": "MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_cm_conditional_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCmConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCmConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllCmConditionalOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCmConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_cm_conditional_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_cm_conditional_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "TRIGGERED",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSD",
                "orderId": 12123343534,
                "status": "NEW",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "triggerTime": 1566818724750,
                "timeInForce": "GTC",
                "type": "MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_cm_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCmConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCmConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllCmConditionalOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCmConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_cm_conditional_orders_server_error(self):
        """Test that query_all_cm_conditional_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_all_cm_conditional_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_cm_conditional_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_all_cm_orders_success(self, mock_get_signature):
        """Test query_all_cm_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_cm_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCmOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAllCmOrdersResponse, "from_dict"):
            expected = QueryAllCmOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCmOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_cm_orders_success_with_optional_params(self, mock_get_signature):
        """Test query_all_cm_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "pair": "pair_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_cm_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCmOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAllCmOrdersResponse, "from_dict"):
            expected = QueryAllCmOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCmOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_cm_orders_missing_required_param_symbol(self):
        """Test that query_all_cm_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_all_cm_orders(**params)

    def test_query_all_cm_orders_server_error(self):
        """Test that query_all_cm_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_all_cm_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_cm_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_cm_open_conditional_orders_success(
        self, mock_get_signature
    ):
        """Test query_all_current_cm_open_conditional_orders() successfully with required parameters only."""

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "NEW",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSD",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "timeInForce": "GTC",
                "activatePrice": "9020",
                "priceRate": "0.3",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_cm_open_conditional_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentCmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentCmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentCmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QueryAllCurrentCmOpenConditionalOrdersResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_cm_open_conditional_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_current_cm_open_conditional_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "NEW",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSD",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "timeInForce": "GTC",
                "activatePrice": "9020",
                "priceRate": "0.3",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_cm_open_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentCmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentCmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentCmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QueryAllCurrentCmOpenConditionalOrdersResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_query_all_current_cm_open_conditional_orders_server_error(self):
        """Test that query_all_current_cm_open_conditional_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_all_current_cm_open_conditional_orders = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_current_cm_open_conditional_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_cm_open_orders_success(self, mock_get_signature):
        """Test query_all_current_cm_open_orders() successfully with required parameters only."""

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_cm_open_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentCmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentCmOpenOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentCmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCurrentCmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_cm_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_current_cm_open_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "pair": "pair_example",
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_cm_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentCmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentCmOpenOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentCmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCurrentCmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_current_cm_open_orders_server_error(self):
        """Test that query_all_current_cm_open_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_all_current_cm_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_current_cm_open_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_um_open_conditional_orders_success(
        self, mock_get_signature
    ):
        """Test query_all_current_um_open_conditional_orders() successfully with required parameters only."""

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "NEW",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSDT",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "timeInForce": "GTC",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_um_open_conditional_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentUmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentUmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentUmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QueryAllCurrentUmOpenConditionalOrdersResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_um_open_conditional_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_current_um_open_conditional_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "NEW",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSDT",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "timeInForce": "GTC",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_um_open_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentUmOpenConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentUmOpenConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentUmOpenConditionalOrdersResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QueryAllCurrentUmOpenConditionalOrdersResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_query_all_current_um_open_conditional_orders_server_error(self):
        """Test that query_all_current_um_open_conditional_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_all_current_um_open_conditional_orders = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_current_um_open_conditional_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_um_open_orders_success(self, mock_get_signature):
        """Test query_all_current_um_open_orders() successfully with required parameters only."""

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_um_open_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentUmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentUmOpenOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentUmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCurrentUmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_current_um_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_current_um_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_current_um_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllCurrentUmOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllCurrentUmOpenOrdersResponse, "from_dict")
        ):
            expected = QueryAllCurrentUmOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllCurrentUmOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_current_um_open_orders_server_error(self):
        """Test that query_all_current_um_open_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_all_current_um_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_current_um_open_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_all_margin_account_orders_success(self, mock_get_signature):
        """Test query_all_margin_account_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "clientOrderId": "D2KDy4DIeS56PvkM13f8cP",
                "cummulativeQuoteQty": "0.00000000",
                "executedQty": "0.00000000",
                "icebergQty": "0.00000000",
                "isWorking": False,
                "orderId": 41295,
                "origQty": "5.31000000",
                "price": "0.22500000",
                "side": "SELL",
                "status": "CANCELED",
                "stopPrice": "0.18000000",
                "symbol": "BNBBTC",
                "time": 1565769338806,
                "timeInForce": "GTC",
                "type": "TAKE_PROFIT_LIMIT",
                "updateTime": 1565769342148,
                "accountId": 152950866,
                "selfTradePreventionMode": "EXPIRE_TAKER",
                "preventedMatchId": None,
                "preventedQuantity": None,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_margin_account_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllMarginAccountOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllMarginAccountOrdersResponse, "from_dict")
        ):
            expected = QueryAllMarginAccountOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllMarginAccountOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_margin_account_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_margin_account_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "clientOrderId": "D2KDy4DIeS56PvkM13f8cP",
                "cummulativeQuoteQty": "0.00000000",
                "executedQty": "0.00000000",
                "icebergQty": "0.00000000",
                "isWorking": False,
                "orderId": 41295,
                "origQty": "5.31000000",
                "price": "0.22500000",
                "side": "SELL",
                "status": "CANCELED",
                "stopPrice": "0.18000000",
                "symbol": "BNBBTC",
                "time": 1565769338806,
                "timeInForce": "GTC",
                "type": "TAKE_PROFIT_LIMIT",
                "updateTime": 1565769342148,
                "accountId": 152950866,
                "selfTradePreventionMode": "EXPIRE_TAKER",
                "preventedMatchId": None,
                "preventedQuantity": None,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_margin_account_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllMarginAccountOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllMarginAccountOrdersResponse, "from_dict")
        ):
            expected = QueryAllMarginAccountOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllMarginAccountOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_margin_account_orders_missing_required_param_symbol(self):
        """Test that query_all_margin_account_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_all_margin_account_orders(**params)

    def test_query_all_margin_account_orders_server_error(self):
        """Test that query_all_margin_account_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_all_margin_account_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_margin_account_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_all_um_conditional_orders_success(self, mock_get_signature):
        """Test query_all_um_conditional_orders() successfully with required parameters only."""

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "TRIGGERED",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSDT",
                "orderId": 12132343435,
                "status": "NEW",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "triggerTime": 1566818724750,
                "timeInForce": "GTC",
                "type": "MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_um_conditional_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllUmConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllUmConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllUmConditionalOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllUmConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_um_conditional_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_um_conditional_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "newClientStrategyId": "abc",
                "strategyId": 123445,
                "strategyStatus": "TRIGGERED",
                "strategyType": "TRAILING_STOP_MARKET",
                "origQty": "0.40",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "9300",
                "symbol": "BTCUSDT",
                "orderId": 12132343435,
                "status": "NEW",
                "bookTime": 1566818724710,
                "updateTime": 1566818724722,
                "triggerTime": 1566818724750,
                "timeInForce": "GTC",
                "type": "MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_um_conditional_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllUmConditionalOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryAllUmConditionalOrdersResponse, "from_dict")
        ):
            expected = QueryAllUmConditionalOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllUmConditionalOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_um_conditional_orders_server_error(self):
        """Test that query_all_um_conditional_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_all_um_conditional_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_um_conditional_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_all_um_orders_success(self, mock_get_signature):
        """Test query_all_um_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_um_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllUmOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAllUmOrdersResponse, "from_dict"):
            expected = QueryAllUmOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllUmOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_um_orders_success_with_optional_params(self, mock_get_signature):
        """Test query_all_um_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "LIMIT",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1579276756075,
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "priceMatch": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_um_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllUmOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAllUmOrdersResponse, "from_dict"):
            expected = QueryAllUmOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllUmOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_um_orders_missing_required_param_symbol(self):
        """Test that query_all_um_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_all_um_orders(**params)

    def test_query_all_um_orders_server_error(self):
        """Test that query_all_um_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_all_um_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_um_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_cm_conditional_order_history_success(self, mock_get_signature):
        """Test query_cm_conditional_order_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "TRIGGERED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD",
            "orderId": 12123343534,
            "status": "NEW",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "triggerTime": 1566818724750,
            "timeInForce": "GTC",
            "type": "MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_cm_conditional_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/orderHistory" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCmConditionalOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCmConditionalOrderHistoryResponse, "from_dict")
        ):
            expected = QueryCmConditionalOrderHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryCmConditionalOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_cm_conditional_order_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_cm_conditional_order_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "new_client_strategy_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "TRIGGERED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD",
            "orderId": 12123343534,
            "status": "NEW",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "triggerTime": 1566818724750,
            "timeInForce": "GTC",
            "type": "MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_cm_conditional_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/orderHistory" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCmConditionalOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCmConditionalOrderHistoryResponse, "from_dict")
        ):
            expected = QueryCmConditionalOrderHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryCmConditionalOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_cm_conditional_order_history_missing_required_param_symbol(self):
        """Test that query_cm_conditional_order_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_cm_conditional_order_history(**params)

    def test_query_cm_conditional_order_history_server_error(self):
        """Test that query_cm_conditional_order_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_cm_conditional_order_history = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_cm_conditional_order_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_cm_modify_order_history_success(self, mock_get_signature):
        """Test query_cm_modify_order_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_cm_modify_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCmModifyOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCmModifyOrderHistoryResponse, "from_dict")
        ):
            expected = QueryCmModifyOrderHistoryResponse.from_dict(expected_response)
        else:
            expected = QueryCmModifyOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_cm_modify_order_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_cm_modify_order_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_cm_modify_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCmModifyOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCmModifyOrderHistoryResponse, "from_dict")
        ):
            expected = QueryCmModifyOrderHistoryResponse.from_dict(expected_response)
        else:
            expected = QueryCmModifyOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_cm_modify_order_history_missing_required_param_symbol(self):
        """Test that query_cm_modify_order_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_cm_modify_order_history(**params)

    def test_query_cm_modify_order_history_server_error(self):
        """Test that query_cm_modify_order_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_cm_modify_order_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_cm_modify_order_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_cm_order_success(self, mock_get_signature):
        """Test query_cm_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "status": "NEW",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "positionSide": "SHORT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryCmOrderResponse, "from_dict"):
            expected = QueryCmOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_cm_order_success_with_optional_params(self, mock_get_signature):
        """Test query_cm_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "status": "NEW",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "positionSide": "SHORT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_cm_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryCmOrderResponse, "from_dict"):
            expected = QueryCmOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_cm_order_missing_required_param_symbol(self):
        """Test that query_cm_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_cm_order(**params)

    def test_query_cm_order_server_error(self):
        """Test that query_cm_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_cm_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_cm_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_current_cm_open_conditional_order_success(self, mock_get_signature):
        """Test query_current_cm_open_conditional_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_cm_open_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentCmOpenConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCurrentCmOpenConditionalOrderResponse, "from_dict")
        ):
            expected = QueryCurrentCmOpenConditionalOrderResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryCurrentCmOpenConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_cm_open_conditional_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_cm_open_conditional_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "new_client_strategy_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSD",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_cm_open_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/conditional/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentCmOpenConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCurrentCmOpenConditionalOrderResponse, "from_dict")
        ):
            expected = QueryCurrentCmOpenConditionalOrderResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryCurrentCmOpenConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_cm_open_conditional_order_missing_required_param_symbol(
        self,
    ):
        """Test that query_current_cm_open_conditional_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_cm_open_conditional_order(**params)

    def test_query_current_cm_open_conditional_order_server_error(self):
        """Test that query_current_cm_open_conditional_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_cm_open_conditional_order = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_cm_open_conditional_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_current_cm_open_order_success(self, mock_get_signature):
        """Test query_current_cm_open_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_cm_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentCmOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryCurrentCmOpenOrderResponse, "from_dict")
        ):
            expected = QueryCurrentCmOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentCmOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_cm_open_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_cm_open_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_cm_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentCmOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryCurrentCmOpenOrderResponse, "from_dict")
        ):
            expected = QueryCurrentCmOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentCmOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_cm_open_order_missing_required_param_symbol(self):
        """Test that query_current_cm_open_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_cm_open_order(**params)

    def test_query_current_cm_open_order_server_error(self):
        """Test that query_current_cm_open_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_cm_open_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_cm_open_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_current_margin_open_order_success(self, mock_get_signature):
        """Test query_current_margin_open_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "clientOrderId": "qhcZw71gAkCCTv0t0k8LUK",
                "cummulativeQuoteQty": "0.00000000",
                "executedQty": "0.00000000",
                "icebergQty": "0.00000000",
                "isWorking": True,
                "orderId": 211842552,
                "origQty": "0.30000000",
                "price": "0.00475010",
                "side": "SELL",
                "status": "NEW",
                "stopPrice": "0.00000000",
                "symbol": "BNBBTC",
                "time": 1562040170089,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1562040170089,
                "accountId": 152950866,
                "selfTradePreventionMode": "EXPIRE_TAKER",
                "preventedMatchId": None,
                "preventedQuantity": None,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_margin_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentMarginOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCurrentMarginOpenOrderResponse, "from_dict")
        ):
            expected = QueryCurrentMarginOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentMarginOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_margin_open_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_margin_open_order() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "clientOrderId": "qhcZw71gAkCCTv0t0k8LUK",
                "cummulativeQuoteQty": "0.00000000",
                "executedQty": "0.00000000",
                "icebergQty": "0.00000000",
                "isWorking": True,
                "orderId": 211842552,
                "origQty": "0.30000000",
                "price": "0.00475010",
                "side": "SELL",
                "status": "NEW",
                "stopPrice": "0.00000000",
                "symbol": "BNBBTC",
                "time": 1562040170089,
                "timeInForce": "GTC",
                "type": "LIMIT",
                "updateTime": 1562040170089,
                "accountId": 152950866,
                "selfTradePreventionMode": "EXPIRE_TAKER",
                "preventedMatchId": None,
                "preventedQuantity": None,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_margin_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentMarginOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCurrentMarginOpenOrderResponse, "from_dict")
        ):
            expected = QueryCurrentMarginOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentMarginOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_margin_open_order_missing_required_param_symbol(self):
        """Test that query_current_margin_open_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_margin_open_order(**params)

    def test_query_current_margin_open_order_server_error(self):
        """Test that query_current_margin_open_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_margin_open_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_margin_open_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_current_um_open_conditional_order_success(self, mock_get_signature):
        """Test query_current_um_open_conditional_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_um_open_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentUmOpenConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCurrentUmOpenConditionalOrderResponse, "from_dict")
        ):
            expected = QueryCurrentUmOpenConditionalOrderResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryCurrentUmOpenConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_um_open_conditional_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_um_open_conditional_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "new_client_strategy_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "NEW",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "timeInForce": "GTC",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_um_open_conditional_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentUmOpenConditionalOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryCurrentUmOpenConditionalOrderResponse, "from_dict")
        ):
            expected = QueryCurrentUmOpenConditionalOrderResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryCurrentUmOpenConditionalOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_um_open_conditional_order_missing_required_param_symbol(
        self,
    ):
        """Test that query_current_um_open_conditional_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_um_open_conditional_order(**params)

    def test_query_current_um_open_conditional_order_server_error(self):
        """Test that query_current_um_open_conditional_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_um_open_conditional_order = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_um_open_conditional_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_current_um_open_order_success(self, mock_get_signature):
        """Test query_current_um_open_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_um_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentUmOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryCurrentUmOpenOrderResponse, "from_dict")
        ):
            expected = QueryCurrentUmOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentUmOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_um_open_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_um_open_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_um_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentUmOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryCurrentUmOpenOrderResponse, "from_dict")
        ):
            expected = QueryCurrentUmOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentUmOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_um_open_order_missing_required_param_symbol(self):
        """Test that query_current_um_open_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_um_open_order(**params)

    def test_query_current_um_open_order_server_error(self):
        """Test that query_current_um_open_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_um_open_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_um_open_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_margin_account_order_success(self, mock_get_signature):
        """Test query_margin_account_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "clientOrderId": "ZwfQzuDIGpceVhKW5DvCmO",
            "cummulativeQuoteQty": "0.00000000",
            "executedQty": "0.00000000",
            "icebergQty": "0.00000000",
            "isWorking": True,
            "orderId": 213205622,
            "origQty": "0.30000000",
            "price": "0.00493630",
            "side": "SELL",
            "status": "NEW",
            "stopPrice": "0.00000000",
            "symbol": "BNBBTC",
            "time": 1562133008725,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1562133008725,
            "accountId": 152950866,
            "selfTradePreventionMode": "EXPIRE_TAKER",
            "preventedMatchId": None,
            "preventedQuantity": None,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_account_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryMarginAccountOrderResponse, "from_dict")
        ):
            expected = QueryMarginAccountOrderResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_margin_account_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_margin_account_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "ZwfQzuDIGpceVhKW5DvCmO",
            "cummulativeQuoteQty": "0.00000000",
            "executedQty": "0.00000000",
            "icebergQty": "0.00000000",
            "isWorking": True,
            "orderId": 213205622,
            "origQty": "0.30000000",
            "price": "0.00493630",
            "side": "SELL",
            "status": "NEW",
            "stopPrice": "0.00000000",
            "symbol": "BNBBTC",
            "time": 1562133008725,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1562133008725,
            "accountId": 152950866,
            "selfTradePreventionMode": "EXPIRE_TAKER",
            "preventedMatchId": None,
            "preventedQuantity": None,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_account_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryMarginAccountOrderResponse, "from_dict")
        ):
            expected = QueryMarginAccountOrderResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_margin_account_order_missing_required_param_symbol(self):
        """Test that query_margin_account_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_margin_account_order(**params)

    def test_query_margin_account_order_server_error(self):
        """Test that query_margin_account_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_margin_account_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_margin_account_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_margin_accounts_all_oco_success(self, mock_get_signature):
        """Test query_margin_accounts_all_oco() successfully with required parameters only."""

        expected_response = [
            {
                "orderListId": 29,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "amEEAXryFzFwYF1FeRpUoZ",
                "transactionTime": 1565245913483,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
                    },
                ],
            },
            {
                "orderListId": 28,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "hG7hFNxJV6cZy3Ze4AUT4d",
                "transactionTime": 1565245913407,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 2,
                        "clientOrderId": "j6lFOfbmFMRjTYA7rRJ0LP",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 3,
                        "clientOrderId": "z0KCjOdditiLS5ekAFtK81",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_accounts_all_oco()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/allOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountsAllOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryMarginAccountsAllOcoResponse, "from_dict")
        ):
            expected = QueryMarginAccountsAllOcoResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountsAllOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_margin_accounts_all_oco_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_margin_accounts_all_oco() successfully with optional parameters."""

        params = {
            "from_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderListId": 29,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "amEEAXryFzFwYF1FeRpUoZ",
                "transactionTime": 1565245913483,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
                    },
                ],
            },
            {
                "orderListId": 28,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "hG7hFNxJV6cZy3Ze4AUT4d",
                "transactionTime": 1565245913407,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 2,
                        "clientOrderId": "j6lFOfbmFMRjTYA7rRJ0LP",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 3,
                        "clientOrderId": "z0KCjOdditiLS5ekAFtK81",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_accounts_all_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/allOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountsAllOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryMarginAccountsAllOcoResponse, "from_dict")
        ):
            expected = QueryMarginAccountsAllOcoResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountsAllOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_margin_accounts_all_oco_server_error(self):
        """Test that query_margin_accounts_all_oco() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_margin_accounts_all_oco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_margin_accounts_all_oco()

    @patch("binance_common.utils.get_signature")
    def test_query_margin_accounts_oco_success(self, mock_get_signature):
        """Test query_margin_accounts_oco() successfully with required parameters only."""

        expected_response = {
            "orderListId": 27,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "h2USkA5YQpaXHPIrkd96xE",
            "transactionTime": 1565245656253,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_accounts_oco()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountsOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryMarginAccountsOcoResponse, "from_dict")
        ):
            expected = QueryMarginAccountsOcoResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountsOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_margin_accounts_oco_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_margin_accounts_oco() successfully with optional parameters."""

        params = {"order_list_id": 1, "orig_client_order_id": "1", "recv_window": 5000}

        expected_response = {
            "orderListId": 27,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "h2USkA5YQpaXHPIrkd96xE",
            "transactionTime": 1565245656253,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_accounts_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountsOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryMarginAccountsOcoResponse, "from_dict")
        ):
            expected = QueryMarginAccountsOcoResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountsOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_margin_accounts_oco_server_error(self):
        """Test that query_margin_accounts_oco() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_margin_accounts_oco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_margin_accounts_oco()

    @patch("binance_common.utils.get_signature")
    def test_query_margin_accounts_open_oco_success(self, mock_get_signature):
        """Test query_margin_accounts_open_oco() successfully with required parameters only."""

        expected_response = [
            {
                "orderListId": 31,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "wuB13fmulKj3YjdqWEcsnp",
                "transactionTime": 1565246080644,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
                    },
                ],
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_accounts_open_oco()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/openOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountsOpenOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryMarginAccountsOpenOcoResponse, "from_dict")
        ):
            expected = QueryMarginAccountsOpenOcoResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountsOpenOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_margin_accounts_open_oco_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_margin_accounts_open_oco() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = [
            {
                "orderListId": 31,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "wuB13fmulKj3YjdqWEcsnp",
                "transactionTime": 1565246080644,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
                    },
                ],
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_margin_accounts_open_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/openOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryMarginAccountsOpenOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryMarginAccountsOpenOcoResponse, "from_dict")
        ):
            expected = QueryMarginAccountsOpenOcoResponse.from_dict(expected_response)
        else:
            expected = QueryMarginAccountsOpenOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_margin_accounts_open_oco_server_error(self):
        """Test that query_margin_accounts_open_oco() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_margin_accounts_open_oco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_margin_accounts_open_oco()

    @patch("binance_common.utils.get_signature")
    def test_query_um_conditional_order_history_success(self, mock_get_signature):
        """Test query_um_conditional_order_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "TRIGGERED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "orderId": 12132343435,
            "status": "NEW",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "triggerTime": 1566818724750,
            "timeInForce": "GTC",
            "type": "MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_um_conditional_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/orderHistory" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUmConditionalOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUmConditionalOrderHistoryResponse, "from_dict")
        ):
            expected = QueryUmConditionalOrderHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryUmConditionalOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_um_conditional_order_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_um_conditional_order_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "strategy_id": 1,
            "new_client_strategy_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "newClientStrategyId": "abc",
            "strategyId": 123445,
            "strategyStatus": "TRIGGERED",
            "strategyType": "TRAILING_STOP_MARKET",
            "origQty": "0.40",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "stopPrice": "9300",
            "symbol": "BTCUSDT",
            "orderId": 12132343435,
            "status": "NEW",
            "bookTime": 1566818724710,
            "updateTime": 1566818724722,
            "triggerTime": 1566818724750,
            "timeInForce": "GTC",
            "type": "MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_um_conditional_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/conditional/orderHistory" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUmConditionalOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUmConditionalOrderHistoryResponse, "from_dict")
        ):
            expected = QueryUmConditionalOrderHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryUmConditionalOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_um_conditional_order_history_missing_required_param_symbol(self):
        """Test that query_um_conditional_order_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_um_conditional_order_history(**params)

    def test_query_um_conditional_order_history_server_error(self):
        """Test that query_um_conditional_order_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_um_conditional_order_history = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_um_conditional_order_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_um_modify_order_history_success(self, mock_get_signature):
        """Test query_um_modify_order_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
                "priceMatch": "NONE",
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
                "priceMatch": "NONE",
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
                "priceMatch": "NONE",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_um_modify_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUmModifyOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUmModifyOrderHistoryResponse, "from_dict")
        ):
            expected = QueryUmModifyOrderHistoryResponse.from_dict(expected_response)
        else:
            expected = QueryUmModifyOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_um_modify_order_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_um_modify_order_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
                "priceMatch": "NONE",
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
                "priceMatch": "NONE",
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
                "priceMatch": "NONE",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_um_modify_order_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUmModifyOrderHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUmModifyOrderHistoryResponse, "from_dict")
        ):
            expected = QueryUmModifyOrderHistoryResponse.from_dict(expected_response)
        else:
            expected = QueryUmModifyOrderHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_um_modify_order_history_missing_required_param_symbol(self):
        """Test that query_um_modify_order_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_um_modify_order_history(**params)

    def test_query_um_modify_order_history_server_error(self):
        """Test that query_um_modify_order_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_um_modify_order_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_um_modify_order_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_um_order_success(self, mock_get_signature):
        """Test query_um_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryUmOrderResponse, "from_dict"):
            expected = QueryUmOrderResponse.from_dict(expected_response)
        else:
            expected = QueryUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_um_order_success_with_optional_params(self, mock_get_signature):
        """Test query_um_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "LIMIT",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "LIMIT",
            "updateTime": 1579276756075,
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "priceMatch": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_um_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUmOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryUmOrderResponse, "from_dict"):
            expected = QueryUmOrderResponse.from_dict(expected_response)
        else:
            expected = QueryUmOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_um_order_missing_required_param_symbol(self):
        """Test that query_um_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_um_order(**params)

    def test_query_um_order_server_error(self):
        """Test that query_um_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_um_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_um_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_users_cm_force_orders_success(self, mock_get_signature):
        """Test query_users_cm_force_orders() successfully with required parameters only."""

        expected_response = [
            {
                "orderId": 165123080,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596542005017000006",
                "price": "11326.9",
                "avgPrice": "11326.9",
                "origQty": "1",
                "executedQty": "1",
                "cumBase": "0.00882854",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "origType": "LIMIT",
                "time": 1596542005019,
                "updateTime": 1596542005050,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_users_cm_force_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUsersCmForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryUsersCmForceOrdersResponse, "from_dict")
        ):
            expected = QueryUsersCmForceOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryUsersCmForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_users_cm_force_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_users_cm_force_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "auto_close_type": QueryUsersCmForceOrdersAutoCloseTypeEnum[
                "LIQUIDATION"
            ].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderId": 165123080,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596542005017000006",
                "price": "11326.9",
                "avgPrice": "11326.9",
                "origQty": "1",
                "executedQty": "1",
                "cumBase": "0.00882854",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "origType": "LIMIT",
                "time": 1596542005019,
                "updateTime": 1596542005050,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_users_cm_force_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/cm/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUsersCmForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryUsersCmForceOrdersResponse, "from_dict")
        ):
            expected = QueryUsersCmForceOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryUsersCmForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_users_cm_force_orders_server_error(self):
        """Test that query_users_cm_force_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_users_cm_force_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_users_cm_force_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_users_margin_force_orders_success(self, mock_get_signature):
        """Test query_users_margin_force_orders() successfully with required parameters only."""

        expected_response = {
            "rows": [
                {
                    "avgPrice": "0.00388359",
                    "executedQty": "31.39000000",
                    "orderId": 180015097,
                    "price": "0.00388110",
                    "qty": "31.39000000",
                    "side": "SELL",
                    "symbol": "BNBBTC",
                    "timeInForce": "GTC",
                    "updatedTime": 1558941374745,
                }
            ],
            "total": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_users_margin_force_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUsersMarginForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUsersMarginForceOrdersResponse, "from_dict")
        ):
            expected = QueryUsersMarginForceOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryUsersMarginForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_users_margin_force_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_users_margin_force_orders() successfully with optional parameters."""

        params = {
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "current": 1,
            "size": 10,
            "recv_window": 5000,
        }

        expected_response = {
            "rows": [
                {
                    "avgPrice": "0.00388359",
                    "executedQty": "31.39000000",
                    "orderId": 180015097,
                    "price": "0.00388110",
                    "qty": "31.39000000",
                    "side": "SELL",
                    "symbol": "BNBBTC",
                    "timeInForce": "GTC",
                    "updatedTime": 1558941374745,
                }
            ],
            "total": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_users_margin_force_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/margin/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUsersMarginForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUsersMarginForceOrdersResponse, "from_dict")
        ):
            expected = QueryUsersMarginForceOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryUsersMarginForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_users_margin_force_orders_server_error(self):
        """Test that query_users_margin_force_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_users_margin_force_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_users_margin_force_orders()

    @patch("binance_common.utils.get_signature")
    def test_query_users_um_force_orders_success(self, mock_get_signature):
        """Test query_users_um_force_orders() successfully with required parameters only."""

        expected_response = [
            {
                "orderId": 6071832819,
                "symbol": "BTCUSDT",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596107620040000020",
                "price": "10871.09",
                "avgPrice": "10913.21000",
                "origQty": "0.001",
                "executedQty": "0.001",
                "cumQuote": "10.91321",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "origType": "LIMIT",
                "time": 1596107620044,
                "updateTime": 1596107620087,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_users_um_force_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUsersUmForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryUsersUmForceOrdersResponse, "from_dict")
        ):
            expected = QueryUsersUmForceOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryUsersUmForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_users_um_force_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_users_um_force_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "auto_close_type": QueryUsersUmForceOrdersAutoCloseTypeEnum[
                "LIQUIDATION"
            ].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderId": 6071832819,
                "symbol": "BTCUSDT",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596107620040000020",
                "price": "10871.09",
                "avgPrice": "10913.21000",
                "origQty": "0.001",
                "executedQty": "0.001",
                "cumQuote": "10.91321",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "origType": "LIMIT",
                "time": 1596107620044,
                "updateTime": 1596107620087,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_users_um_force_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUsersUmForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(QueryUsersUmForceOrdersResponse, "from_dict")
        ):
            expected = QueryUsersUmForceOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryUsersUmForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_users_um_force_orders_server_error(self):
        """Test that query_users_um_force_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_users_um_force_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_users_um_force_orders()

    @patch("binance_common.utils.get_signature")
    def test_toggle_bnb_burn_on_um_futures_trade_success(self, mock_get_signature):
        """Test toggle_bnb_burn_on_um_futures_trade() successfully with required parameters only."""

        params = {
            "fee_burn": "fee_burn_example",
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.toggle_bnb_burn_on_um_futures_trade(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/feeBurn" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["feeBurn"] == "fee_burn_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ToggleBnbBurnOnUmFuturesTradeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ToggleBnbBurnOnUmFuturesTradeResponse, "from_dict")
        ):
            expected = ToggleBnbBurnOnUmFuturesTradeResponse.from_dict(
                expected_response
            )
        else:
            expected = ToggleBnbBurnOnUmFuturesTradeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_toggle_bnb_burn_on_um_futures_trade_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test toggle_bnb_burn_on_um_futures_trade() successfully with optional parameters."""

        params = {"fee_burn": "fee_burn_example", "recv_window": 5000}

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.toggle_bnb_burn_on_um_futures_trade(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/feeBurn" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ToggleBnbBurnOnUmFuturesTradeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ToggleBnbBurnOnUmFuturesTradeResponse, "from_dict")
        ):
            expected = ToggleBnbBurnOnUmFuturesTradeResponse.from_dict(
                expected_response
            )
        else:
            expected = ToggleBnbBurnOnUmFuturesTradeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_toggle_bnb_burn_on_um_futures_trade_missing_required_param_fee_burn(self):
        """Test that toggle_bnb_burn_on_um_futures_trade() raises RequiredError when 'fee_burn' is missing."""
        params = {
            "fee_burn": "fee_burn_example",
        }
        params["fee_burn"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'fee_burn'"
        ):
            self.client.toggle_bnb_burn_on_um_futures_trade(**params)

    def test_toggle_bnb_burn_on_um_futures_trade_server_error(self):
        """Test that toggle_bnb_burn_on_um_futures_trade() raises an error when the server returns an error."""

        params = {
            "fee_burn": "fee_burn_example",
        }

        mock_error = Exception("ResponseError")
        self.client.toggle_bnb_burn_on_um_futures_trade = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.toggle_bnb_burn_on_um_futures_trade(**params)

    @patch("binance_common.utils.get_signature")
    def test_um_account_trade_list_success(self, mock_get_signature):
        """Test um_account_trade_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "id": 67880589,
                "orderId": 270093109,
                "side": "SELL",
                "price": "28511.00",
                "qty": "0.010",
                "realizedPnl": "2.58500000",
                "quoteQty": "285.11000",
                "commission": "-0.11404400",
                "commissionAsset": "USDT",
                "time": 1680688557875,
                "buyer": False,
                "maker": False,
                "positionSide": "BOTH",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.um_account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UmAccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UmAccountTradeListResponse, "from_dict"):
            expected = UmAccountTradeListResponse.from_dict(expected_response)
        else:
            expected = UmAccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_um_account_trade_list_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test um_account_trade_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "id": 67880589,
                "orderId": 270093109,
                "side": "SELL",
                "price": "28511.00",
                "qty": "0.010",
                "realizedPnl": "2.58500000",
                "quoteQty": "285.11000",
                "commission": "-0.11404400",
                "commissionAsset": "USDT",
                "time": 1680688557875,
                "buyer": False,
                "maker": False,
                "positionSide": "BOTH",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.um_account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UmAccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UmAccountTradeListResponse, "from_dict"):
            expected = UmAccountTradeListResponse.from_dict(expected_response)
        else:
            expected = UmAccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_um_account_trade_list_missing_required_param_symbol(self):
        """Test that um_account_trade_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.um_account_trade_list(**params)

    def test_um_account_trade_list_server_error(self):
        """Test that um_account_trade_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.um_account_trade_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.um_account_trade_list(**params)

    @patch("binance_common.utils.get_signature")
    def test_um_position_adl_quantile_estimation_success(self, mock_get_signature):
        """Test um_position_adl_quantile_estimation() successfully with required parameters only."""

        expected_response = [
            {"symbol": "ETHUSDT", "adlQuantile": {"LONG": 3, "SHORT": 3, "BOTH": 0}},
            {"symbol": "BTCUSDT", "adlQuantile": {"LONG": 0, "SHORT": 0, "BOTH": 2}},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.um_position_adl_quantile_estimation()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UmPositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(UmPositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = UmPositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = UmPositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_um_position_adl_quantile_estimation_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test um_position_adl_quantile_estimation() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {"symbol": "ETHUSDT", "adlQuantile": {"LONG": 3, "SHORT": 3, "BOTH": 0}},
            {"symbol": "BTCUSDT", "adlQuantile": {"LONG": 0, "SHORT": 0, "BOTH": 2}},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.um_position_adl_quantile_estimation(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/papi/v1/um/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UmPositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(UmPositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = UmPositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = UmPositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_um_position_adl_quantile_estimation_server_error(self):
        """Test that um_position_adl_quantile_estimation() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.um_position_adl_quantile_estimation = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.um_position_adl_quantile_estimation()
