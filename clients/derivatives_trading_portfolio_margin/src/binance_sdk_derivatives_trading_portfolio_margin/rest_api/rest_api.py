"""
Binance Derivatives Trading Portfolio Margin REST API

OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import requests
from typing import Optional, TypeVar, Union
from binance_common.configuration import ConfigurationRestAPI
from binance_common.models import ApiResponse
from binance_common.signature import Signers
from binance_common.utils import send_request
from .api.account_api import AccountApi
from .api.market_data_api import MarketDataApi
from .api.trade_api import TradeApi
from .api.user_data_streams_api import UserDataStreamsApi

from .models import AccountBalanceResponse
from .models import AccountInformationResponse
from .models import BnbTransferResponse
from .models import ChangeAutoRepayFuturesStatusResponse
from .models import ChangeCmInitialLeverageResponse
from .models import ChangeCmPositionModeResponse
from .models import ChangeUmInitialLeverageResponse
from .models import ChangeUmPositionModeResponse
from .models import CmNotionalAndLeverageBracketsResponse
from .models import FundAutoCollectionResponse
from .models import FundCollectionByAssetResponse
from .models import GetAutoRepayFuturesStatusResponse
from .models import GetCmAccountDetailResponse
from .models import GetCmCurrentPositionModeResponse
from .models import GetCmIncomeHistoryResponse
from .models import GetDownloadIdForUmFuturesOrderHistoryResponse
from .models import GetDownloadIdForUmFuturesTradeHistoryResponse
from .models import GetDownloadIdForUmFuturesTransactionHistoryResponse
from .models import GetMarginBorrowLoanInterestHistoryResponse
from .models import GetUmAccountDetailResponse
from .models import GetUmAccountDetailV2Response
from .models import GetUmCurrentPositionModeResponse
from .models import GetUmFuturesOrderDownloadLinkByIdResponse
from .models import GetUmFuturesTradeDownloadLinkByIdResponse
from .models import GetUmFuturesTransactionDownloadLinkByIdResponse
from .models import GetUmIncomeHistoryResponse
from .models import GetUserCommissionRateForCmResponse
from .models import GetUserCommissionRateForUmResponse
from .models import MarginMaxBorrowResponse
from .models import PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse
from .models import QueryCmPositionInformationResponse
from .models import QueryMarginLoanRecordResponse
from .models import QueryMarginMaxWithdrawResponse
from .models import QueryMarginRepayRecordResponse
from .models import QueryPortfolioMarginNegativeBalanceInterestHistoryResponse
from .models import QueryUmPositionInformationResponse
from .models import QueryUserNegativeBalanceAutoExchangeRecordResponse
from .models import QueryUserRateLimitResponse
from .models import RepayFuturesNegativeBalanceResponse
from .models import UmFuturesAccountConfigurationResponse
from .models import UmFuturesSymbolConfigurationResponse
from .models import UmNotionalAndLeverageBracketsResponse

from .models import CancelAllCmOpenConditionalOrdersResponse
from .models import CancelAllCmOpenOrdersResponse
from .models import CancelAllUmOpenConditionalOrdersResponse
from .models import CancelAllUmOpenOrdersResponse
from .models import CancelCmConditionalOrderResponse
from .models import CancelCmOrderResponse
from .models import CancelMarginAccountAllOpenOrdersOnASymbolResponse
from .models import CancelMarginAccountOcoOrdersResponse
from .models import CancelMarginAccountOrderResponse
from .models import CancelUmConditionalOrderResponse
from .models import CancelUmOrderResponse
from .models import CmAccountTradeListResponse
from .models import CmPositionAdlQuantileEstimationResponse
from .models import GetUmFuturesBnbBurnStatusResponse
from .models import MarginAccountBorrowResponse
from .models import MarginAccountNewOcoResponse
from .models import MarginAccountRepayResponse
from .models import MarginAccountRepayDebtResponse
from .models import MarginAccountTradeListResponse
from .models import ModifyCmOrderResponse
from .models import ModifyUmOrderResponse
from .models import NewCmConditionalOrderResponse
from .models import NewCmOrderResponse
from .models import NewMarginOrderResponse
from .models import NewUmConditionalOrderResponse
from .models import NewUmOrderResponse
from .models import QueryAllCmConditionalOrdersResponse
from .models import QueryAllCmOrdersResponse
from .models import QueryAllCurrentCmOpenConditionalOrdersResponse
from .models import QueryAllCurrentCmOpenOrdersResponse
from .models import QueryAllCurrentUmOpenConditionalOrdersResponse
from .models import QueryAllCurrentUmOpenOrdersResponse
from .models import QueryAllMarginAccountOrdersResponse
from .models import QueryAllUmConditionalOrdersResponse
from .models import QueryAllUmOrdersResponse
from .models import QueryCmConditionalOrderHistoryResponse
from .models import QueryCmModifyOrderHistoryResponse
from .models import QueryCmOrderResponse
from .models import QueryCurrentCmOpenConditionalOrderResponse
from .models import QueryCurrentCmOpenOrderResponse
from .models import QueryCurrentMarginOpenOrderResponse
from .models import QueryCurrentUmOpenConditionalOrderResponse
from .models import QueryCurrentUmOpenOrderResponse
from .models import QueryMarginAccountOrderResponse
from .models import QueryMarginAccountsAllOcoResponse
from .models import QueryMarginAccountsOcoResponse
from .models import QueryMarginAccountsOpenOcoResponse
from .models import QueryUmConditionalOrderHistoryResponse
from .models import QueryUmModifyOrderHistoryResponse
from .models import QueryUmOrderResponse
from .models import QueryUsersCmForceOrdersResponse
from .models import QueryUsersMarginForceOrdersResponse
from .models import QueryUsersUmForceOrdersResponse
from .models import ToggleBnbBurnOnUmFuturesTradeResponse
from .models import UmAccountTradeListResponse
from .models import UmPositionAdlQuantileEstimationResponse


from .models import StartUserDataStreamResponse


from .models import MarginAccountNewOcoSideEnum
from .models import MarginAccountNewOcoStopLimitTimeInForceEnum
from .models import MarginAccountNewOcoNewOrderRespTypeEnum
from .models import MarginAccountNewOcoSideEffectTypeEnum
from .models import ModifyCmOrderSideEnum
from .models import ModifyCmOrderPriceMatchEnum
from .models import ModifyUmOrderSideEnum
from .models import ModifyUmOrderPriceMatchEnum
from .models import NewCmConditionalOrderSideEnum
from .models import NewCmConditionalOrderStrategyTypeEnum
from .models import NewCmConditionalOrderPositionSideEnum
from .models import NewCmConditionalOrderTimeInForceEnum
from .models import NewCmConditionalOrderWorkingTypeEnum
from .models import NewCmOrderSideEnum
from .models import NewCmOrderTypeEnum
from .models import NewCmOrderPositionSideEnum
from .models import NewCmOrderTimeInForceEnum
from .models import NewCmOrderPriceMatchEnum
from .models import NewCmOrderNewOrderRespTypeEnum
from .models import NewMarginOrderSideEnum
from .models import NewMarginOrderTypeEnum
from .models import NewMarginOrderNewOrderRespTypeEnum
from .models import NewMarginOrderSideEffectTypeEnum
from .models import NewMarginOrderTimeInForceEnum
from .models import NewMarginOrderSelfTradePreventionModeEnum
from .models import NewUmConditionalOrderSideEnum
from .models import NewUmConditionalOrderStrategyTypeEnum
from .models import NewUmConditionalOrderPositionSideEnum
from .models import NewUmConditionalOrderTimeInForceEnum
from .models import NewUmConditionalOrderWorkingTypeEnum
from .models import NewUmConditionalOrderPriceMatchEnum
from .models import NewUmConditionalOrderSelfTradePreventionModeEnum
from .models import NewUmOrderSideEnum
from .models import NewUmOrderTypeEnum
from .models import NewUmOrderPositionSideEnum
from .models import NewUmOrderTimeInForceEnum
from .models import NewUmOrderNewOrderRespTypeEnum
from .models import NewUmOrderPriceMatchEnum
from .models import NewUmOrderSelfTradePreventionModeEnum
from .models import QueryUsersCmForceOrdersAutoCloseTypeEnum
from .models import QueryUsersUmForceOrdersAutoCloseTypeEnum


T = TypeVar("T")


class DerivativesTradingPortfolioMarginRestAPI:
    def __init__(
        self,
        configuration: ConfigurationRestAPI,
    ) -> None:
        self.configuration = configuration
        self._session = requests.Session()
        self._signer = (
            Signers.get_signer(
                configuration.private_key, configuration.private_key_passphrase
            )
            if configuration.private_key is not None
            else None
        )

        self._accountApi = AccountApi(self.configuration, self._session, self._signer)
        self._marketDataApi = MarketDataApi(
            self.configuration, self._session, self._signer
        )
        self._tradeApi = TradeApi(self.configuration, self._session, self._signer)
        self._userDataStreamsApi = UserDataStreamsApi(
            self.configuration, self._session, self._signer
        )

    def send_request(
        self, endpoint: str, method: str, params: Optional[dict] = None
    ) -> ApiResponse[T]:
        """
        Sends an request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session, self.configuration, method, endpoint, params
        )

    def send_signed_request(
        self, endpoint: str, method: str, params: Optional[dict] = None
    ) -> ApiResponse[T]:
        """
        Sends a signed request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session,
            self.configuration,
            method,
            endpoint,
            params,
            is_signed=True,
            signer=self._signer,
        )

    def account_balance(
        self,
        asset: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AccountBalanceResponse]:
        """
                Account Balance(USER_DATA)

                Query account balance

        Weight: 20

                Args:
                    asset (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[AccountBalanceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.account_balance(asset, recv_window)

    def account_information(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AccountInformationResponse]:
        """
                Account Information(USER_DATA)

                Query account information

        Weight: 20

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[AccountInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.account_information(recv_window)

    def bnb_transfer(
        self,
        amount: Union[float, None],
        transfer_side: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[BnbTransferResponse]:
        """
                BNB transfer (TRADE)

                Transfer BNB in and out of UM

        * The endpoint can only be called 10 times per 10 minutes in a rolling manner

        Weight: 750

                Args:
                    amount (Union[float, None]):
                    transfer_side (Union[str, None]): "TO_UM","FROM_UM"
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[BnbTransferResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.bnb_transfer(amount, transfer_side, recv_window)

    def change_auto_repay_futures_status(
        self,
        auto_repay: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeAutoRepayFuturesStatusResponse]:
        """
                Change Auto-repay-futures Status(TRADE)

                Change Auto-repay-futures Status

        Weight: 750

                Args:
                    auto_repay (Union[str, None]): Default: `true`; `false` for turn off the auto-repay futures negative balance function
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeAutoRepayFuturesStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.change_auto_repay_futures_status(
            auto_repay, recv_window
        )

    def change_cm_initial_leverage(
        self,
        symbol: Union[str, None],
        leverage: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeCmInitialLeverageResponse]:
        """
                Change CM Initial Leverage (TRADE)

                Change user's initial leverage of specific symbol in CM.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    leverage (Union[int, None]): target initial leverage: int from 1 to 125
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeCmInitialLeverageResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.change_cm_initial_leverage(
            symbol, leverage, recv_window
        )

    def change_cm_position_mode(
        self,
        dual_side_position: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeCmPositionModeResponse]:
        """
                Change CM Position Mode(TRADE)

                Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM

        Weight: 1

                Args:
                    dual_side_position (Union[str, None]): "true": Hedge Mode; "false": One-way Mode
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeCmPositionModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.change_cm_position_mode(dual_side_position, recv_window)

    def change_um_initial_leverage(
        self,
        symbol: Union[str, None],
        leverage: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeUmInitialLeverageResponse]:
        """
                Change UM Initial Leverage(TRADE)

                Change user's initial leverage of specific symbol in UM.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    leverage (Union[int, None]): target initial leverage: int from 1 to 125
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeUmInitialLeverageResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.change_um_initial_leverage(
            symbol, leverage, recv_window
        )

    def change_um_position_mode(
        self,
        dual_side_position: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ChangeUmPositionModeResponse]:
        """
                Change UM Position Mode(TRADE)

                Change user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM

        Weight: 1

                Args:
                    dual_side_position (Union[str, None]): "true": Hedge Mode; "false": One-way Mode
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ChangeUmPositionModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.change_um_position_mode(dual_side_position, recv_window)

    def cm_notional_and_leverage_brackets(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CmNotionalAndLeverageBracketsResponse]:
        """
                CM Notional and Leverage Brackets(USER_DATA)

                Query CM notional and leverage brackets

        Weight: 1

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CmNotionalAndLeverageBracketsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.cm_notional_and_leverage_brackets(symbol, recv_window)

    def fund_auto_collection(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[FundAutoCollectionResponse]:
        """
                Fund Auto-collection(TRADE)

                Fund collection for Portfolio Margin

        * The BNB would not be collected from UM-PM account to the Portfolio Margin account.
        * You can only use this function 500 times per hour in a rolling manner.

        Weight: 750

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[FundAutoCollectionResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.fund_auto_collection(recv_window)

    def fund_collection_by_asset(
        self,
        asset: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[FundCollectionByAssetResponse]:
        """
                Fund Collection by Asset(TRADE)

                Transfers specific asset from Futures Account to Margin account

        * The BNB transfer is not be supported

        Weight: 30

                Args:
                    asset (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[FundCollectionByAssetResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.fund_collection_by_asset(asset, recv_window)

    def get_auto_repay_futures_status(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetAutoRepayFuturesStatusResponse]:
        """
                Get Auto-repay-futures Status(USER_DATA)

                Query Auto-repay-futures Status

        Weight: 30

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetAutoRepayFuturesStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_auto_repay_futures_status(recv_window)

    def get_cm_account_detail(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetCmAccountDetailResponse]:
        """
                Get CM Account Detail(USER_DATA)

                Get current CM account asset and position information.

        Weight: 5

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetCmAccountDetailResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_cm_account_detail(recv_window)

    def get_cm_current_position_mode(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetCmCurrentPositionModeResponse]:
        """
                Get CM Current Position Mode(USER_DATA)

                Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM

        Weight: 30

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetCmCurrentPositionModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_cm_current_position_mode(recv_window)

    def get_cm_income_history(
        self,
        symbol: Optional[str] = None,
        income_type: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        page: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetCmIncomeHistoryResponse]:
        """
                Get CM Income History(USER_DATA)

                Get CM Income History


        * If `incomeType` is not sent, all kinds of flow will be returned
        * "trandId" is unique in the same "incomeType" for a user
        * The interval between `startTime` and `endTime` can not exceed 200 days:
        * If `startTime` and `endTime` are not sent, the last 200 days will be returned

        Weight: 30

                Args:
                    symbol (Optional[str] = None):
                    income_type (Optional[str] = None): TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    page (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetCmIncomeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_cm_income_history(
            symbol, income_type, start_time, end_time, page, limit, recv_window
        )

    def get_download_id_for_um_futures_order_history(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDownloadIdForUmFuturesOrderHistoryResponse]:
        """
                Get Download Id For UM Futures Order History (USER_DATA)

                Get download id for UM futures order history

        * Request Limitation is 10 times per month, shared by front end download page and rest api
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 1500

                Args:
                    start_time (Union[int, None]):
                    end_time (Union[int, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetDownloadIdForUmFuturesOrderHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_download_id_for_um_futures_order_history(
            start_time, end_time, recv_window
        )

    def get_download_id_for_um_futures_trade_history(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDownloadIdForUmFuturesTradeHistoryResponse]:
        """
                Get Download Id For UM Futures Trade History (USER_DATA)

                Get download id for UM futures trade history

        * Request Limitation is 5 times per month, shared by front end download page and rest api
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 1500

                Args:
                    start_time (Union[int, None]):
                    end_time (Union[int, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetDownloadIdForUmFuturesTradeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_download_id_for_um_futures_trade_history(
            start_time, end_time, recv_window
        )

    def get_download_id_for_um_futures_transaction_history(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetDownloadIdForUmFuturesTransactionHistoryResponse]:
        """
                Get Download Id For UM Futures Transaction History (USER_DATA)

                Get download id for UM futures transaction history

        * Request Limitation is 5 times per month, shared by front end download page and rest api
        * The time between `startTime` and `endTime` can not be longer than 1 year

        Weight: 1500

                Args:
                    start_time (Union[int, None]):
                    end_time (Union[int, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetDownloadIdForUmFuturesTransactionHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_download_id_for_um_futures_transaction_history(
            start_time, end_time, recv_window
        )

    def get_margin_borrow_loan_interest_history(
        self,
        asset: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        archived: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetMarginBorrowLoanInterestHistoryResponse]:
        """
                Get Margin Borrow/Loan Interest History(USER_DATA)

                Get Margin Borrow/Loan Interest History


        * Response in descending order
        * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
        * If `startTime` and `endTime` not sent, return records of the last 7 days by default
        * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
        * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.
        * Type in response has 5 enums:
        * `PERIODIC` interest charged per hour
        * `ON_BORROW` first interest charged on borrow
        * `PERIODIC_CONVERTED` interest charged per hour converted into BNB
        * `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB
        * `PORTFOLIO` Portfolio Margin negative balance daily interest

        Weight: 1

                Args:
                    asset (Optional[str] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    archived (Optional[str] = None): Default: `false`. Set to `true` for archived data from 6 months ago
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetMarginBorrowLoanInterestHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_margin_borrow_loan_interest_history(
            asset, start_time, end_time, current, size, archived, recv_window
        )

    def get_um_account_detail(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmAccountDetailResponse]:
        """
                Get UM Account Detail(USER_DATA)

                Get current UM account asset and position information.

        Weight: 5

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmAccountDetailResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_account_detail(recv_window)

    def get_um_account_detail_v2(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmAccountDetailV2Response]:
        """
                Get UM Account Detail V2(USER_DATA)

                Get current UM account asset and position information.

        Weight: 5

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmAccountDetailV2Response]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_account_detail_v2(recv_window)

    def get_um_current_position_mode(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmCurrentPositionModeResponse]:
        """
                Get UM Current Position Mode(USER_DATA)

                Get user's position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM

        Weight: 30

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmCurrentPositionModeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_current_position_mode(recv_window)

    def get_um_futures_order_download_link_by_id(
        self,
        download_id: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmFuturesOrderDownloadLinkByIdResponse]:
        """
                Get UM Futures Order Download Link by Id(USER_DATA)

                Get UM futures order download link by Id

        * Download link expiration: 24h

        Weight: 10

                Args:
                    download_id (Union[str, None]): get by download id api
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmFuturesOrderDownloadLinkByIdResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_futures_order_download_link_by_id(
            download_id, recv_window
        )

    def get_um_futures_trade_download_link_by_id(
        self,
        download_id: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmFuturesTradeDownloadLinkByIdResponse]:
        """
                Get UM Futures Trade Download Link by Id(USER_DATA)

                Get UM futures trade download link by Id

        * Download link expiration: 24h

        Weight: 10

                Args:
                    download_id (Union[str, None]): get by download id api
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmFuturesTradeDownloadLinkByIdResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_futures_trade_download_link_by_id(
            download_id, recv_window
        )

    def get_um_futures_transaction_download_link_by_id(
        self,
        download_id: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmFuturesTransactionDownloadLinkByIdResponse]:
        """
                Get UM Futures Transaction Download Link by Id(USER_DATA)

                Get UM futures Transaction download link by Id

        * Download link expiration: 24h

        Weight: 10

                Args:
                    download_id (Union[str, None]): get by download id api
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmFuturesTransactionDownloadLinkByIdResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_futures_transaction_download_link_by_id(
            download_id, recv_window
        )

    def get_um_income_history(
        self,
        symbol: Optional[str] = None,
        income_type: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        page: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmIncomeHistoryResponse]:
        """
                Get UM Income History(USER_DATA)

                Get UM Income History

        * If neither `startTime` nor `endTime` is sent, the recent 7-day data will be returned.
        * If `incomeType` is not sent, all kinds of flow will be returned
        * "trandId" is unique in the same incomeType for a user
        * Income history only contains data for the last three months

        Weight: 30

                Args:
                    symbol (Optional[str] = None):
                    income_type (Optional[str] = None): TRANSFER, WELCOME_BONUS, REALIZED_PNL, FUNDING_FEE, COMMISSION, INSURANCE_CLEAR, REFERRAL_KICKBACK, COMMISSION_REBATE, API_REBATE, CONTEST_REWARD, CROSS_COLLATERAL_TRANSFER, OPTIONS_PREMIUM_FEE, OPTIONS_SETTLE_PROFIT, INTERNAL_TRANSFER, AUTO_EXCHANGE, DELIVERED_SETTELMENT, COIN_SWAP_DEPOSIT, COIN_SWAP_WITHDRAW, POSITION_LIMIT_INCREASE_FEE
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    page (Optional[int] = None):
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmIncomeHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_um_income_history(
            symbol, income_type, start_time, end_time, page, limit, recv_window
        )

    def get_user_commission_rate_for_cm(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUserCommissionRateForCmResponse]:
        """
                Get User Commission Rate for CM(USER_DATA)

                Get User Commission Rate for CM

        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUserCommissionRateForCmResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_user_commission_rate_for_cm(symbol, recv_window)

    def get_user_commission_rate_for_um(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUserCommissionRateForUmResponse]:
        """
                Get User Commission Rate for UM(USER_DATA)

                Get User Commission Rate for UM

        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUserCommissionRateForUmResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_user_commission_rate_for_um(symbol, recv_window)

    def margin_max_borrow(
        self,
        asset: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginMaxBorrowResponse]:
        """
                Margin Max Borrow(USER_DATA)

                Query margin max borrow

        Weight: 5

                Args:
                    asset (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[MarginMaxBorrowResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.margin_max_borrow(asset, recv_window)

    def portfolio_margin_um_trading_quantitative_rules_indicators(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse]:
        """
                Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)

                Portfolio Margin UM Trading Quantitative Rules Indicators

        Weight: 1 for a single symbol
        10 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return (
            self._accountApi.portfolio_margin_um_trading_quantitative_rules_indicators(
                symbol, recv_window
            )
        )

    def query_cm_position_information(
        self,
        margin_asset: Optional[str] = None,
        pair: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCmPositionInformationResponse]:
        """
                Query CM Position Information(USER_DATA)

                Get current CM position information.

        * If neither `marginAsset` nor `pair` is sent, positions of all symbols with `TRADING` status will be returned.
        * for One-way Mode user, the response will only show the "BOTH" positions
        * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.
        * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.

        Weight: 1

                Args:
                    margin_asset (Optional[str] = None):
                    pair (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCmPositionInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_cm_position_information(
            margin_asset, pair, recv_window
        )

    def query_margin_loan_record(
        self,
        asset: Union[str, None],
        tx_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        archived: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginLoanRecordResponse]:
        """
                Query Margin Loan Record(USER_DATA)

                Query margin loan record

        * txId or startTime must be sent. txId takes precedence.
        * Response in descending order
        * The max interval between `startTime` and `endTime` is 30 days.
        * If `startTime` and `endTime` not sent, return records of the last 7 days by default
        * Set `archived` to `true` to query data from 6 months ago

        Weight: 10

                Args:
                    asset (Union[str, None]):
                    tx_id (Optional[int] = None): the `tranId` in `POST/papi/v1/marginLoan`
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    archived (Optional[str] = None): Default: `false`. Set to `true` for archived data from 6 months ago
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginLoanRecordResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_margin_loan_record(
            asset, tx_id, start_time, end_time, current, size, archived, recv_window
        )

    def query_margin_max_withdraw(
        self,
        asset: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginMaxWithdrawResponse]:
        """
                Query Margin Max Withdraw(USER_DATA)

                Query Margin Max Withdraw

        Weight: 5

                Args:
                    asset (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginMaxWithdrawResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_margin_max_withdraw(asset, recv_window)

    def query_margin_repay_record(
        self,
        asset: Union[str, None],
        tx_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        archived: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginRepayRecordResponse]:
        """
                Query Margin repay Record(USER_DATA)

                Query margin repay record.

        * txId or startTime must be sent. txId takes precedence.
        * Response in descending order
        * The max interval between `startTime` and `endTime` is 30 days.
        * If `startTime` and `endTime` not sent, return records of the last 7 days by default
        * Set `archived` to `true` to query data from 6 months ago

        Weight: 10

                Args:
                    asset (Union[str, None]):
                    tx_id (Optional[int] = None): the `tranId` in `POST/papi/v1/marginLoan`
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    archived (Optional[str] = None): Default: `false`. Set to `true` for archived data from 6 months ago
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginRepayRecordResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_margin_repay_record(
            asset, tx_id, start_time, end_time, current, size, archived, recv_window
        )

    def query_portfolio_margin_negative_balance_interest_history(
        self,
        asset: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        size: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryPortfolioMarginNegativeBalanceInterestHistoryResponse]:
        """
                Query Portfolio Margin Negative Balance Interest History(USER_DATA)

                Query interest history of negative balance for portfolio margin.

        * Response in descending order
        * The max interval between startTime and endTime is 30 days. It is a MUST to ensure data correctness.
        * If `startTime` and `endTime` not sent, return records of the last 7 days by default
        * If `startTime` is sent and `endTime` is not sent, the records from `startTime` to the present will be returned; if `startTime` is more than 30 days ago, the records of the past 30 days will be returned.
        * If `startTime` is not sent and `endTime` is sent, the records of the 7 days before `endTime` is returned.

        Weight: 50

                Args:
                    asset (Optional[str] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    size (Optional[int] = None): Default:10 Max:100
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryPortfolioMarginNegativeBalanceInterestHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return (
            self._accountApi.query_portfolio_margin_negative_balance_interest_history(
                asset, start_time, end_time, size, recv_window
            )
        )

    def query_um_position_information(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUmPositionInformationResponse]:
        """
                Query UM Position Information(USER_DATA)

                Get current UM position information.

        * Please use with user data stream `ACCOUNT_UPDATE` to meet your timeliness and accuracy needs.
        * for One-way Mode user, the response will only show the "BOTH" positions
        * for Hedge Mode user, the response will show "LONG", and "SHORT" positions.

        Weight: 5

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUmPositionInformationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_um_position_information(symbol, recv_window)

    def query_user_negative_balance_auto_exchange_record(
        self,
        start_time: Union[int, None],
        end_time: Union[int, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUserNegativeBalanceAutoExchangeRecordResponse]:
        """
                Query User Negative Balance Auto Exchange Record (USER_DATA)

                Query user negative balance auto exchange record

        * Response in descending order
        * The max interval between `startTime` and `endTime` is 3 months.

        Weight: 100

                Args:
                    start_time (Union[int, None]):
                    end_time (Union[int, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUserNegativeBalanceAutoExchangeRecordResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_user_negative_balance_auto_exchange_record(
            start_time, end_time, recv_window
        )

    def query_user_rate_limit(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUserRateLimitResponse]:
        """
                Query User Rate Limit (USER_DATA)

                Query User Rate Limit

        Weight: 1

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUserRateLimitResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.query_user_rate_limit(recv_window)

    def repay_futures_negative_balance(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[RepayFuturesNegativeBalanceResponse]:
        """
                Repay futures Negative Balance(USER_DATA)

                Repay futures Negative Balance

        Weight: 750

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[RepayFuturesNegativeBalanceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.repay_futures_negative_balance(recv_window)

    def um_futures_account_configuration(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UmFuturesAccountConfigurationResponse]:
        """
                UM Futures Account Configuration(USER_DATA)

                Query UM Futures account configuration

        Weight: 5

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UmFuturesAccountConfigurationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.um_futures_account_configuration(recv_window)

    def um_futures_symbol_configuration(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UmFuturesSymbolConfigurationResponse]:
        """
                UM Futures Symbol Configuration(USER_DATA)

                Get current UM account symbol configuration.

        Weight: 5

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UmFuturesSymbolConfigurationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.um_futures_symbol_configuration(symbol, recv_window)

    def um_notional_and_leverage_brackets(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UmNotionalAndLeverageBracketsResponse]:
        """
                UM Notional and Leverage Brackets (USER_DATA)

                Query UM notional and leverage brackets

        Weight: 1

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UmNotionalAndLeverageBracketsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.um_notional_and_leverage_brackets(symbol, recv_window)

    def test_connectivity(
        self,
    ) -> ApiResponse[None]:
        """
                Test Connectivity

                Test connectivity to the Rest API.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketDataApi.test_connectivity()

    def cancel_all_cm_open_conditional_orders(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelAllCmOpenConditionalOrdersResponse]:
        """
                Cancel All CM Open Conditional Orders(TRADE)

                Cancel All CM Open Conditional Orders

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelAllCmOpenConditionalOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_all_cm_open_conditional_orders(symbol, recv_window)

    def cancel_all_cm_open_orders(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelAllCmOpenOrdersResponse]:
        """
                Cancel All CM Open Orders(TRADE)

                Cancel all active LIMIT orders on specific symbol

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelAllCmOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_all_cm_open_orders(symbol, recv_window)

    def cancel_all_um_open_conditional_orders(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelAllUmOpenConditionalOrdersResponse]:
        """
                Cancel All UM Open Conditional Orders (TRADE)

                Cancel All UM Open Conditional Orders

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelAllUmOpenConditionalOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_all_um_open_conditional_orders(symbol, recv_window)

    def cancel_all_um_open_orders(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelAllUmOpenOrdersResponse]:
        """
                Cancel All UM Open Orders(TRADE)

                Cancel all active LIMIT orders on specific symbol

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelAllUmOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_all_um_open_orders(symbol, recv_window)

    def cancel_cm_conditional_order(
        self,
        symbol: Union[str, None],
        strategy_id: Optional[int] = None,
        new_client_strategy_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelCmConditionalOrderResponse]:
        """
                Cancel CM Conditional Order(TRADE)

                Cancel CM Conditional Order

        * Either `strategyId` or `newClientStrategyId` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    strategy_id (Optional[int] = None):
                    new_client_strategy_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelCmConditionalOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_cm_conditional_order(
            symbol, strategy_id, new_client_strategy_id, recv_window
        )

    def cancel_cm_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelCmOrderResponse]:
        """
                Cancel CM Order(TRADE)

                Cancel an active LIMIT order

        * Either `orderId` or `origClientOrderId` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelCmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_cm_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def cancel_margin_account_all_open_orders_on_a_symbol(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelMarginAccountAllOpenOrdersOnASymbolResponse]:
        """
                Cancel Margin Account All Open Orders on a Symbol(TRADE)

                Cancel Margin Account All Open Orders on a Symbol

        Weight: 5

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelMarginAccountAllOpenOrdersOnASymbolResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_margin_account_all_open_orders_on_a_symbol(
            symbol, recv_window
        )

    def cancel_margin_account_oco_orders(
        self,
        symbol: Union[str, None],
        order_list_id: Optional[int] = None,
        list_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelMarginAccountOcoOrdersResponse]:
        """
                Cancel Margin Account OCO Orders(TRADE)

                Cancel Margin Account OCO Orders

        * Additional notes: Canceling an individual leg will cancel the entire OCO

        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    order_list_id (Optional[int] = None): Either `orderListId` or `listClientOrderId` must be provided
                    list_client_order_id (Optional[str] = None): Either `orderListId` or `listClientOrderId` must be provided
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelMarginAccountOcoOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_margin_account_oco_orders(
            symbol,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        )

    def cancel_margin_account_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelMarginAccountOrderResponse]:
        """
                Cancel Margin Account Order(TRADE)

                Cancel Margin Account Order

        * Either `orderId` or `origClientOrderId` must be sent.

        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelMarginAccountOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_margin_account_order(
            symbol, order_id, orig_client_order_id, new_client_order_id, recv_window
        )

    def cancel_um_conditional_order(
        self,
        symbol: Union[str, None],
        strategy_id: Optional[int] = None,
        new_client_strategy_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelUmConditionalOrderResponse]:
        """
                Cancel UM Conditional Order(TRADE)

                Cancel UM Conditional Order

        * Either `strategyId` or `newClientStrategyId` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    strategy_id (Optional[int] = None):
                    new_client_strategy_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelUmConditionalOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_um_conditional_order(
            symbol, strategy_id, new_client_strategy_id, recv_window
        )

    def cancel_um_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CancelUmOrderResponse]:
        """
                Cancel UM Order(TRADE)

                Cancel an active UM LIMIT order

        * Either `orderId` or `origClientOrderId` must be sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CancelUmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cancel_um_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def cm_account_trade_list(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CmAccountTradeListResponse]:
        """
                CM Account Trade List(USER_DATA)

                Get trades for a specific account and CM symbol.

        * Either `symbol` or `pair` must be sent
        * `symbol` and `pair` cannot be sent together
        * `pair` and `fromId` cannot be sent together
        * `OrderId` can only be sent together with symbol
        * If a `pair` is sent, tickers for all symbols of the `pair` will be returned
        * The parameter `fromId` cannot be sent with `startTime` or `endTime`
        * If `startTime` and `endTime` are both not sent, then the last '24 hours' data will be returned.
        * The time between `startTime` and `endTime` cannot be longer than 24 hours.

        Weight: 20 with symbol, 40 with pair

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    from_id (Optional[int] = None): Trade id to fetch from. Default gets most recent trades.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CmAccountTradeListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cm_account_trade_list(
            symbol, pair, start_time, end_time, from_id, limit, recv_window
        )

    def cm_position_adl_quantile_estimation(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[CmPositionAdlQuantileEstimationResponse]:
        """
                CM Position ADL Quantile Estimation(USER_DATA)

                Query CM Position ADL Quantile Estimation
        * Values update every 30s.
        * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
        * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
        * If the positions of the symbol are crossed margined in Hedge Mode:
        * "HEDGE" as a sign will be returned instead of "BOTH";
        * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.

        Weight: 5

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[CmPositionAdlQuantileEstimationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.cm_position_adl_quantile_estimation(symbol, recv_window)

    def get_um_futures_bnb_burn_status(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetUmFuturesBnbBurnStatusResponse]:
        """
                Get UM Futures BNB Burn Status (USER_DATA)

                Get user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )

        Weight: 30

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[GetUmFuturesBnbBurnStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.get_um_futures_bnb_burn_status(recv_window)

    def margin_account_borrow(
        self,
        asset: Union[str, None],
        amount: Union[float, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountBorrowResponse]:
        """
                Margin Account Borrow(MARGIN)

                Apply for a margin loan.

        Weight: 100

                Args:
                    asset (Union[str, None]):
                    amount (Union[float, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[MarginAccountBorrowResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_borrow(asset, amount, recv_window)

    def margin_account_new_oco(
        self,
        symbol: Union[str, None],
        side: Union[MarginAccountNewOcoSideEnum, None],
        quantity: Union[float, None],
        price: Union[float, None],
        stop_price: Union[float, None],
        list_client_order_id: Optional[str] = None,
        limit_client_order_id: Optional[str] = None,
        limit_iceberg_qty: Optional[float] = None,
        stop_client_order_id: Optional[str] = None,
        stop_limit_price: Optional[float] = None,
        stop_iceberg_qty: Optional[float] = None,
        stop_limit_time_in_force: Optional[
            MarginAccountNewOcoStopLimitTimeInForceEnum
        ] = None,
        new_order_resp_type: Optional[MarginAccountNewOcoNewOrderRespTypeEnum] = None,
        side_effect_type: Optional[MarginAccountNewOcoSideEffectTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountNewOcoResponse]:
        """
                Margin Account New OCO(TRADE)

                Send in a new OCO for a margin account

        * Price Restrictions:
        * `SELL`: Limit Price > Last Price > Stop Price
        * `BUY`: Limit Price < Last Price < Stop Price
        * Quantity Restrictions:
        * Both legs must have the same quantity
        * `ICEBERG` quantities however do not have to be the same.
        * Order Rate Limit
        * `OCO` counts as 2 orders against the order rate limit.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[MarginAccountNewOcoSideEnum, None]):
                    quantity (Union[float, None]): Order quantity
                    price (Union[float, None]):
                    stop_price (Union[float, None]):
                    list_client_order_id (Optional[str] = None): Either `orderListId` or `listClientOrderId` must be provided
                    limit_client_order_id (Optional[str] = None): A unique Id for the limit order
                    limit_iceberg_qty (Optional[float] = None):
                    stop_client_order_id (Optional[str] = None): A unique Id for the stop loss/stop loss limit leg
                    stop_limit_price (Optional[float] = None): If provided, stopLimitTimeInForce is required.
                    stop_iceberg_qty (Optional[float] = None):
                    stop_limit_time_in_force (Optional[MarginAccountNewOcoStopLimitTimeInForceEnum] = None): Valid values are `GTC/FOK/IOC`
                    new_order_resp_type (Optional[MarginAccountNewOcoNewOrderRespTypeEnum] = None): "ACK", "RESULT", default "ACK"
                    side_effect_type (Optional[MarginAccountNewOcoSideEffectTypeEnum] = None): NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY; default NO_SIDE_EFFECT.
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[MarginAccountNewOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_new_oco(
            symbol,
            side,
            quantity,
            price,
            stop_price,
            list_client_order_id,
            limit_client_order_id,
            limit_iceberg_qty,
            stop_client_order_id,
            stop_limit_price,
            stop_iceberg_qty,
            stop_limit_time_in_force,
            new_order_resp_type,
            side_effect_type,
            recv_window,
        )

    def margin_account_repay(
        self,
        asset: Union[str, None],
        amount: Union[float, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountRepayResponse]:
        """
                Margin Account Repay(MARGIN)

                Repay for a margin loan.

        Weight: 100

                Args:
                    asset (Union[str, None]):
                    amount (Union[float, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[MarginAccountRepayResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_repay(asset, amount, recv_window)

    def margin_account_repay_debt(
        self,
        asset: Union[str, None],
        amount: Optional[str] = None,
        specify_repay_assets: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountRepayDebtResponse]:
        """
                Margin Account Repay Debt(TRADE)

                Repay debt for a margin loan.

        * The repay asset amount cannot exceed 50000 USD equivalent value for a single request.
        * If `amount` is not sent, all the asset loan will be repaid if having enough specific repay assets.
        * If `amount` is sent, only the certain amount of the asset loan will be repaid if having enough specific repay assets.
        * The system will use the same asset to repay the loan first (if have) no matter whether put the asset in `specifyRepayAssets`

        Weight: 3000

                Args:
                    asset (Union[str, None]):
                    amount (Optional[str] = None):
                    specify_repay_assets (Optional[str] = None): Specific asset list to repay debt; Can be added in batch, separated by commas
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[MarginAccountRepayDebtResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_repay_debt(
            asset, amount, specify_repay_assets, recv_window
        )

    def margin_account_trade_list(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MarginAccountTradeListResponse]:
        """
                Margin Account Trade List (USER_DATA)

                Margin Account Trade List

        Weight: 5

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    from_id (Optional[int] = None): Trade id to fetch from. Default gets most recent trades.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[MarginAccountTradeListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.margin_account_trade_list(
            symbol, order_id, start_time, end_time, from_id, limit, recv_window
        )

    def modify_cm_order(
        self,
        symbol: Union[str, None],
        side: Union[ModifyCmOrderSideEnum, None],
        quantity: Union[float, None],
        price: Union[float, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        price_match: Optional[ModifyCmOrderPriceMatchEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ModifyCmOrderResponse]:
        """
                Modify CM Order(TRADE)

                Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

        * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.
        * Both `quantity` and `price` must be sent
        * When the new `quantity` or `price` doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
        * However the order will be cancelled by the amendment in the following situations:
        * when the order is in partially filled status and the new `quantity` <= `executedQty`
        * When the order is `GTX` and the new price will cause it to be executed immediately

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[ModifyCmOrderSideEnum, None]):
                    quantity (Union[float, None]): Order quantity
                    price (Union[float, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    price_match (Optional[ModifyCmOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ModifyCmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.modify_cm_order(
            symbol,
            side,
            quantity,
            price,
            order_id,
            orig_client_order_id,
            price_match,
            recv_window,
        )

    def modify_um_order(
        self,
        symbol: Union[str, None],
        side: Union[ModifyUmOrderSideEnum, None],
        quantity: Union[float, None],
        price: Union[float, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        price_match: Optional[ModifyUmOrderPriceMatchEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ModifyUmOrderResponse]:
        """
                Modify UM Order(TRADE)

                Order modify function, currently only LIMIT order modification is supported, modified orders will be reordered in the match queue

        * Either orderId or origClientOrderId must be sent, and the orderId will prevail if both are sent.
        * Both quantity and price must be sent
        * When the new quantity or price doesn't satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is.
        * However the order will be cancelled by the amendment in the following situations:
        * when the order is in partially filled status and the new quantity <= executedQty
        * When the order is GTX and the new price will cause it to be executed immediately

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[ModifyUmOrderSideEnum, None]):
                    quantity (Union[float, None]): Order quantity
                    price (Union[float, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    price_match (Optional[ModifyUmOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ModifyUmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.modify_um_order(
            symbol,
            side,
            quantity,
            price,
            order_id,
            orig_client_order_id,
            price_match,
            recv_window,
        )

    def new_cm_conditional_order(
        self,
        symbol: Union[str, None],
        side: Union[NewCmConditionalOrderSideEnum, None],
        strategy_type: Union[NewCmConditionalOrderStrategyTypeEnum, None],
        position_side: Optional[NewCmConditionalOrderPositionSideEnum] = None,
        time_in_force: Optional[NewCmConditionalOrderTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        reduce_only: Optional[str] = None,
        price: Optional[float] = None,
        working_type: Optional[NewCmConditionalOrderWorkingTypeEnum] = None,
        price_protect: Optional[str] = None,
        new_client_strategy_id: Optional[str] = None,
        stop_price: Optional[float] = None,
        activation_price: Optional[float] = None,
        callback_rate: Optional[float] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewCmConditionalOrderResponse]:
        """
                New CM Conditional Order(TRADE)

                New CM Conditional Order

        * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
        * Condition orders will be triggered when:
        * `STOP`, `STOP_MARKET`:
        * BUY: "MARK_PRICE"  >= `stopPrice`
        * SELL: "MARK_PRICE" <= `stopPrice`
        * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
        * BUY: "MARK_PRICE" <= `stopPrice`
        * SELL: "MARK_PRICE" >= `stopPrice`
        * `TRAILING_STOP_MARKET`:
        * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
        * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
        * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
        * BUY: `activationPrice` should be smaller than latest mark price.
        * SELL: `activationPrice` should be larger than latest mark price.
        * Condition orders will be triggered when:
        * If parameter`priceProtect`is sent as true:
        * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
        * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
        * `STOP`, `STOP_MARKET`:
        * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
        * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
        * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
        * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
        * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewCmConditionalOrderSideEnum, None]):
                    strategy_type (Union[NewCmConditionalOrderStrategyTypeEnum, None]): "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
                    position_side (Optional[NewCmConditionalOrderPositionSideEnum] = None): Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
                    time_in_force (Optional[NewCmConditionalOrderTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    reduce_only (Optional[str] = None): "true" or "false". default "false". Cannot be sent in Hedge Mode .
                    price (Optional[float] = None):
                    working_type (Optional[NewCmConditionalOrderWorkingTypeEnum] = None): stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
                    price_protect (Optional[str] = None): "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
                    new_client_strategy_id (Optional[str] = None):
                    stop_price (Optional[float] = None): Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
                    activation_price (Optional[float] = None): Used with `TRAILING_STOP_MARKET` orders, default as the mark price
                    callback_rate (Optional[float] = None): Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NewCmConditionalOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_cm_conditional_order(
            symbol,
            side,
            strategy_type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            working_type,
            price_protect,
            new_client_strategy_id,
            stop_price,
            activation_price,
            callback_rate,
            recv_window,
        )

    def new_cm_order(
        self,
        symbol: Union[str, None],
        side: Union[NewCmOrderSideEnum, None],
        type: Union[NewCmOrderTypeEnum, None],
        position_side: Optional[NewCmOrderPositionSideEnum] = None,
        time_in_force: Optional[NewCmOrderTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        reduce_only: Optional[str] = None,
        price: Optional[float] = None,
        price_match: Optional[NewCmOrderPriceMatchEnum] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[NewCmOrderNewOrderRespTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewCmOrderResponse]:
        """
                New CM Order(TRADE)

                Place new CM order

        * If `newOrderRespType` is sent as `RESULT` :
        * `MARKET` order: the final FILLED result of the order will be return directly.
        * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewCmOrderSideEnum, None]):
                    type (Union[NewCmOrderTypeEnum, None]): `LIMIT`, `MARKET`
                    position_side (Optional[NewCmOrderPositionSideEnum] = None): Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
                    time_in_force (Optional[NewCmOrderTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    reduce_only (Optional[str] = None): "true" or "false". default "false". Cannot be sent in Hedge Mode .
                    price (Optional[float] = None):
                    price_match (Optional[NewCmOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    new_order_resp_type (Optional[NewCmOrderNewOrderRespTypeEnum] = None): "ACK", "RESULT", default "ACK"
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NewCmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_cm_order(
            symbol,
            side,
            type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            price_match,
            new_client_order_id,
            new_order_resp_type,
            recv_window,
        )

    def new_margin_order(
        self,
        symbol: Union[str, None],
        side: Union[NewMarginOrderSideEnum, None],
        type: Union[NewMarginOrderTypeEnum, None],
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        price: Optional[float] = None,
        stop_price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[NewMarginOrderNewOrderRespTypeEnum] = None,
        iceberg_qty: Optional[float] = None,
        side_effect_type: Optional[NewMarginOrderSideEffectTypeEnum] = None,
        time_in_force: Optional[NewMarginOrderTimeInForceEnum] = None,
        self_trade_prevention_mode: Optional[
            NewMarginOrderSelfTradePreventionModeEnum
        ] = None,
        auto_repay_at_cancel: Optional[bool] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewMarginOrderResponse]:
        """
                New Margin Order(TRADE)

                New Margin Order

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewMarginOrderSideEnum, None]):
                    type (Union[NewMarginOrderTypeEnum, None]): `LIMIT`, `MARKET`
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    price (Optional[float] = None):
                    stop_price (Optional[float] = None): Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    new_order_resp_type (Optional[NewMarginOrderNewOrderRespTypeEnum] = None): "ACK", "RESULT", default "ACK"
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order
                    side_effect_type (Optional[NewMarginOrderSideEffectTypeEnum] = None): NO_SIDE_EFFECT, MARGIN_BUY, AUTO_REPAY; default NO_SIDE_EFFECT.
                    time_in_force (Optional[NewMarginOrderTimeInForceEnum] = None):
                    self_trade_prevention_mode (Optional[NewMarginOrderSelfTradePreventionModeEnum] = None): `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
                    auto_repay_at_cancel (Optional[bool] = None): truetrue
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NewMarginOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_margin_order(
            symbol,
            side,
            type,
            quantity,
            quote_order_qty,
            price,
            stop_price,
            new_client_order_id,
            new_order_resp_type,
            iceberg_qty,
            side_effect_type,
            time_in_force,
            self_trade_prevention_mode,
            auto_repay_at_cancel,
            recv_window,
        )

    def new_um_conditional_order(
        self,
        symbol: Union[str, None],
        side: Union[NewUmConditionalOrderSideEnum, None],
        strategy_type: Union[NewUmConditionalOrderStrategyTypeEnum, None],
        position_side: Optional[NewUmConditionalOrderPositionSideEnum] = None,
        time_in_force: Optional[NewUmConditionalOrderTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        reduce_only: Optional[str] = None,
        price: Optional[float] = None,
        working_type: Optional[NewUmConditionalOrderWorkingTypeEnum] = None,
        price_protect: Optional[str] = None,
        new_client_strategy_id: Optional[str] = None,
        stop_price: Optional[float] = None,
        activation_price: Optional[float] = None,
        callback_rate: Optional[float] = None,
        price_match: Optional[NewUmConditionalOrderPriceMatchEnum] = None,
        self_trade_prevention_mode: Optional[
            NewUmConditionalOrderSelfTradePreventionModeEnum
        ] = None,
        good_till_date: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewUmConditionalOrderResponse]:
        """
                New UM Conditional Order (TRADE)

                Place new UM conditional order

        * Order with type `STOP/TAKE_PROFIT`, parameter `timeInForce` can be sent ( default `GTC`).
        * Condition orders will be triggered when:
        * `STOP`, `STOP_MARKET`:
        * BUY: "MARK_PRICE"  >= `stopPrice`
        * SELL: "MARK_PRICE" <= `stopPrice`
        * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
        * BUY: "MARK_PRICE" <= `stopPrice`
        * SELL: "MARK_PRICE" >= `stopPrice`
        * `TRAILING_STOP_MARKET`:
        * BUY: the lowest mark price after order placed `<= `activationPrice`, and the latest mark price >`= the lowest mark price * (1 + `callbackRate`)
        * SELL: the highest mark price after order placed >= `activationPrice`, and the latest mark price <= the highest mark price * (1 - `callbackRate`)
        * For `TRAILING_STOP_MARKET`, if you got such error code. `{"code": -2021, "msg": "Order would immediately trigger."}` means that the parameters you send do not meet the following requirements:
        * BUY: `activationPrice` should be smaller than latest mark price.
        * SELL: `activationPrice` should be larger than latest mark price.
        * Condition orders will be triggered when:
        * If parameter`priceProtect`is sent as true:
        * when price reaches the `stopPrice` the difference rate between "MARK_PRICE" and "CONTRACT_PRICE" cannot be larger than the "triggerProtect" of the symbol
        * "triggerProtect" of a symbol can be got from `GET /fapi/v1/exchangeInfo`
        * `STOP`, `STOP_MARKET`:
        * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
        * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
        * `TAKE_PROFIT`, `TAKE_PROFIT_MARKET`:
        * BUY: latest price ("MARK_PRICE" or "CONTRACT_PRICE") <= `stopPrice`
        * SELL: latest price ("MARK_PRICE" or "CONTRACT_PRICE") >= `stopPrice`
        * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
        * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewUmConditionalOrderSideEnum, None]):
                    strategy_type (Union[NewUmConditionalOrderStrategyTypeEnum, None]): "STOP", "STOP_MARKET", "TAKE_PROFIT", "TAKE_PROFIT_MARKET", and "TRAILING_STOP_MARKET"
                    position_side (Optional[NewUmConditionalOrderPositionSideEnum] = None): Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
                    time_in_force (Optional[NewUmConditionalOrderTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    reduce_only (Optional[str] = None): "true" or "false". default "false". Cannot be sent in Hedge Mode .
                    price (Optional[float] = None):
                    working_type (Optional[NewUmConditionalOrderWorkingTypeEnum] = None): stopPrice triggered by: "MARK_PRICE", "CONTRACT_PRICE". Default "CONTRACT_PRICE"
                    price_protect (Optional[str] = None): "TRUE" or "FALSE", default "FALSE". Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders
                    new_client_strategy_id (Optional[str] = None):
                    stop_price (Optional[float] = None): Used with `STOP/STOP_MARKET` or `TAKE_PROFIT/TAKE_PROFIT_MARKET` orders.
                    activation_price (Optional[float] = None): Used with `TRAILING_STOP_MARKET` orders, default as the mark price
                    callback_rate (Optional[float] = None): Used with `TRAILING_STOP_MARKET` orders, min 0.1, max 5 where 1 for 1%
                    price_match (Optional[NewUmConditionalOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    self_trade_prevention_mode (Optional[NewUmConditionalOrderSelfTradePreventionModeEnum] = None): `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
                    good_till_date (Optional[int] = None): order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NewUmConditionalOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_um_conditional_order(
            symbol,
            side,
            strategy_type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            working_type,
            price_protect,
            new_client_strategy_id,
            stop_price,
            activation_price,
            callback_rate,
            price_match,
            self_trade_prevention_mode,
            good_till_date,
            recv_window,
        )

    def new_um_order(
        self,
        symbol: Union[str, None],
        side: Union[NewUmOrderSideEnum, None],
        type: Union[NewUmOrderTypeEnum, None],
        position_side: Optional[NewUmOrderPositionSideEnum] = None,
        time_in_force: Optional[NewUmOrderTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        reduce_only: Optional[str] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[NewUmOrderNewOrderRespTypeEnum] = None,
        price_match: Optional[NewUmOrderPriceMatchEnum] = None,
        self_trade_prevention_mode: Optional[
            NewUmOrderSelfTradePreventionModeEnum
        ] = None,
        good_till_date: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewUmOrderResponse]:
        """
                New UM Order (TRADE)

                Place new UM order

        * If `newOrderRespType` is sent as `RESULT` :
        * `MARKET` order: the final FILLED result of the order will be return directly.
        * `LIMIT` order with special `timeInForce`: the final status result of the order(FILLED or EXPIRED) will be returned directly.
        * `selfTradePreventionMode` is only effective when `timeInForce` set to `IOC` or `GTC` or `GTD`.
        * In extreme market conditions, timeInForce `GTD` order auto cancel time might be delayed comparing to `goodTillDate`

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewUmOrderSideEnum, None]):
                    type (Union[NewUmOrderTypeEnum, None]): `LIMIT`, `MARKET`
                    position_side (Optional[NewUmOrderPositionSideEnum] = None): Default `BOTH` for One-way Mode ; `LONG` or `SHORT` for Hedge Mode. It must be sent in Hedge Mode.
                    time_in_force (Optional[NewUmOrderTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    reduce_only (Optional[str] = None): "true" or "false". default "false". Cannot be sent in Hedge Mode .
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default
                    new_order_resp_type (Optional[NewUmOrderNewOrderRespTypeEnum] = None): "ACK", "RESULT", default "ACK"
                    price_match (Optional[NewUmOrderPriceMatchEnum] = None): only avaliable for `LIMIT`/`STOP`/`TAKE_PROFIT` order; can be set to `OPPONENT`/ `OPPONENT_5`/ `OPPONENT_10`/ `OPPONENT_20`: /`QUEUE`/ `QUEUE_5`/ `QUEUE_10`/ `QUEUE_20`; Can't be passed together with `price`
                    self_trade_prevention_mode (Optional[NewUmOrderSelfTradePreventionModeEnum] = None): `NONE`:No STP / `EXPIRE_TAKER`:expire taker order when STP triggers/ `EXPIRE_MAKER`:expire taker order when STP triggers/ `EXPIRE_BOTH`:expire both orders when STP triggers
                    good_till_date (Optional[int] = None): order cancel time for timeInForce `GTD`, mandatory when `timeInforce` set to `GTD`; order the timestamp only retains second-level precision, ms part will be ignored; The goodTillDate timestamp must be greater than the current time plus 600 seconds and smaller than 253402300799000Mode. It must be sent in Hedge Mode.
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[NewUmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_um_order(
            symbol,
            side,
            type,
            position_side,
            time_in_force,
            quantity,
            reduce_only,
            price,
            new_client_order_id,
            new_order_resp_type,
            price_match,
            self_trade_prevention_mode,
            good_till_date,
            recv_window,
        )

    def query_all_cm_conditional_orders(
        self,
        symbol: Optional[str] = None,
        strategy_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllCmConditionalOrdersResponse]:
        """
                Query All CM Conditional Orders(USER_DATA)

                Query All CM Conditional Orders

        * These orders will not be found:
        * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 7 days < current time
        * The query time period must be less than 7 days( default as the recent 7 days).

        Weight: 1 for a single symbol; 40 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    strategy_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllCmConditionalOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_cm_conditional_orders(
            symbol, strategy_id, start_time, end_time, limit, recv_window
        )

    def query_all_cm_orders(
        self,
        symbol: Union[str, None],
        pair: Optional[str] = None,
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllCmOrdersResponse]:
        """
                Query All CM Orders (USER_DATA)

                Get all account CM orders; active, canceled, or filled.

        * Either `symbol` or `pair` must be sent.
        * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
        * These orders will not be found:
        * order status is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 3 days < current time

        Weight: 20 with symbol, 40 with pair

                Args:
                    symbol (Union[str, None]):
                    pair (Optional[str] = None):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllCmOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_cm_orders(
            symbol, pair, order_id, start_time, end_time, limit, recv_window
        )

    def query_all_current_cm_open_conditional_orders(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllCurrentCmOpenConditionalOrdersResponse]:
        """
                Query All Current CM Open Conditional Orders (USER_DATA)

                Get all open conditional orders on a symbol. **Careful** when accessing this with no symbol.

        * If the symbol is not sent, orders for all symbols will be returned in an array.

        Weight: 1 for a single symbol; 40 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllCurrentCmOpenConditionalOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_current_cm_open_conditional_orders(
            symbol, recv_window
        )

    def query_all_current_cm_open_orders(
        self,
        symbol: Optional[str] = None,
        pair: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllCurrentCmOpenOrdersResponse]:
        """
                Query All Current CM Open Orders(USER_DATA)

                Get all open orders on a symbol.

        * If the symbol is not sent, orders for all symbols will be returned in an array.

        Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
        Careful when accessing this with no symbol.

                Args:
                    symbol (Optional[str] = None):
                    pair (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllCurrentCmOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_current_cm_open_orders(
            symbol, pair, recv_window
        )

    def query_all_current_um_open_conditional_orders(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllCurrentUmOpenConditionalOrdersResponse]:
        """
                Query All Current UM Open Conditional Orders(USER_DATA)

                Get all open conditional orders on a symbol.

        * If the symbol is not sent, orders for all symbols will be returned in an array.

        Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
        Careful when accessing this with no symbol.

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllCurrentUmOpenConditionalOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_current_um_open_conditional_orders(
            symbol, recv_window
        )

    def query_all_current_um_open_orders(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllCurrentUmOpenOrdersResponse]:
        """
                Query All Current UM Open Orders(USER_DATA)

                Get all open orders on a symbol.


        * If the symbol is not sent, orders for all symbols will be returned in an array.

        Weight: 1 for a single symbol; 40 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllCurrentUmOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_current_um_open_orders(symbol, recv_window)

    def query_all_margin_account_orders(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllMarginAccountOrdersResponse]:
        """
                Query All Margin Account Orders (USER_DATA)

                Query All Margin Account Orders

        Weight: 100

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllMarginAccountOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_margin_account_orders(
            symbol, order_id, start_time, end_time, limit, recv_window
        )

    def query_all_um_conditional_orders(
        self,
        symbol: Optional[str] = None,
        strategy_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllUmConditionalOrdersResponse]:
        """
                Query All UM Conditional Orders(USER_DATA)

                Query All UM Conditional Orders

        * These orders will not be found:
        * order strategyStatus is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 7 days < current time
        * The query time period must be less than 7 days( default as the recent 7 days).

        Weight: 1 for a single symbol; 40 when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None):
                    strategy_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllUmConditionalOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_um_conditional_orders(
            symbol, strategy_id, start_time, end_time, limit, recv_window
        )

    def query_all_um_orders(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryAllUmOrdersResponse]:
        """
                Query All UM Orders(USER_DATA)

                Get all account UM orders; active, canceled, or filled.
        * These orders will not be found:
        * order status is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 3 days < current time

        * If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
        * The query time period must be less then 7 days( default as the recent 7 days).

        Weight: 5

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryAllUmOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_all_um_orders(
            symbol, order_id, start_time, end_time, limit, recv_window
        )

    def query_cm_conditional_order_history(
        self,
        symbol: Union[str, None],
        strategy_id: Optional[int] = None,
        new_client_strategy_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCmConditionalOrderHistoryResponse]:
        """
                Query CM Conditional Order History(USER_DATA)

                Query CM Conditional Order History


        * Either `strategyId` or `newClientStrategyId` must be sent.
        * `NEW` orders will not be found.
        * These orders will not be found:
        * order status is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 7 days < current time

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    strategy_id (Optional[int] = None):
                    new_client_strategy_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCmConditionalOrderHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_cm_conditional_order_history(
            symbol, strategy_id, new_client_strategy_id, recv_window
        )

    def query_cm_modify_order_history(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCmModifyOrderHistoryResponse]:
        """
                Query CM Modify Order History(TRADE)

                Get order modification history

        * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCmModifyOrderHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_cm_modify_order_history(
            symbol,
            order_id,
            orig_client_order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        )

    def query_cm_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCmOrderResponse]:
        """
                Query CM Order(USER_DATA)

                Check an CM order's status.

        * Either `orderId` or `origClientOrderId` must be sent.
        * These orders will not be found:
        * order status is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 3 days < current time

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_cm_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def query_current_cm_open_conditional_order(
        self,
        symbol: Union[str, None],
        strategy_id: Optional[int] = None,
        new_client_strategy_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentCmOpenConditionalOrderResponse]:
        """
                Query Current CM Open Conditional Order(USER_DATA)

                Query Current CM Open Conditional Order

        * Either `strategyId` or `newClientStrategyId` must be sent.
        * If the queried order has been triggered, cancelled or expired, the error message "Order does not exist" will be returned.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    strategy_id (Optional[int] = None):
                    new_client_strategy_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCurrentCmOpenConditionalOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_cm_open_conditional_order(
            symbol, strategy_id, new_client_strategy_id, recv_window
        )

    def query_current_cm_open_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentCmOpenOrderResponse]:
        """
                Query Current CM Open Order (USER_DATA)

                Query current CM open order

        * Either `orderId` or `origClientOrderId` must be sent.
        * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCurrentCmOpenOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_cm_open_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def query_current_margin_open_order(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentMarginOpenOrderResponse]:
        """
                Query Current Margin Open Order (USER_DATA)

                Query Current Margin Open Order

        Weight: 5

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCurrentMarginOpenOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_margin_open_order(symbol, recv_window)

    def query_current_um_open_conditional_order(
        self,
        symbol: Union[str, None],
        strategy_id: Optional[int] = None,
        new_client_strategy_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentUmOpenConditionalOrderResponse]:
        """
                Query Current UM Open Conditional Order(USER_DATA)

                Query Current UM Open Conditional Order

        * Either `strategyId` or `newClientStrategyId` must be sent.
        * If the queried order has been `CANCELED`, `TRIGGERED``EXPIRED`, the error message "Order does not exist" will be returned.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    strategy_id (Optional[int] = None):
                    new_client_strategy_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCurrentUmOpenConditionalOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_um_open_conditional_order(
            symbol, strategy_id, new_client_strategy_id, recv_window
        )

    def query_current_um_open_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryCurrentUmOpenOrderResponse]:
        """
                Query Current UM Open Order(USER_DATA)

                Query current UM open order


        * Either `orderId` or `origClientOrderId` must be sent.
        * If the queried order has been filled or cancelled, the error message "Order does not exist" will be returned.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryCurrentUmOpenOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_current_um_open_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def query_margin_account_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountOrderResponse]:
        """
                Query Margin Account Order (USER_DATA)

                Query Margin Account Order

        Weight: 10

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginAccountOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_account_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def query_margin_accounts_all_oco(
        self,
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsAllOcoResponse]:
        """
                Query Margin Account's all OCO (USER_DATA)

                Query all OCO for a specific margin account based on provided optional parameters

        Weight: 100

                Args:
                    from_id (Optional[int] = None): Trade id to fetch from. Default gets most recent trades.
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginAccountsAllOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_all_oco(
            from_id, start_time, end_time, limit, recv_window
        )

    def query_margin_accounts_oco(
        self,
        order_list_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsOcoResponse]:
        """
                Query Margin Account's OCO (USER_DATA)

                Retrieves a specific OCO based on provided optional parameters

        Weight: 5

                Args:
                    order_list_id (Optional[int] = None): Either `orderListId` or `listClientOrderId` must be provided
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginAccountsOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_oco(
            order_list_id, orig_client_order_id, recv_window
        )

    def query_margin_accounts_open_oco(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryMarginAccountsOpenOcoResponse]:
        """
                Query Margin Account's Open OCO (USER_DATA)

                Query Margin Account's Open OCO

        Weight: 5

                Args:
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryMarginAccountsOpenOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_margin_accounts_open_oco(recv_window)

    def query_um_conditional_order_history(
        self,
        symbol: Union[str, None],
        strategy_id: Optional[int] = None,
        new_client_strategy_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUmConditionalOrderHistoryResponse]:
        """
                Query UM Conditional Order History(USER_DATA)

                Query UM Conditional Order History

        * Either `strategyId` or `newClientStrategyId` must be sent.
        * `NEW` orders will not be found.
        * These orders will not be found:
        * order status is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 7 days < current time

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    strategy_id (Optional[int] = None):
                    new_client_strategy_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUmConditionalOrderHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_um_conditional_order_history(
            symbol, strategy_id, new_client_strategy_id, recv_window
        )

    def query_um_modify_order_history(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUmModifyOrderHistoryResponse]:
        """
                Query UM Modify Order History(TRADE)

                Get order modification history

        * Either `orderId` or `origClientOrderId` must be sent, and the `orderId` will prevail if both are sent.

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUmModifyOrderHistoryResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_um_modify_order_history(
            symbol,
            order_id,
            orig_client_order_id,
            start_time,
            end_time,
            limit,
            recv_window,
        )

    def query_um_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUmOrderResponse]:
        """
                Query UM Order (USER_DATA)

                Check an UM order's status.

        * These orders will not be found:
        * Either `orderId` or `origClientOrderId` must be sent.
        * order status is `CANCELED` or `EXPIRED`, **AND**
        * order has NO filled trade, **AND**
        * created time + 3 days < current time

        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUmOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_um_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def query_users_cm_force_orders(
        self,
        symbol: Optional[str] = None,
        auto_close_type: Optional[QueryUsersCmForceOrdersAutoCloseTypeEnum] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUsersCmForceOrdersResponse]:
        """
                Query User's CM Force Orders(USER_DATA)

                Query User's CM Force Orders

        * If "autoCloseType" is not sent, orders with both of the types will be returned
        * If "startTime" is not sent, data within 7 days before "endTime" can be queried

        Weight: 20 with symbol, 50 without symbol

                Args:
                    symbol (Optional[str] = None):
                    auto_close_type (Optional[QueryUsersCmForceOrdersAutoCloseTypeEnum] = None): `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUsersCmForceOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_users_cm_force_orders(
            symbol, auto_close_type, start_time, end_time, limit, recv_window
        )

    def query_users_margin_force_orders(
        self,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        current: Optional[int] = None,
        size: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUsersMarginForceOrdersResponse]:
        """
                Query User's Margin Force Orders(USER_DATA)

                Query user's margin force orders

        Weight: 1

                Args:
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    current (Optional[int] = None): Currently querying page. Start from 1. Default:1
                    size (Optional[int] = None): Default:10 Max:100
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUsersMarginForceOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_users_margin_force_orders(
            start_time, end_time, current, size, recv_window
        )

    def query_users_um_force_orders(
        self,
        symbol: Optional[str] = None,
        auto_close_type: Optional[QueryUsersUmForceOrdersAutoCloseTypeEnum] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[QueryUsersUmForceOrdersResponse]:
        """
                Query User's UM Force Orders (USER_DATA)

                Query User's UM Force Orders

        * If `autoCloseType` is not sent, orders with both of the types will be returned
        * If `startTime` is not sent, data within 7 days before `endTime` can be queried

        Weight: 20 with symbol, 50 without symbol

                Args:
                    symbol (Optional[str] = None):
                    auto_close_type (Optional[QueryUsersUmForceOrdersAutoCloseTypeEnum] = None): `LIQUIDATION` for liquidation orders, `ADL` for ADL orders.
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[QueryUsersUmForceOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.query_users_um_force_orders(
            symbol, auto_close_type, start_time, end_time, limit, recv_window
        )

    def toggle_bnb_burn_on_um_futures_trade(
        self,
        fee_burn: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[ToggleBnbBurnOnUmFuturesTradeResponse]:
        """
                Toggle BNB Burn On UM Futures Trade (TRADE)

                Change user's BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off ) on ***EVERY symbol***


        * The BNB would not be collected from UM-PM account to the Portfolio Margin account.

        Weight: 1

                Args:
                    fee_burn (Union[str, None]): "true": Fee Discount On; "false": Fee Discount Off
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[ToggleBnbBurnOnUmFuturesTradeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.toggle_bnb_burn_on_um_futures_trade(fee_burn, recv_window)

    def um_account_trade_list(
        self,
        symbol: Union[str, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UmAccountTradeListResponse]:
        """
                UM Account Trade List(USER_DATA)

                Get trades for a specific account and UM symbol.


        * If `startTime` and `endTime` are both not sent, then the last '7 days' data will be returned.
        * The time between `startTime` and `endTime` cannot be longer than 7 days.
        * The parameter `fromId` cannot be sent with `startTime` or `endTime`.

        Weight: 5

                Args:
                    symbol (Union[str, None]):
                    start_time (Optional[int] = None): Timestamp in ms to get funding from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get funding until INCLUSIVE.
                    from_id (Optional[int] = None): Trade id to fetch from. Default gets most recent trades.
                    limit (Optional[int] = None): Default 100; max 1000
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UmAccountTradeListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.um_account_trade_list(
            symbol, start_time, end_time, from_id, limit, recv_window
        )

    def um_position_adl_quantile_estimation(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[UmPositionAdlQuantileEstimationResponse]:
        """
                UM Position ADL Quantile Estimation(USER_DATA)

                Query UM Position ADL Quantile Estimation

        * Values update every 30s.
        * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to high.
        * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode, "LONG", "SHORT", and "BOTH" will be returned to show the positions' adl quantiles of different position sides.
        * If the positions of the symbol are crossed margined in Hedge Mode:
        * "HEDGE" as a sign will be returned instead of "BOTH";
        * A same value caculated on unrealized pnls on long and short sides' positions will be shown for "LONG" and "SHORT" when there are positions in both of long and short sides.

        Weight: 5

                Args:
                    symbol (Optional[str] = None):
                    recv_window (Optional[int] = None):

                Returns:
                    ApiResponse[UmPositionAdlQuantileEstimationResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.um_position_adl_quantile_estimation(symbol, recv_window)

    def close_user_data_stream(
        self,
    ) -> ApiResponse[None]:
        """
                Close User Data Stream(USER_STREAM)

                Close out a user data stream.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamsApi.close_user_data_stream()

    def keepalive_user_data_stream(
        self,
    ) -> ApiResponse[None]:
        """
                Keepalive User Data Stream (USER_STREAM)

                Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 60 minutes.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamsApi.keepalive_user_data_stream()

    def start_user_data_stream(
        self,
    ) -> ApiResponse[StartUserDataStreamResponse]:
        """
                Start User Data Stream(USER_STREAM)

                Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent. If the account has an active `listenKey`, that `listenKey` will be returned and its validity will be extended for 60 minutes.

        Weight: 1

                Args:

                Returns:
                    ApiResponse[StartUserDataStreamResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamsApi.start_user_data_stream()
