"""
Binance Spot WebSocket API

OpenAPI Specifications for the Binance Spot WebSocket API

API documents:
  - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
  - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest

from unittest.mock import AsyncMock, MagicMock

from binance_common.models import WebsocketApiResponse
from binance_common.utils import parse_ws_rate_limit_headers
from binance_common.errors import RequiredError
from binance_sdk_spot.websocket_api.api import MarketApi


from binance_sdk_spot.websocket_api.models import KlinesIntervalEnum
from binance_sdk_spot.websocket_api.models import TickerTypeEnum
from binance_sdk_spot.websocket_api.models import TickerWindowSizeEnum
from binance_sdk_spot.websocket_api.models import Ticker24hrTypeEnum
from binance_sdk_spot.websocket_api.models import TickerTradingDayTypeEnum
from binance_sdk_spot.websocket_api.models import UiKlinesIntervalEnum
from binance_sdk_spot.websocket_api.models import AvgPriceResponse
from binance_sdk_spot.websocket_api.models import DepthResponse
from binance_sdk_spot.websocket_api.models import KlinesResponse
from binance_sdk_spot.websocket_api.models import TickerResponse
from binance_sdk_spot.websocket_api.models import Ticker24hrResponse
from binance_sdk_spot.websocket_api.models import TickerBookResponse
from binance_sdk_spot.websocket_api.models import TickerPriceResponse
from binance_sdk_spot.websocket_api.models import TickerTradingDayResponse
from binance_sdk_spot.websocket_api.models import TradesAggregateResponse
from binance_sdk_spot.websocket_api.models import TradesHistoricalResponse
from binance_sdk_spot.websocket_api.models import TradesRecentResponse
from binance_sdk_spot.websocket_api.models import UiKlinesResponse


class TestWebSocketMarketApi:
    @pytest.fixture(autouse=True)
    def setup_method(self):
        self.mock_websocket_api = MagicMock()
        self.websocket_api = MarketApi(websocket_api=self.mock_websocket_api)

    @pytest.mark.asyncio
    async def test_avg_price_success(self):
        """Test avg_price() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "ddbfb65f-9ebf-42ec-8240-8f0f91de0867",
            "status": 200,
            "result": {"mins": 5, "price": "9.35751834", "closeTime": 1694061154503},
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.avg_price(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/avgPrice".replace("/", "", 1)

        assert "params" in request_kwargs["payload"]
        params = request_kwargs["payload"]["params"]
        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/avgPrice".replace("/", "", 1), "params": params},
            response_model=AvgPriceResponse,
        )

    @pytest.mark.asyncio
    async def test_avg_price_success_with_optional_params(self):
        """Test avg_price() successfully with optional parameters."""

        params = {"symbol": "BNBUSDT", "id": "e9d6b4349871b40611412680b3445fac"}

        expected_response = {
            "id": "ddbfb65f-9ebf-42ec-8240-8f0f91de0867",
            "status": 200,
            "result": {"mins": 5, "price": "9.35751834", "closeTime": 1694061154503},
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.avg_price(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/avgPrice".replace("/", "", 1)
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/avgPrice".replace("/", "", 1), "params": params},
            response_model=AvgPriceResponse,
        )

    @pytest.mark.asyncio
    async def test_avg_price_missing_required_param_symbol(self):
        """Test that avg_price() raises RequiredError when 'symbol' is missing."""

        params = {"symbol": "BNBUSDT", "id": "e9d6b4349871b40611412680b3445fac"}
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.avg_price(**params)

    @pytest.mark.asyncio
    async def test_avg_price_server_error(self):
        """Test that avg_price() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.avg_price(**params)

    @pytest.mark.asyncio
    async def test_depth_success(self):
        """Test depth() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "51e2affb-0aba-4821-ba75-f2625006eb43",
            "status": 200,
            "result": {
                "lastUpdateId": 2731179239,
                "bids": [
                    ["0.01379900", "3.43200000"],
                    ["0.01379800", "3.24300000"],
                    ["0.01379700", "10.45500000"],
                    ["0.01379600", "3.82100000"],
                    ["0.01379500", "10.26200000"],
                ],
                "asks": [
                    ["0.01380000", "5.91700000"],
                    ["0.01380100", "6.01400000"],
                    ["0.01380200", "0.26800000"],
                    ["0.01380300", "0.33800000"],
                    ["0.01380400", "0.26800000"],
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.depth(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/depth".replace("/", "", 1)

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/depth".replace("/", "", 1), "params": params},
            response_model=DepthResponse,
        )

    @pytest.mark.asyncio
    async def test_depth_success_with_optional_params(self):
        """Test depth() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "limit": 100,
        }

        expected_response = {
            "id": "51e2affb-0aba-4821-ba75-f2625006eb43",
            "status": 200,
            "result": {
                "lastUpdateId": 2731179239,
                "bids": [
                    ["0.01379900", "3.43200000"],
                    ["0.01379800", "3.24300000"],
                    ["0.01379700", "10.45500000"],
                    ["0.01379600", "3.82100000"],
                    ["0.01379500", "10.26200000"],
                ],
                "asks": [
                    ["0.01380000", "5.91700000"],
                    ["0.01380100", "6.01400000"],
                    ["0.01380200", "0.26800000"],
                    ["0.01380300", "0.33800000"],
                    ["0.01380400", "0.26800000"],
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.depth(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/depth".replace("/", "", 1)
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["limit"] == 100

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/depth".replace("/", "", 1), "params": params},
            response_model=DepthResponse,
        )

    @pytest.mark.asyncio
    async def test_depth_missing_required_param_symbol(self):
        """Test that depth() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "limit": 100,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.depth(**params)

    @pytest.mark.asyncio
    async def test_depth_server_error(self):
        """Test that depth() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.depth(**params)

    @pytest.mark.asyncio
    async def test_klines_success(self):
        """Test klines() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "interval": KlinesIntervalEnum["INTERVAL_1s"].value,
        }

        expected_response = {
            "id": "1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b",
            "status": 200,
            "result": [
                [
                    1655971200000,
                    "0.01086000",
                    "0.01086600",
                    "0.01083600",
                    "0.01083800",
                    "2290.53800000",
                    1655974799999,
                    "24.85074442",
                    2283,
                    "1171.64000000",
                    "12.71225884",
                    "0",
                ]
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.klines(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/klines".replace("/", "", 1)

        assert params["symbol"] == "BNBUSDT"

        assert params["interval"] == KlinesIntervalEnum["INTERVAL_1s"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/klines".replace("/", "", 1), "params": params},
            response_model=KlinesResponse,
        )

    @pytest.mark.asyncio
    async def test_klines_success_with_optional_params(self):
        """Test klines() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "interval": KlinesIntervalEnum["INTERVAL_1s"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "time_zone": "time_zone_example",
            "limit": 100,
        }

        expected_response = {
            "id": "1dbbeb56-8eea-466a-8f6e-86bdcfa2fc0b",
            "status": 200,
            "result": [
                [
                    1655971200000,
                    "0.01086000",
                    "0.01086600",
                    "0.01083600",
                    "0.01083800",
                    "2290.53800000",
                    1655974799999,
                    "24.85074442",
                    2283,
                    "1171.64000000",
                    "12.71225884",
                    "0",
                ]
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.klines(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/klines".replace("/", "", 1)
        assert params["symbol"] == "BNBUSDT"
        assert params["interval"] == KlinesIntervalEnum["INTERVAL_1s"].value
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["time_zone"] == "time_zone_example"
        assert params["limit"] == 100

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/klines".replace("/", "", 1), "params": params},
            response_model=KlinesResponse,
        )

    @pytest.mark.asyncio
    async def test_klines_missing_required_param_symbol(self):
        """Test that klines() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "interval": KlinesIntervalEnum["INTERVAL_1s"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "time_zone": "time_zone_example",
            "limit": 100,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.klines(**params)

    @pytest.mark.asyncio
    async def test_klines_missing_required_param_interval(self):
        """Test that klines() raises RequiredError when 'interval' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "interval": KlinesIntervalEnum["INTERVAL_1s"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "time_zone": "time_zone_example",
            "limit": 100,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            await self.websocket_api.klines(**params)

    @pytest.mark.asyncio
    async def test_klines_server_error(self):
        """Test that klines() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "interval": KlinesIntervalEnum["INTERVAL_1s"].value,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.klines(**params)

    @pytest.mark.asyncio
    async def test_ticker_success(self):
        """Test ticker() successfully with required parameters only."""

        expected_response = {
            "id": "bdb7c503-542c-495c-b797-4d2ee2e91173",
            "status": 200,
            "result": {
                "symbol": "BNBBTC",
                "priceChange": "0.00061500",
                "priceChangePercent": "4.735",
                "weightedAvgPrice": "0.01368242",
                "openPrice": "0.01298900",
                "highPrice": "0.01418800",
                "lowPrice": "0.01296000",
                "lastPrice": "0.01360400",
                "volume": "587179.23900000",
                "quoteVolume": "8034.03382165",
                "openTime": 1659580020000,
                "closeTime": 1660184865291,
                "firstId": 192977765,
                "lastId": 195365758,
                "count": 2387994,
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.ticker()

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker".replace("/", "", 1)

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker".replace("/", "", 1), "params": {}},
            response_model=TickerResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_success_with_optional_params(self):
        """Test ticker() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "symbol": "BNBUSDT",
            "symbols": ["symbols_example"],
            "type": TickerTypeEnum["FULL"].value,
            "window_size": TickerWindowSizeEnum["WINDOW_SIZE_1m"].value,
        }

        expected_response = {
            "id": "bdb7c503-542c-495c-b797-4d2ee2e91173",
            "status": 200,
            "result": {
                "symbol": "BNBBTC",
                "priceChange": "0.00061500",
                "priceChangePercent": "4.735",
                "weightedAvgPrice": "0.01368242",
                "openPrice": "0.01298900",
                "highPrice": "0.01418800",
                "lowPrice": "0.01296000",
                "lastPrice": "0.01360400",
                "volume": "587179.23900000",
                "quoteVolume": "8034.03382165",
                "openTime": 1659580020000,
                "closeTime": 1660184865291,
                "firstId": 192977765,
                "lastId": 195365758,
                "count": 2387994,
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.ticker(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker".replace("/", "", 1)
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["symbol"] == "BNBUSDT"
        assert params["symbols"] == ["symbols_example"]
        assert params["type"] == TickerTypeEnum["FULL"].value
        assert params["window_size"] == TickerWindowSizeEnum["WINDOW_SIZE_1m"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker".replace("/", "", 1), "params": params},
            response_model=TickerResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_server_error(self):
        """Test that ticker() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.ticker()

    @pytest.mark.asyncio
    async def test_ticker24hr_success(self):
        """Test ticker24hr() successfully with required parameters only."""

        expected_response = {
            "id": "9fa2a91b-3fca-4ed7-a9ad-58e3b67483de",
            "status": 200,
            "result": {
                "symbol": "BNBBTC",
                "priceChange": "0.00013900",
                "priceChangePercent": "1.020",
                "weightedAvgPrice": "0.01382453",
                "prevClosePrice": "0.01362800",
                "lastPrice": "0.01376700",
                "lastQty": "1.78800000",
                "bidPrice": "0.01376700",
                "bidQty": "4.64600000",
                "askPrice": "0.01376800",
                "askQty": "14.31400000",
                "openPrice": "0.01362800",
                "highPrice": "0.01414900",
                "lowPrice": "0.01346600",
                "volume": "69412.40500000",
                "quoteVolume": "959.59411487",
                "openTime": 1660014164909,
                "closeTime": 1660100564909,
                "firstId": 194696115,
                "lastId": 194968287,
                "count": 272173,
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.ticker24hr()

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.24hr".replace("/", "", 1)

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.24hr".replace("/", "", 1), "params": {}},
            response_model=Ticker24hrResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker24hr_success_with_optional_params(self):
        """Test ticker24hr() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "symbol": "BNBUSDT",
            "symbols": ["symbols_example"],
            "type": Ticker24hrTypeEnum["FULL"].value,
        }

        expected_response = {
            "id": "9fa2a91b-3fca-4ed7-a9ad-58e3b67483de",
            "status": 200,
            "result": {
                "symbol": "BNBBTC",
                "priceChange": "0.00013900",
                "priceChangePercent": "1.020",
                "weightedAvgPrice": "0.01382453",
                "prevClosePrice": "0.01362800",
                "lastPrice": "0.01376700",
                "lastQty": "1.78800000",
                "bidPrice": "0.01376700",
                "bidQty": "4.64600000",
                "askPrice": "0.01376800",
                "askQty": "14.31400000",
                "openPrice": "0.01362800",
                "highPrice": "0.01414900",
                "lowPrice": "0.01346600",
                "volume": "69412.40500000",
                "quoteVolume": "959.59411487",
                "openTime": 1660014164909,
                "closeTime": 1660100564909,
                "firstId": 194696115,
                "lastId": 194968287,
                "count": 272173,
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.ticker24hr(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.24hr".replace("/", "", 1)
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["symbol"] == "BNBUSDT"
        assert params["symbols"] == ["symbols_example"]
        assert params["type"] == Ticker24hrTypeEnum["FULL"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.24hr".replace("/", "", 1), "params": params},
            response_model=Ticker24hrResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker24hr_server_error(self):
        """Test that ticker24hr() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.ticker24hr()

    @pytest.mark.asyncio
    async def test_ticker_book_success(self):
        """Test ticker_book() successfully with required parameters only."""

        expected_response = {
            "id": "9d32157c-a556-4d27-9866-66760a174b57",
            "status": 200,
            "result": {
                "symbol": "BNBBTC",
                "bidPrice": "0.01358000",
                "bidQty": "12.53400000",
                "askPrice": "0.01358100",
                "askQty": "17.83700000",
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.ticker_book()

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.book".replace("/", "", 1)

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.book".replace("/", "", 1), "params": {}},
            response_model=TickerBookResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_book_success_with_optional_params(self):
        """Test ticker_book() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "symbol": "BNBUSDT",
            "symbols": ["symbols_example"],
        }

        expected_response = {
            "id": "9d32157c-a556-4d27-9866-66760a174b57",
            "status": 200,
            "result": {
                "symbol": "BNBBTC",
                "bidPrice": "0.01358000",
                "bidQty": "12.53400000",
                "askPrice": "0.01358100",
                "askQty": "17.83700000",
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.ticker_book(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.book".replace("/", "", 1)
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["symbol"] == "BNBUSDT"
        assert params["symbols"] == ["symbols_example"]

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.book".replace("/", "", 1), "params": params},
            response_model=TickerBookResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_book_server_error(self):
        """Test that ticker_book() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.ticker_book()

    @pytest.mark.asyncio
    async def test_ticker_price_success(self):
        """Test ticker_price() successfully with required parameters only."""

        expected_response = {
            "id": "043a7cf2-bde3-4888-9604-c8ac41fcba4d",
            "status": 200,
            "result": {"symbol": "BNBBTC", "price": "0.01361900"},
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.ticker_price()

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.price".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.price".replace("/", "", 1), "params": {}},
            response_model=TickerPriceResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_price_success_with_optional_params(self):
        """Test ticker_price() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "symbol": "BNBUSDT",
            "symbols": ["symbols_example"],
        }

        expected_response = {
            "id": "043a7cf2-bde3-4888-9604-c8ac41fcba4d",
            "status": 200,
            "result": {"symbol": "BNBBTC", "price": "0.01361900"},
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.ticker_price(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.price".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["symbol"] == "BNBUSDT"
        assert params["symbols"] == ["symbols_example"]

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.price".replace("/", "", 1), "params": params},
            response_model=TickerPriceResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_price_server_error(self):
        """Test that ticker_price() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.ticker_price()

    @pytest.mark.asyncio
    async def test_ticker_trading_day_success(self):
        """Test ticker_trading_day() successfully with required parameters only."""

        expected_response = {
            "id": "f4b3b507-c8f2-442a-81a6-b2f12daa030f",
            "status": 200,
            "result": [
                {
                    "symbol": "BNBUSDT",
                    "priceChange": "2.60000000",
                    "priceChangePercent": "1.238",
                    "weightedAvgPrice": "211.92276958",
                    "openPrice": "210.00000000",
                    "highPrice": "213.70000000",
                    "lowPrice": "209.70000000",
                    "lastPrice": "212.60000000",
                    "volume": "280709.58900000",
                    "quoteVolume": "59488753.54750000",
                    "openTime": 1695686400000,
                    "closeTime": 1695772799999,
                    "firstId": 672397461,
                    "lastId": 672496158,
                    "count": 98698,
                },
                {
                    "symbol": "BTCUSDT",
                    "priceChange": "-83.13000000",
                    "priceChangePercent": "-0.317",
                    "weightedAvgPrice": "26234.58803036",
                    "openPrice": "26304.80000000",
                    "highPrice": "26397.46000000",
                    "lowPrice": "26088.34000000",
                    "lastPrice": "26221.67000000",
                    "volume": "18495.35066000",
                    "quoteVolume": "485217905.04210480",
                    "openTime": 1695686400000,
                    "closeTime": 1695772799999,
                    "firstId": 3220151555,
                    "lastId": 3220849281,
                    "count": 697727,
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 8,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.ticker_trading_day()

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.tradingDay".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/ticker.tradingDay".replace("/", "", 1), "params": {}},
            response_model=TickerTradingDayResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_trading_day_success_with_optional_params(self):
        """Test ticker_trading_day() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "symbol": "BNBUSDT",
            "symbols": ["symbols_example"],
            "time_zone": "time_zone_example",
            "type": TickerTradingDayTypeEnum["FULL"].value,
        }

        expected_response = {
            "id": "f4b3b507-c8f2-442a-81a6-b2f12daa030f",
            "status": 200,
            "result": [
                {
                    "symbol": "BNBUSDT",
                    "priceChange": "2.60000000",
                    "priceChangePercent": "1.238",
                    "weightedAvgPrice": "211.92276958",
                    "openPrice": "210.00000000",
                    "highPrice": "213.70000000",
                    "lowPrice": "209.70000000",
                    "lastPrice": "212.60000000",
                    "volume": "280709.58900000",
                    "quoteVolume": "59488753.54750000",
                    "openTime": 1695686400000,
                    "closeTime": 1695772799999,
                    "firstId": 672397461,
                    "lastId": 672496158,
                    "count": 98698,
                },
                {
                    "symbol": "BTCUSDT",
                    "priceChange": "-83.13000000",
                    "priceChangePercent": "-0.317",
                    "weightedAvgPrice": "26234.58803036",
                    "openPrice": "26304.80000000",
                    "highPrice": "26397.46000000",
                    "lowPrice": "26088.34000000",
                    "lastPrice": "26221.67000000",
                    "volume": "18495.35066000",
                    "quoteVolume": "485217905.04210480",
                    "openTime": 1695686400000,
                    "closeTime": 1695772799999,
                    "firstId": 3220151555,
                    "lastId": 3220849281,
                    "count": 697727,
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 8,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.ticker_trading_day(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/ticker.tradingDay".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["symbol"] == "BNBUSDT"
        assert params["symbols"] == ["symbols_example"]
        assert params["time_zone"] == "time_zone_example"
        assert params["type"] == TickerTradingDayTypeEnum["FULL"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={
                "method": "/ticker.tradingDay".replace("/", "", 1),
                "params": params,
            },
            response_model=TickerTradingDayResponse,
        )

    @pytest.mark.asyncio
    async def test_ticker_trading_day_server_error(self):
        """Test that ticker_trading_day() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.ticker_trading_day()

    @pytest.mark.asyncio
    async def test_trades_aggregate_success(self):
        """Test trades_aggregate() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "189da436-d4bd-48ca-9f95-9f613d621717",
            "status": 200,
            "result": [
                {
                    "a": 50000000,
                    "p": "0.00274100",
                    "q": "57.19000000",
                    "f": 59120167,
                    "l": 59120170,
                    "T": 1565877971222,
                    "m": True,
                    "M": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.trades_aggregate(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/trades.aggregate".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={
                "method": "/trades.aggregate".replace("/", "", 1),
                "params": params,
            },
            response_model=TradesAggregateResponse,
        )

    @pytest.mark.asyncio
    async def test_trades_aggregate_success_with_optional_params(self):
        """Test trades_aggregate() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 100,
        }

        expected_response = {
            "id": "189da436-d4bd-48ca-9f95-9f613d621717",
            "status": 200,
            "result": [
                {
                    "a": 50000000,
                    "p": "0.00274100",
                    "q": "57.19000000",
                    "f": 59120167,
                    "l": 59120170,
                    "T": 1565877971222,
                    "m": True,
                    "M": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.trades_aggregate(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/trades.aggregate".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["from_id"] == 1
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["limit"] == 100

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={
                "method": "/trades.aggregate".replace("/", "", 1),
                "params": params,
            },
            response_model=TradesAggregateResponse,
        )

    @pytest.mark.asyncio
    async def test_trades_aggregate_missing_required_param_symbol(self):
        """Test that trades_aggregate() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 100,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.trades_aggregate(**params)

    @pytest.mark.asyncio
    async def test_trades_aggregate_server_error(self):
        """Test that trades_aggregate() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.trades_aggregate(**params)

    @pytest.mark.asyncio
    async def test_trades_historical_success(self):
        """Test trades_historical() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "cffc9c7d-4efc-4ce0-b587-6b87448f052a",
            "status": 200,
            "result": [
                {
                    "id": 0,
                    "price": "0.00005000",
                    "qty": "40.00000000",
                    "quoteQty": "0.00200000",
                    "time": 1500004800376,
                    "isBuyerMaker": True,
                    "isBestMatch": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 10,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.trades_historical(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/trades.historical".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={
                "method": "/trades.historical".replace("/", "", 1),
                "params": params,
            },
            response_model=TradesHistoricalResponse,
        )

    @pytest.mark.asyncio
    async def test_trades_historical_success_with_optional_params(self):
        """Test trades_historical() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_id": 1,
            "limit": 100,
        }

        expected_response = {
            "id": "cffc9c7d-4efc-4ce0-b587-6b87448f052a",
            "status": 200,
            "result": [
                {
                    "id": 0,
                    "price": "0.00005000",
                    "qty": "40.00000000",
                    "quoteQty": "0.00200000",
                    "time": 1500004800376,
                    "isBuyerMaker": True,
                    "isBestMatch": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 10,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.trades_historical(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/trades.historical".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["from_id"] == 1
        assert params["limit"] == 100

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={
                "method": "/trades.historical".replace("/", "", 1),
                "params": params,
            },
            response_model=TradesHistoricalResponse,
        )

    @pytest.mark.asyncio
    async def test_trades_historical_missing_required_param_symbol(self):
        """Test that trades_historical() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_id": 1,
            "limit": 100,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.trades_historical(**params)

    @pytest.mark.asyncio
    async def test_trades_historical_server_error(self):
        """Test that trades_historical() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.trades_historical(**params)

    @pytest.mark.asyncio
    async def test_trades_recent_success(self):
        """Test trades_recent() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "409a20bd-253d-41db-a6dd-687862a5882f",
            "status": 200,
            "result": [
                {
                    "id": 194686783,
                    "price": "0.01361000",
                    "qty": "0.01400000",
                    "quoteQty": "0.00019054",
                    "time": 1660009530807,
                    "isBuyerMaker": True,
                    "isBestMatch": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.trades_recent(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/trades.recent".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/trades.recent".replace("/", "", 1), "params": params},
            response_model=TradesRecentResponse,
        )

    @pytest.mark.asyncio
    async def test_trades_recent_success_with_optional_params(self):
        """Test trades_recent() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "limit": 100,
        }

        expected_response = {
            "id": "409a20bd-253d-41db-a6dd-687862a5882f",
            "status": 200,
            "result": [
                {
                    "id": 194686783,
                    "price": "0.01361000",
                    "qty": "0.01400000",
                    "quoteQty": "0.00019054",
                    "time": 1660009530807,
                    "isBuyerMaker": True,
                    "isBestMatch": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.trades_recent(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/trades.recent".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["limit"] == 100

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/trades.recent".replace("/", "", 1), "params": params},
            response_model=TradesRecentResponse,
        )

    @pytest.mark.asyncio
    async def test_trades_recent_missing_required_param_symbol(self):
        """Test that trades_recent() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "limit": 100,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.trades_recent(**params)

    @pytest.mark.asyncio
    async def test_trades_recent_server_error(self):
        """Test that trades_recent() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.trades_recent(**params)

    @pytest.mark.asyncio
    async def test_ui_klines_success(self):
        """Test ui_klines() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "interval": UiKlinesIntervalEnum["INTERVAL_1s"].value,
        }

        expected_response = {
            "id": "b137468a-fb20-4c06-bd6b-625148eec958",
            "status": 200,
            "result": [
                [
                    1655971200000,
                    "0.01086000",
                    "0.01086600",
                    "0.01083600",
                    "0.01083800",
                    "2290.53800000",
                    1655974799999,
                    "24.85074442",
                    2283,
                    "1171.64000000",
                    "12.71225884",
                    "0",
                ]
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.ui_klines(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/uiKlines".replace("/", "", 1)

        assert params["symbol"] == "BNBUSDT"

        assert params["interval"] == UiKlinesIntervalEnum["INTERVAL_1s"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/uiKlines".replace("/", "", 1), "params": params},
            response_model=UiKlinesResponse,
        )

    @pytest.mark.asyncio
    async def test_ui_klines_success_with_optional_params(self):
        """Test ui_klines() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "interval": UiKlinesIntervalEnum["INTERVAL_1s"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "time_zone": "time_zone_example",
            "limit": 100,
        }

        expected_response = {
            "id": "b137468a-fb20-4c06-bd6b-625148eec958",
            "status": 200,
            "result": [
                [
                    1655971200000,
                    "0.01086000",
                    "0.01086600",
                    "0.01083600",
                    "0.01083800",
                    "2290.53800000",
                    1655974799999,
                    "24.85074442",
                    2283,
                    "1171.64000000",
                    "12.71225884",
                    "0",
                ]
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 2,
                }
            ],
        }

        self.mock_websocket_api.send_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.ui_klines(**params)

        actual_call_args = self.mock_websocket_api.send_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/uiKlines".replace("/", "", 1)
        assert params["symbol"] == "BNBUSDT"
        assert params["interval"] == UiKlinesIntervalEnum["INTERVAL_1s"].value
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["time_zone"] == "time_zone_example"
        assert params["limit"] == 100

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_message.assert_called_once_with(
            payload={"method": "/uiKlines".replace("/", "", 1), "params": params},
            response_model=UiKlinesResponse,
        )

    @pytest.mark.asyncio
    async def test_ui_klines_missing_required_param_symbol(self):
        """Test that ui_klines() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "interval": UiKlinesIntervalEnum["INTERVAL_1s"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "time_zone": "time_zone_example",
            "limit": 100,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.ui_klines(**params)

    @pytest.mark.asyncio
    async def test_ui_klines_missing_required_param_interval(self):
        """Test that ui_klines() raises RequiredError when 'interval' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "interval": UiKlinesIntervalEnum["INTERVAL_1s"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "time_zone": "time_zone_example",
            "limit": 100,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            await self.websocket_api.ui_klines(**params)

    @pytest.mark.asyncio
    async def test_ui_klines_server_error(self):
        """Test that ui_klines() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "interval": UiKlinesIntervalEnum["INTERVAL_1s"].value,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.ui_klines(**params)
