"""
Binance Spot WebSocket API

OpenAPI Specifications for the Binance Spot WebSocket API

API documents:
  - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
  - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest

from unittest.mock import AsyncMock, MagicMock

from binance_common.models import WebsocketApiResponse
from binance_common.utils import parse_ws_rate_limit_headers
from binance_common.errors import RequiredError
from binance_spot.websocket_api.api import TradeApi


from binance_spot.websocket_api.models import OrderCancelCancelRestrictionsEnum
from binance_spot.websocket_api.models import OrderCancelReplaceCancelReplaceModeEnum
from binance_spot.websocket_api.models import OrderCancelReplaceSideEnum
from binance_spot.websocket_api.models import OrderCancelReplaceTypeEnum
from binance_spot.websocket_api.models import OrderCancelReplaceTimeInForceEnum
from binance_spot.websocket_api.models import OrderCancelReplaceNewOrderRespTypeEnum
from binance_spot.websocket_api.models import (
    OrderCancelReplaceSelfTradePreventionModeEnum,
)
from binance_spot.websocket_api.models import OrderCancelReplaceCancelRestrictionsEnum
from binance_spot.websocket_api.models import (
    OrderCancelReplaceOrderRateLimitExceededModeEnum,
)
from binance_spot.websocket_api.models import OrderListPlaceSideEnum
from binance_spot.websocket_api.models import OrderListPlaceStopLimitTimeInForceEnum
from binance_spot.websocket_api.models import OrderListPlaceNewOrderRespTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceSelfTradePreventionModeEnum
from binance_spot.websocket_api.models import OrderListPlaceOcoSideEnum
from binance_spot.websocket_api.models import OrderListPlaceOcoAboveTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceOcoBelowTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceOcoBelowTimeInForceEnum
from binance_spot.websocket_api.models import OrderListPlaceOcoNewOrderRespTypeEnum
from binance_spot.websocket_api.models import (
    OrderListPlaceOcoSelfTradePreventionModeEnum,
)
from binance_spot.websocket_api.models import OrderListPlaceOtoWorkingTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceOtoWorkingSideEnum
from binance_spot.websocket_api.models import OrderListPlaceOtoPendingTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceOtoPendingSideEnum
from binance_spot.websocket_api.models import OrderListPlaceOtoNewOrderRespTypeEnum
from binance_spot.websocket_api.models import (
    OrderListPlaceOtoSelfTradePreventionModeEnum,
)
from binance_spot.websocket_api.models import OrderListPlaceOtoWorkingTimeInForceEnum
from binance_spot.websocket_api.models import OrderListPlaceOtoPendingTimeInForceEnum
from binance_spot.websocket_api.models import OrderListPlaceOtocoWorkingTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceOtocoWorkingSideEnum
from binance_spot.websocket_api.models import OrderListPlaceOtocoPendingSideEnum
from binance_spot.websocket_api.models import OrderListPlaceOtocoPendingAboveTypeEnum
from binance_spot.websocket_api.models import OrderListPlaceOtocoNewOrderRespTypeEnum
from binance_spot.websocket_api.models import (
    OrderListPlaceOtocoSelfTradePreventionModeEnum,
)
from binance_spot.websocket_api.models import OrderListPlaceOtocoWorkingTimeInForceEnum
from binance_spot.websocket_api.models import (
    OrderListPlaceOtocoPendingAboveTimeInForceEnum,
)
from binance_spot.websocket_api.models import OrderListPlaceOtocoPendingBelowTypeEnum
from binance_spot.websocket_api.models import (
    OrderListPlaceOtocoPendingBelowTimeInForceEnum,
)
from binance_spot.websocket_api.models import OrderPlaceSideEnum
from binance_spot.websocket_api.models import OrderPlaceTypeEnum
from binance_spot.websocket_api.models import OrderPlaceTimeInForceEnum
from binance_spot.websocket_api.models import OrderPlaceNewOrderRespTypeEnum
from binance_spot.websocket_api.models import OrderPlaceSelfTradePreventionModeEnum
from binance_spot.websocket_api.models import SorOrderPlaceSideEnum
from binance_spot.websocket_api.models import SorOrderPlaceTypeEnum
from binance_spot.websocket_api.models import SorOrderPlaceTimeInForceEnum
from binance_spot.websocket_api.models import SorOrderPlaceNewOrderRespTypeEnum
from binance_spot.websocket_api.models import SorOrderPlaceSelfTradePreventionModeEnum
from binance_spot.websocket_api.models import OpenOrdersCancelAllResponse
from binance_spot.websocket_api.models import OrderAmendKeepPriorityResponse
from binance_spot.websocket_api.models import OrderCancelResponse
from binance_spot.websocket_api.models import OrderCancelReplaceResponse
from binance_spot.websocket_api.models import OrderListCancelResponse
from binance_spot.websocket_api.models import OrderListPlaceResponse
from binance_spot.websocket_api.models import OrderListPlaceOcoResponse
from binance_spot.websocket_api.models import OrderListPlaceOtoResponse
from binance_spot.websocket_api.models import OrderListPlaceOtocoResponse
from binance_spot.websocket_api.models import OrderPlaceResponse
from binance_spot.websocket_api.models import OrderTestResponse
from binance_spot.websocket_api.models import SorOrderPlaceResponse
from binance_spot.websocket_api.models import SorOrderTestResponse


class TestWebSocketTradeApi:
    @pytest.fixture(autouse=True)
    def setup_method(self):
        self.mock_websocket_api = MagicMock()
        self.websocket_api = TradeApi(websocket_api=self.mock_websocket_api)

    @pytest.mark.asyncio
    async def test_open_orders_cancel_all_success(self):
        """Test open_orders_cancel_all() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "778f938f-9041-4b88-9914-efbf64eeacc8",
            "status": 200,
            "result": [
                {
                    "orderListId": 19431,
                    "contingencyType": "OCO",
                    "listStatusType": "ALL_DONE",
                    "listOrderStatus": "ALL_DONE",
                    "listClientOrderId": "iuVNVJYYrByz6C4yGOPPK0",
                    "transactionTime": 1660803702431,
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569099454,
                            "clientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569099453,
                            "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                        },
                    ],
                    "orderReports": [
                        {
                            "symbol": "BTCUSDT",
                            "origClientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                            "orderId": 12569099454,
                            "orderListId": 19431,
                            "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                            "transactTime": 1684804350068,
                            "price": "23400.00000000",
                            "origQty": "0.00850000",
                            "executedQty": "0.00000000",
                            "origQuoteOrderQty": "0.000000",
                            "cummulativeQuoteQty": "0.00000000",
                            "status": "CANCELED",
                            "timeInForce": "GTC",
                            "type": "LIMIT_MAKER",
                            "side": "BUY",
                            "selfTradePreventionMode": "NONE",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "origClientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                            "orderId": 12569099453,
                            "orderListId": 19431,
                            "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                            "transactTime": 1684804350068,
                            "price": "23450.50000000",
                            "origQty": "0.00850000",
                            "executedQty": "0.00000000",
                            "origQuoteOrderQty": "0.000000",
                            "cummulativeQuoteQty": "0.00000000",
                            "status": "CANCELED",
                            "timeInForce": "GTC",
                            "type": "STOP_LOSS_LIMIT",
                            "side": "BUY",
                            "stopPrice": "23430.00000000",
                            "selfTradePreventionMode": "NONE",
                        },
                    ],
                },
                {
                    "symbol": "BTCUSDT",
                    "origClientOrderId": "4d96324ff9d44481926157",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "91fe37ce9e69c90d6358c0",
                    "transactTime": 1684804350068,
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00001000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.23416100",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "stopPrice": "0.00000000",
                    "trailingDelta": 0,
                    "trailingTime": -1,
                    "icebergQty": "0.00000000",
                    "strategyId": 37463720,
                    "strategyType": 1000000,
                    "selfTradePreventionMode": "NONE",
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.open_orders_cancel_all(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/openOrders.cancelAll".replace(
            "/", ""
        )

        assert "params" in request_kwargs["payload"]
        params = request_kwargs["payload"]["params"]
        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/openOrders.cancelAll".replace("/", ""),
                "params": params,
            },
            response_model=OpenOrdersCancelAllResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_open_orders_cancel_all_success_with_optional_params(self):
        """Test open_orders_cancel_all() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "recv_window": 5000,
        }

        expected_response = {
            "id": "778f938f-9041-4b88-9914-efbf64eeacc8",
            "status": 200,
            "result": [
                {
                    "orderListId": 19431,
                    "contingencyType": "OCO",
                    "listStatusType": "ALL_DONE",
                    "listOrderStatus": "ALL_DONE",
                    "listClientOrderId": "iuVNVJYYrByz6C4yGOPPK0",
                    "transactionTime": 1660803702431,
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569099454,
                            "clientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569099453,
                            "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                        },
                    ],
                    "orderReports": [
                        {
                            "symbol": "BTCUSDT",
                            "origClientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                            "orderId": 12569099454,
                            "orderListId": 19431,
                            "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                            "transactTime": 1684804350068,
                            "price": "23400.00000000",
                            "origQty": "0.00850000",
                            "executedQty": "0.00000000",
                            "origQuoteOrderQty": "0.000000",
                            "cummulativeQuoteQty": "0.00000000",
                            "status": "CANCELED",
                            "timeInForce": "GTC",
                            "type": "LIMIT_MAKER",
                            "side": "BUY",
                            "selfTradePreventionMode": "NONE",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "origClientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                            "orderId": 12569099453,
                            "orderListId": 19431,
                            "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                            "transactTime": 1684804350068,
                            "price": "23450.50000000",
                            "origQty": "0.00850000",
                            "executedQty": "0.00000000",
                            "origQuoteOrderQty": "0.000000",
                            "cummulativeQuoteQty": "0.00000000",
                            "status": "CANCELED",
                            "timeInForce": "GTC",
                            "type": "STOP_LOSS_LIMIT",
                            "side": "BUY",
                            "stopPrice": "23430.00000000",
                            "selfTradePreventionMode": "NONE",
                        },
                    ],
                },
                {
                    "symbol": "BTCUSDT",
                    "origClientOrderId": "4d96324ff9d44481926157",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "91fe37ce9e69c90d6358c0",
                    "transactTime": 1684804350068,
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00001000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.23416100",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "stopPrice": "0.00000000",
                    "trailingDelta": 0,
                    "trailingTime": -1,
                    "icebergQty": "0.00000000",
                    "strategyId": 37463720,
                    "strategyType": 1000000,
                    "selfTradePreventionMode": "NONE",
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.open_orders_cancel_all(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/openOrders.cancelAll".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/openOrders.cancelAll".replace("/", ""),
                "params": params,
            },
            response_model=OpenOrdersCancelAllResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_open_orders_cancel_all_missing_required_param_symbol(self):
        """Test that open_orders_cancel_all() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.open_orders_cancel_all(**params)

    @pytest.mark.asyncio
    async def test_open_orders_cancel_all_server_error(self):
        """Test that open_orders_cancel_all() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.open_orders_cancel_all(**params)

    @pytest.mark.asyncio
    async def test_order_amend_keep_priority_success(self):
        """Test order_amend_keep_priority() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
        }

        expected_response = {
            "id": "56374b46-3061-486b-a311-89ee972eb648",
            "status": 200,
            "result": {
                "transactTime": 1741924229819,
                "executionId": 60,
                "amendedOrder": {
                    "symbol": "BTUCSDT",
                    "orderId": 23,
                    "orderListId": 4,
                    "origClientOrderId": "my_pending_order",
                    "clientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                    "price": "1.00000000",
                    "qty": "5.00000000",
                    "executedQty": "0.00000000",
                    "preventedQty": "0.00000000",
                    "quoteOrderQty": "0.00000000",
                    "cumulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "BUY",
                    "workingTime": 1741924204920,
                    "selfTradePreventionMode": "NONE",
                },
                "listStatus": {
                    "orderListId": 4,
                    "contingencyType": "OTO",
                    "listOrderStatus": "EXECUTING",
                    "listClientOrderId": "8nOGLLawudj1QoOiwbroRH",
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 23,
                            "clientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 22,
                            "clientOrderId": "g04EWsjaackzedjC9wRkWD",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 23,
                            "clientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 22,
                            "clientOrderId": "g04EWsjaackzedjC9wRkWD",
                        },
                    ],
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_amend_keep_priority(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"][
            "method"
        ] == "/order.amend.keepPriority".replace("/", "")

        assert params["symbol"] == "BNBUSDT"

        assert params["new_qty"] == 1.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/order.amend.keepPriority".replace("/", ""),
                "params": params,
            },
            response_model=OrderAmendKeepPriorityResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_amend_keep_priority_success_with_optional_params(self):
        """Test order_amend_keep_priority() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }

        expected_response = {
            "id": "56374b46-3061-486b-a311-89ee972eb648",
            "status": 200,
            "result": {
                "transactTime": 1741924229819,
                "executionId": 60,
                "amendedOrder": {
                    "symbol": "BTUCSDT",
                    "orderId": 23,
                    "orderListId": 4,
                    "origClientOrderId": "my_pending_order",
                    "clientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                    "price": "1.00000000",
                    "qty": "5.00000000",
                    "executedQty": "0.00000000",
                    "preventedQty": "0.00000000",
                    "quoteOrderQty": "0.00000000",
                    "cumulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "BUY",
                    "workingTime": 1741924204920,
                    "selfTradePreventionMode": "NONE",
                },
                "listStatus": {
                    "orderListId": 4,
                    "contingencyType": "OTO",
                    "listOrderStatus": "EXECUTING",
                    "listClientOrderId": "8nOGLLawudj1QoOiwbroRH",
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 23,
                            "clientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 22,
                            "clientOrderId": "g04EWsjaackzedjC9wRkWD",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 23,
                            "clientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 22,
                            "clientOrderId": "g04EWsjaackzedjC9wRkWD",
                        },
                    ],
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_amend_keep_priority(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"][
            "method"
        ] == "/order.amend.keepPriority".replace("/", "")
        assert params["symbol"] == "BNBUSDT"
        assert params["new_qty"] == 1.0
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["order_id"] == 1
        assert params["orig_client_order_id"] == "orig_client_order_id_example"
        assert params["new_client_order_id"] == "new_client_order_id_example"
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/order.amend.keepPriority".replace("/", ""),
                "params": params,
            },
            response_model=OrderAmendKeepPriorityResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_amend_keep_priority_missing_required_param_symbol(self):
        """Test that order_amend_keep_priority() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_amend_keep_priority(**params)

    @pytest.mark.asyncio
    async def test_order_amend_keep_priority_missing_required_param_new_qty(self):
        """Test that order_amend_keep_priority() raises RequiredError when 'new_qty' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }
        del params["new_qty"]

        with pytest.raises(RequiredError, match="Missing required parameter 'new_qty'"):
            await self.websocket_api.order_amend_keep_priority(**params)

    @pytest.mark.asyncio
    async def test_order_amend_keep_priority_server_error(self):
        """Test that order_amend_keep_priority() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_amend_keep_priority(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_success(self):
        """Test order_cancel() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "16eaf097-bbec-44b9-96ff-e97e6e875870",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "origClientOrderId": "4d96324ff9d44481926157",
                "orderId": 12569099453,
                "orderListId": 19431,
                "clientOrderId": "91fe37ce9e69c90d6358c0",
                "transactTime": 1684804350068,
                "price": "23416.10000000",
                "origQty": "0.00847000",
                "executedQty": "0.00001000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.23416100",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "stopPrice": "0.00000000",
                "trailingDelta": 0,
                "icebergQty": "0.00000000",
                "strategyId": 37463720,
                "strategyType": 1000000,
                "selfTradePreventionMode": "NONE",
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "iuVNVJYYrByz6C4yGOPPK0",
                "transactionTime": 1660803702431,
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099454,
                        "clientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099453,
                        "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099454,
                        "clientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099453,
                        "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                        "orderId": 12569099454,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23400.00000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                        "orderId": 12569099453,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23450.50000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "23430.00000000",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                        "orderId": 12569099454,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23400.00000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                        "orderId": 12569099453,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23450.50000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "23430.00000000",
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_cancel(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.cancel".replace("/", "")

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.cancel".replace("/", ""), "params": params},
            response_model=OrderCancelResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_cancel_success_with_optional_params(self):
        """Test order_cancel() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "cancel_restrictions": OrderCancelCancelRestrictionsEnum["ONLY_NEW"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "16eaf097-bbec-44b9-96ff-e97e6e875870",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "origClientOrderId": "4d96324ff9d44481926157",
                "orderId": 12569099453,
                "orderListId": 19431,
                "clientOrderId": "91fe37ce9e69c90d6358c0",
                "transactTime": 1684804350068,
                "price": "23416.10000000",
                "origQty": "0.00847000",
                "executedQty": "0.00001000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.23416100",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "stopPrice": "0.00000000",
                "trailingDelta": 0,
                "icebergQty": "0.00000000",
                "strategyId": 37463720,
                "strategyType": 1000000,
                "selfTradePreventionMode": "NONE",
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "iuVNVJYYrByz6C4yGOPPK0",
                "transactionTime": 1660803702431,
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099454,
                        "clientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099453,
                        "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099454,
                        "clientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569099453,
                        "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                        "orderId": 12569099454,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23400.00000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                        "orderId": 12569099453,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23450.50000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "23430.00000000",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "Tnu2IP0J5Y4mxw3IATBfmW",
                        "orderId": 12569099454,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23400.00000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                        "orderId": 12569099453,
                        "orderListId": 19431,
                        "clientOrderId": "OFFXQtxVFZ6Nbcg4PgE2DA",
                        "transactTime": 1684804350068,
                        "price": "23450.50000000",
                        "origQty": "0.00850000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "23430.00000000",
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_cancel(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.cancel".replace("/", "")
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["order_id"] == 1
        assert params["orig_client_order_id"] == "orig_client_order_id_example"
        assert params["new_client_order_id"] == "new_client_order_id_example"
        assert (
            params["cancel_restrictions"]
            == OrderCancelCancelRestrictionsEnum["ONLY_NEW"].value
        )
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.cancel".replace("/", ""), "params": params},
            response_model=OrderCancelResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_cancel_missing_required_param_symbol(self):
        """Test that order_cancel() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "cancel_restrictions": OrderCancelCancelRestrictionsEnum["ONLY_NEW"].value,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_cancel(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_server_error(self):
        """Test that order_cancel() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_cancel(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_replace_success(self):
        """Test order_cancel_replace() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
        }

        expected_response = {
            "id": "99de1036-b5e2-4e0f-9b5c-13d751c93a1a",
            "status": 200,
            "result": {
                "cancelResult": "SUCCESS",
                "newOrderResult": "SUCCESS",
                "cancelResponse": {
                    "symbol": "BTCUSDT",
                    "origClientOrderId": "4d96324ff9d44481926157",
                    "orderId": 125690984230,
                    "orderListId": -1,
                    "clientOrderId": "91fe37ce9e69c90d6358c0",
                    "transactTime": 1684804350068,
                    "price": "23450.00000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00001000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.23450000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
                "newOrderResponse": {
                    "symbol": "BTCUSDT",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                    "transactTime": 1660813156959,
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 1,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 1,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_cancel_replace(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.cancelReplace".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert (
            params["cancel_replace_mode"]
            == OrderCancelReplaceCancelReplaceModeEnum["STOP_ON_FAILURE"].value
        )

        assert params["side"] == OrderCancelReplaceSideEnum["BUY"].value

        assert params["type"] == OrderCancelReplaceTypeEnum["MARKET"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/order.cancelReplace".replace("/", ""),
                "params": params,
            },
            response_model=OrderCancelReplaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_cancel_replace_success_with_optional_params(self):
        """Test order_cancel_replace() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "cancel_order_id": 1,
            "cancel_orig_client_order_id": "cancel_orig_client_order_id_example",
            "cancel_new_client_order_id": "cancel_new_client_order_id_example",
            "time_in_force": OrderCancelReplaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1.0,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderCancelReplaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "cancel_restrictions": OrderCancelReplaceCancelRestrictionsEnum[
                "ONLY_NEW"
            ].value,
            "order_rate_limit_exceeded_mode": OrderCancelReplaceOrderRateLimitExceededModeEnum[
                "DO_NOTHING"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "99de1036-b5e2-4e0f-9b5c-13d751c93a1a",
            "status": 200,
            "result": {
                "cancelResult": "SUCCESS",
                "newOrderResult": "SUCCESS",
                "cancelResponse": {
                    "symbol": "BTCUSDT",
                    "origClientOrderId": "4d96324ff9d44481926157",
                    "orderId": 125690984230,
                    "orderListId": -1,
                    "clientOrderId": "91fe37ce9e69c90d6358c0",
                    "transactTime": 1684804350068,
                    "price": "23450.00000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00001000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.23450000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
                "newOrderResponse": {
                    "symbol": "BTCUSDT",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "bX5wROblo6YeDwa9iTLeyY",
                    "transactTime": 1660813156959,
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 1,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 1,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_cancel_replace(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.cancelReplace".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert (
            params["cancel_replace_mode"]
            == OrderCancelReplaceCancelReplaceModeEnum["STOP_ON_FAILURE"].value
        )
        assert params["side"] == OrderCancelReplaceSideEnum["BUY"].value
        assert params["type"] == OrderCancelReplaceTypeEnum["MARKET"].value
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["cancel_order_id"] == 1
        assert (
            params["cancel_orig_client_order_id"]
            == "cancel_orig_client_order_id_example"
        )
        assert (
            params["cancel_new_client_order_id"] == "cancel_new_client_order_id_example"
        )
        assert params["time_in_force"] == OrderCancelReplaceTimeInForceEnum["GTC"].value
        assert params["price"] == 1.0
        assert params["quantity"] == 1.0
        assert params["quote_order_qty"] == 1.0
        assert params["new_client_order_id"] == "new_client_order_id_example"
        assert (
            params["new_order_resp_type"]
            == OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value
        )
        assert params["stop_price"] == 1.0
        assert params["trailing_delta"] == 1.0
        assert params["iceberg_qty"] == 1.0
        assert params["strategy_id"] == 1
        assert params["strategy_type"] == 1
        assert (
            params["self_trade_prevention_mode"]
            == OrderCancelReplaceSelfTradePreventionModeEnum["NONE"].value
        )
        assert (
            params["cancel_restrictions"]
            == OrderCancelReplaceCancelRestrictionsEnum["ONLY_NEW"].value
        )
        assert (
            params["order_rate_limit_exceeded_mode"]
            == OrderCancelReplaceOrderRateLimitExceededModeEnum["DO_NOTHING"].value
        )
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/order.cancelReplace".replace("/", ""),
                "params": params,
            },
            response_model=OrderCancelReplaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_cancel_replace_missing_required_param_symbol(self):
        """Test that order_cancel_replace() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "cancel_order_id": 1,
            "cancel_orig_client_order_id": "cancel_orig_client_order_id_example",
            "cancel_new_client_order_id": "cancel_new_client_order_id_example",
            "time_in_force": OrderCancelReplaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1.0,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderCancelReplaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "cancel_restrictions": OrderCancelReplaceCancelRestrictionsEnum[
                "ONLY_NEW"
            ].value,
            "order_rate_limit_exceeded_mode": OrderCancelReplaceOrderRateLimitExceededModeEnum[
                "DO_NOTHING"
            ].value,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_cancel_replace(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_replace_missing_required_param_cancel_replace_mode(
        self,
    ):
        """Test that order_cancel_replace() raises RequiredError when 'cancel_replace_mode' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "cancel_order_id": 1,
            "cancel_orig_client_order_id": "cancel_orig_client_order_id_example",
            "cancel_new_client_order_id": "cancel_new_client_order_id_example",
            "time_in_force": OrderCancelReplaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1.0,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderCancelReplaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "cancel_restrictions": OrderCancelReplaceCancelRestrictionsEnum[
                "ONLY_NEW"
            ].value,
            "order_rate_limit_exceeded_mode": OrderCancelReplaceOrderRateLimitExceededModeEnum[
                "DO_NOTHING"
            ].value,
            "recv_window": 5000,
        }
        del params["cancel_replace_mode"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'cancel_replace_mode'"
        ):
            await self.websocket_api.order_cancel_replace(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_replace_missing_required_param_side(self):
        """Test that order_cancel_replace() raises RequiredError when 'side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "cancel_order_id": 1,
            "cancel_orig_client_order_id": "cancel_orig_client_order_id_example",
            "cancel_new_client_order_id": "cancel_new_client_order_id_example",
            "time_in_force": OrderCancelReplaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1.0,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderCancelReplaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "cancel_restrictions": OrderCancelReplaceCancelRestrictionsEnum[
                "ONLY_NEW"
            ].value,
            "order_rate_limit_exceeded_mode": OrderCancelReplaceOrderRateLimitExceededModeEnum[
                "DO_NOTHING"
            ].value,
            "recv_window": 5000,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            await self.websocket_api.order_cancel_replace(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_replace_missing_required_param_type(self):
        """Test that order_cancel_replace() raises RequiredError when 'type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "cancel_order_id": 1,
            "cancel_orig_client_order_id": "cancel_orig_client_order_id_example",
            "cancel_new_client_order_id": "cancel_new_client_order_id_example",
            "time_in_force": OrderCancelReplaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1.0,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderCancelReplaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "cancel_restrictions": OrderCancelReplaceCancelRestrictionsEnum[
                "ONLY_NEW"
            ].value,
            "order_rate_limit_exceeded_mode": OrderCancelReplaceOrderRateLimitExceededModeEnum[
                "DO_NOTHING"
            ].value,
            "recv_window": 5000,
        }
        del params["type"]

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            await self.websocket_api.order_cancel_replace(**params)

    @pytest.mark.asyncio
    async def test_order_cancel_replace_server_error(self):
        """Test that order_cancel_replace() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_cancel_replace(**params)

    @pytest.mark.asyncio
    async def test_order_list_cancel_success(self):
        """Test order_list_cancel() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "c5899911-d3f4-47ae-8835-97da553d27d0",
            "status": 200,
            "result": {
                "orderListId": 1274512,
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "6023531d7edaad348f5aff",
                "transactionTime": 1660801720215,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "orderListId": 1274512,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                        "transactTime": 1660801720215,
                        "price": "23420.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "SELL",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "orderListId": 1274512,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                        "transactTime": 1660801720215,
                        "price": "23410.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "SELL",
                        "stopPrice": "23405.00000000",
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_list_cancel(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.cancel".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/orderList.cancel".replace("/", ""), "params": params},
            response_model=OrderListCancelResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_cancel_success_with_optional_params(self):
        """Test order_list_cancel() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_list_id": 1,
            "list_client_order_id": "list_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }

        expected_response = {
            "id": "c5899911-d3f4-47ae-8835-97da553d27d0",
            "status": 200,
            "result": {
                "orderListId": 1274512,
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "6023531d7edaad348f5aff",
                "transactionTime": 1660801720215,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "orderListId": 1274512,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                        "transactTime": 1660801720215,
                        "price": "23420.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "SELL",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "orderListId": 1274512,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                        "transactTime": 1660801720215,
                        "price": "23410.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "SELL",
                        "stopPrice": "23405.00000000",
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_list_cancel(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.cancel".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["order_list_id"] == 1
        assert params["list_client_order_id"] == "list_client_order_id_example"
        assert params["new_client_order_id"] == "new_client_order_id_example"
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/orderList.cancel".replace("/", ""), "params": params},
            response_model=OrderListCancelResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_cancel_missing_required_param_symbol(self):
        """Test that order_list_cancel() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_list_id": 1,
            "list_client_order_id": "list_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_list_cancel(**params)

    @pytest.mark.asyncio
    async def test_order_list_cancel_server_error(self):
        """Test that order_list_cancel() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_list_cancel(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_success(self):
        """Test order_list_place() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
        }

        expected_response = {
            "id": "57833dc0-e3f2-43fb-ba20-46480973b0aa",
            "status": 200,
            "result": {
                "orderListId": 1274512,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "08985fedd9ea2cf6b28996",
                "transactionTime": 1660801713793,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "orderListId": 1274512,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                        "transactTime": 1660801713793,
                        "price": "23420.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "SELL",
                        "workingTime": 1660801713793,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "orderListId": 1274512,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                        "transactTime": 1660801713793,
                        "price": "23410.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "SELL",
                        "stopPrice": "23405.00000000",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 2,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 2,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_list_place(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert params["side"] == OrderListPlaceSideEnum["BUY"].value

        assert params["price"] == 1.0

        assert params["quantity"] == 1.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/orderList.place".replace("/", ""), "params": params},
            response_model=OrderListPlaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_success_with_optional_params(self):
        """Test order_list_place() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "limit_client_order_id": "limit_client_order_id_example",
            "limit_iceberg_qty": 1.0,
            "limit_strategy_id": 1,
            "limit_strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "stop_client_order_id": "stop_client_order_id_example",
            "stop_limit_price": 1.0,
            "stop_limit_time_in_force": OrderListPlaceStopLimitTimeInForceEnum[
                "GTC"
            ].value,
            "stop_iceberg_qty": 1.0,
            "stop_strategy_id": 1,
            "stop_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "57833dc0-e3f2-43fb-ba20-46480973b0aa",
            "status": 200,
            "result": {
                "orderListId": 1274512,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "08985fedd9ea2cf6b28996",
                "transactionTime": 1660801713793,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "orderListId": 1274512,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                        "transactTime": 1660801713793,
                        "price": "23420.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "SELL",
                        "workingTime": 1660801713793,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "orderListId": 1274512,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                        "transactTime": 1660801713793,
                        "price": "23410.00000000",
                        "origQty": "0.00650000",
                        "executedQty": "0.00000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "SELL",
                        "stopPrice": "23405.00000000",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 2,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 2,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_list_place(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["side"] == OrderListPlaceSideEnum["BUY"].value
        assert params["price"] == 1.0
        assert params["quantity"] == 1.0
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["list_client_order_id"] == "list_client_order_id_example"
        assert params["limit_client_order_id"] == "limit_client_order_id_example"
        assert params["limit_iceberg_qty"] == 1.0
        assert params["limit_strategy_id"] == 1
        assert params["limit_strategy_type"] == 1
        assert params["stop_price"] == 1.0
        assert params["trailing_delta"] == 1
        assert params["stop_client_order_id"] == "stop_client_order_id_example"
        assert params["stop_limit_price"] == 1.0
        assert (
            params["stop_limit_time_in_force"]
            == OrderListPlaceStopLimitTimeInForceEnum["GTC"].value
        )
        assert params["stop_iceberg_qty"] == 1.0
        assert params["stop_strategy_id"] == 1
        assert params["stop_strategy_type"] == 1
        assert (
            params["new_order_resp_type"]
            == OrderListPlaceNewOrderRespTypeEnum["ACK"].value
        )
        assert (
            params["self_trade_prevention_mode"]
            == OrderListPlaceSelfTradePreventionModeEnum["NONE"].value
        )
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/orderList.place".replace("/", ""), "params": params},
            response_model=OrderListPlaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_missing_required_param_symbol(self):
        """Test that order_list_place() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "limit_client_order_id": "limit_client_order_id_example",
            "limit_iceberg_qty": 1.0,
            "limit_strategy_id": 1,
            "limit_strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "stop_client_order_id": "stop_client_order_id_example",
            "stop_limit_price": 1.0,
            "stop_limit_time_in_force": OrderListPlaceStopLimitTimeInForceEnum[
                "GTC"
            ].value,
            "stop_iceberg_qty": 1.0,
            "stop_strategy_id": 1,
            "stop_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_list_place(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_missing_required_param_side(self):
        """Test that order_list_place() raises RequiredError when 'side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "limit_client_order_id": "limit_client_order_id_example",
            "limit_iceberg_qty": 1.0,
            "limit_strategy_id": 1,
            "limit_strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "stop_client_order_id": "stop_client_order_id_example",
            "stop_limit_price": 1.0,
            "stop_limit_time_in_force": OrderListPlaceStopLimitTimeInForceEnum[
                "GTC"
            ].value,
            "stop_iceberg_qty": 1.0,
            "stop_strategy_id": 1,
            "stop_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            await self.websocket_api.order_list_place(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_missing_required_param_price(self):
        """Test that order_list_place() raises RequiredError when 'price' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "limit_client_order_id": "limit_client_order_id_example",
            "limit_iceberg_qty": 1.0,
            "limit_strategy_id": 1,
            "limit_strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "stop_client_order_id": "stop_client_order_id_example",
            "stop_limit_price": 1.0,
            "stop_limit_time_in_force": OrderListPlaceStopLimitTimeInForceEnum[
                "GTC"
            ].value,
            "stop_iceberg_qty": 1.0,
            "stop_strategy_id": 1,
            "stop_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["price"]

        with pytest.raises(RequiredError, match="Missing required parameter 'price'"):
            await self.websocket_api.order_list_place(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_missing_required_param_quantity(self):
        """Test that order_list_place() raises RequiredError when 'quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "limit_client_order_id": "limit_client_order_id_example",
            "limit_iceberg_qty": 1.0,
            "limit_strategy_id": 1,
            "limit_strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "stop_client_order_id": "stop_client_order_id_example",
            "stop_limit_price": 1.0,
            "stop_limit_time_in_force": OrderListPlaceStopLimitTimeInForceEnum[
                "GTC"
            ].value,
            "stop_iceberg_qty": 1.0,
            "stop_strategy_id": 1,
            "stop_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            await self.websocket_api.order_list_place(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_server_error(self):
        """Test that order_list_place() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceSideEnum["BUY"].value,
            "price": 1.0,
            "quantity": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_list_place(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oco_success(self):
        """Test order_list_place_oco() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
        }

        expected_response = {
            "id": "56374a46-3261-486b-a211-99ed972eb648",
            "status": 200,
            "result": {
                "orderListId": 2,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "cKPMnDCbcLQILtDYM4f4fX",
                "transactionTime": 1711062760648,
                "symbol": "LTCBNB",
                "orders": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 3,
                        "clientOrderId": "Z2IMlR79XNY5LU0tOxrWyW",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 2,
                        "clientOrderId": "0m6I4wfxvTUrOBSMUl0OPU",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 3,
                        "orderListId": 2,
                        "clientOrderId": "Z2IMlR79XNY5LU0tOxrWyW",
                        "transactTime": 1711062760648,
                        "price": "1.49999999",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "workingTime": 1711062760648,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 2,
                        "orderListId": 2,
                        "clientOrderId": "0m6I4wfxvTUrOBSMUl0OPU",
                        "transactTime": 1711062760648,
                        "price": "1.50000000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "1.50000001",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 2,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 2,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_list_place_oco(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place.oco".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert params["side"] == OrderListPlaceOcoSideEnum["BUY"].value

        assert params["quantity"] == 1.0

        assert (
            params["above_type"]
            == OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value
        )

        assert params["below_type"] == OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.place.oco".replace("/", ""),
                "params": params,
            },
            response_model=OrderListPlaceOcoResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_oco_success_with_optional_params(self):
        """Test order_list_place_oco() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListPlaceOcoBelowTimeInForceEnum[
                "belowType"
            ].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "56374a46-3261-486b-a211-99ed972eb648",
            "status": 200,
            "result": {
                "orderListId": 2,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "cKPMnDCbcLQILtDYM4f4fX",
                "transactionTime": 1711062760648,
                "symbol": "LTCBNB",
                "orders": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 3,
                        "clientOrderId": "Z2IMlR79XNY5LU0tOxrWyW",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 2,
                        "clientOrderId": "0m6I4wfxvTUrOBSMUl0OPU",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 3,
                        "orderListId": 2,
                        "clientOrderId": "Z2IMlR79XNY5LU0tOxrWyW",
                        "transactTime": 1711062760648,
                        "price": "1.49999999",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "workingTime": 1711062760648,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 2,
                        "orderListId": 2,
                        "clientOrderId": "0m6I4wfxvTUrOBSMUl0OPU",
                        "transactTime": 1711062760648,
                        "price": "1.50000000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.00000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "1.50000001",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 2,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 2,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_list_place_oco(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place.oco".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["side"] == OrderListPlaceOcoSideEnum["BUY"].value
        assert params["quantity"] == 1.0
        assert (
            params["above_type"]
            == OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value
        )
        assert params["below_type"] == OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["list_client_order_id"] == "list_client_order_id_example"
        assert params["above_client_order_id"] == "above_client_order_id_example"
        assert params["above_iceberg_qty"] == 1
        assert params["above_price"] == 1.0
        assert params["above_stop_price"] == 1.0
        assert params["above_trailing_delta"] == 1
        assert params["above_time_in_force"] == 1.0
        assert params["above_strategy_id"] == 1
        assert params["above_strategy_type"] == 1
        assert params["below_client_order_id"] == "below_client_order_id_example"
        assert params["below_iceberg_qty"] == 1
        assert params["below_price"] == 1.0
        assert params["below_stop_price"] == 1.0
        assert params["below_trailing_delta"] == 1
        assert (
            params["below_time_in_force"]
            == OrderListPlaceOcoBelowTimeInForceEnum["belowType"].value
        )
        assert params["below_strategy_id"] == 1
        assert params["below_strategy_type"] == 1
        assert (
            params["new_order_resp_type"]
            == OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value
        )
        assert (
            params["self_trade_prevention_mode"]
            == OrderListPlaceOcoSelfTradePreventionModeEnum["NONE"].value
        )
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.place.oco".replace("/", ""),
                "params": params,
            },
            response_model=OrderListPlaceOcoResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_oco_missing_required_param_symbol(self):
        """Test that order_list_place_oco() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListPlaceOcoBelowTimeInForceEnum[
                "belowType"
            ].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_list_place_oco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oco_missing_required_param_side(self):
        """Test that order_list_place_oco() raises RequiredError when 'side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListPlaceOcoBelowTimeInForceEnum[
                "belowType"
            ].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            await self.websocket_api.order_list_place_oco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oco_missing_required_param_quantity(self):
        """Test that order_list_place_oco() raises RequiredError when 'quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListPlaceOcoBelowTimeInForceEnum[
                "belowType"
            ].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            await self.websocket_api.order_list_place_oco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oco_missing_required_param_above_type(self):
        """Test that order_list_place_oco() raises RequiredError when 'above_type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListPlaceOcoBelowTimeInForceEnum[
                "belowType"
            ].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["above_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'above_type'"
        ):
            await self.websocket_api.order_list_place_oco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oco_missing_required_param_below_type(self):
        """Test that order_list_place_oco() raises RequiredError when 'below_type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListPlaceOcoBelowTimeInForceEnum[
                "belowType"
            ].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListPlaceOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["below_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'below_type'"
        ):
            await self.websocket_api.order_list_place_oco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oco_server_error(self):
        """Test that order_list_place_oco() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListPlaceOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListPlaceOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListPlaceOcoBelowTypeEnum["STOP_LOSS"].value,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_list_place_oco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_success(self):
        """Test order_list_place_oto() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }

        expected_response = {
            "id": "1712544395950",
            "status": 200,
            "result": {
                "orderListId": 626,
                "contingencyType": "OTO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "KA4EBjGnzvSwSCQsDdTrlf",
                "transactionTime": 1712544395981,
                "symbol": "1712544378871",
                "orders": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 14,
                        "clientOrderId": "9MxJSE1TYkmyx5lbGLve7R",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 13,
                        "clientOrderId": "YiAUtM9yJjl1a2jXHSp9Ny",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 14,
                        "orderListId": 626,
                        "clientOrderId": "9MxJSE1TYkmyx5lbGLve7R",
                        "transactTime": 1712544395981,
                        "price": "0.000000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "PENDING_NEW",
                        "timeInForce": "GTC",
                        "type": "MARKET",
                        "side": "BUY",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 13,
                        "orderListId": 626,
                        "clientOrderId": "YiAUtM9yJjl1a2jXHSp9Ny",
                        "transactTime": 1712544395981,
                        "price": "1.000000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT",
                        "side": "SELL",
                        "workingTime": 1712544395981,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 10000000,
                    "count": 10,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 1000,
                    "count": 38,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_list_place_oto(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place.oto".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert params["working_type"] == OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value

        assert params["working_side"] == OrderListPlaceOtoWorkingSideEnum["BUY"].value

        assert params["working_price"] == 1.0

        assert params["working_quantity"] == 1.0

        assert params["pending_type"] == OrderListPlaceOtoPendingTypeEnum["LIMIT"].value

        assert params["pending_side"] == OrderListPlaceOtoPendingSideEnum["BUY"].value

        assert params["pending_quantity"] == 1.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.place.oto".replace("/", ""),
                "params": params,
            },
            response_model=OrderListPlaceOtoResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_oto_success_with_optional_params(self):
        """Test order_list_place_oto() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "1712544395950",
            "status": 200,
            "result": {
                "orderListId": 626,
                "contingencyType": "OTO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "KA4EBjGnzvSwSCQsDdTrlf",
                "transactionTime": 1712544395981,
                "symbol": "1712544378871",
                "orders": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 14,
                        "clientOrderId": "9MxJSE1TYkmyx5lbGLve7R",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 13,
                        "clientOrderId": "YiAUtM9yJjl1a2jXHSp9Ny",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 14,
                        "orderListId": 626,
                        "clientOrderId": "9MxJSE1TYkmyx5lbGLve7R",
                        "transactTime": 1712544395981,
                        "price": "0.000000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "PENDING_NEW",
                        "timeInForce": "GTC",
                        "type": "MARKET",
                        "side": "BUY",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 13,
                        "orderListId": 626,
                        "clientOrderId": "YiAUtM9yJjl1a2jXHSp9Ny",
                        "transactTime": 1712544395981,
                        "price": "1.000000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT",
                        "side": "SELL",
                        "workingTime": 1712544395981,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 10000000,
                    "count": 10,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 1000,
                    "count": 38,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_list_place_oto(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place.oto".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["working_type"] == OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value
        assert params["working_side"] == OrderListPlaceOtoWorkingSideEnum["BUY"].value
        assert params["working_price"] == 1.0
        assert params["working_quantity"] == 1.0
        assert params["pending_type"] == OrderListPlaceOtoPendingTypeEnum["LIMIT"].value
        assert params["pending_side"] == OrderListPlaceOtoPendingSideEnum["BUY"].value
        assert params["pending_quantity"] == 1.0
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["list_client_order_id"] == "list_client_order_id_example"
        assert (
            params["new_order_resp_type"]
            == OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value
        )
        assert (
            params["self_trade_prevention_mode"]
            == OrderListPlaceOtoSelfTradePreventionModeEnum["NONE"].value
        )
        assert params["working_client_order_id"] == "working_client_order_id_example"
        assert params["working_iceberg_qty"] == 1.0
        assert (
            params["working_time_in_force"]
            == OrderListPlaceOtoWorkingTimeInForceEnum["GTC"].value
        )
        assert params["working_strategy_id"] == 1
        assert params["working_strategy_type"] == 1
        assert params["pending_client_order_id"] == "pending_client_order_id_example"
        assert params["pending_price"] == 1.0
        assert params["pending_stop_price"] == 1.0
        assert params["pending_trailing_delta"] == 1.0
        assert params["pending_iceberg_qty"] == 1.0
        assert (
            params["pending_time_in_force"]
            == OrderListPlaceOtoPendingTimeInForceEnum["GTC"].value
        )
        assert params["pending_strategy_id"] == 1
        assert params["pending_strategy_type"] == 1
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.place.oto".replace("/", ""),
                "params": params,
            },
            response_model=OrderListPlaceOtoResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_symbol(self):
        """Test that order_list_place_oto() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_working_type(self):
        """Test that order_list_place_oto() raises RequiredError when 'working_type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_type'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_working_side(self):
        """Test that order_list_place_oto() raises RequiredError when 'working_side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_side'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_working_price(self):
        """Test that order_list_place_oto() raises RequiredError when 'working_price' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_price"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_price'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_working_quantity(self):
        """Test that order_list_place_oto() raises RequiredError when 'working_quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_quantity'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_pending_type(self):
        """Test that order_list_place_oto() raises RequiredError when 'pending_type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["pending_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_type'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_pending_side(self):
        """Test that order_list_place_oto() raises RequiredError when 'pending_side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["pending_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_side'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_missing_required_param_pending_quantity(self):
        """Test that order_list_place_oto() raises RequiredError when 'pending_quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListPlaceOtoPendingTimeInForceEnum[
                "GTC"
            ].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["pending_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_quantity'"
        ):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_oto_server_error(self):
        """Test that order_list_place_oto() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListPlaceOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListPlaceOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_list_place_oto(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_success(self):
        """Test order_list_place_otoco() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }

        expected_response = {
            "id": "1712544408508",
            "status": 200,
            "result": {
                "orderListId": 629,
                "contingencyType": "OTO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "GaeJHjZPasPItFj4x7Mqm6",
                "transactionTime": 1712544408537,
                "symbol": "1712544378871",
                "orders": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 25,
                        "clientOrderId": "ilpIoShcFZ1ZGgSASKxMPt",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 24,
                        "clientOrderId": "YcCPKCDMQIjNvLtNswt82X",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 23,
                        "clientOrderId": "OVQOpKwfmPCfaBTD0n7e7H",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 25,
                        "orderListId": 629,
                        "clientOrderId": "ilpIoShcFZ1ZGgSASKxMPt",
                        "transactTime": 1712544408537,
                        "price": "5.000000",
                        "origQty": "5.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "PENDING_NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "SELL",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 24,
                        "orderListId": 629,
                        "clientOrderId": "YcCPKCDMQIjNvLtNswt82X",
                        "transactTime": 1712544408537,
                        "price": "0.000000",
                        "origQty": "5.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "PENDING_NEW",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS",
                        "side": "SELL",
                        "stopPrice": "0.500000",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 23,
                        "orderListId": 629,
                        "clientOrderId": "OVQOpKwfmPCfaBTD0n7e7H",
                        "transactTime": 1712544408537,
                        "price": "1.500000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT",
                        "side": "BUY",
                        "workingTime": 1712544408537,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 10000000,
                    "count": 18,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 1000,
                    "count": 65,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_list_place_otoco(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place.otoco".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert (
            params["working_type"] == OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value
        )

        assert params["working_side"] == OrderListPlaceOtocoWorkingSideEnum["BUY"].value

        assert params["working_price"] == 1.0

        assert params["working_quantity"] == 1.0

        assert params["pending_side"] == OrderListPlaceOtocoPendingSideEnum["BUY"].value

        assert params["pending_quantity"] == 1.0

        assert (
            params["pending_above_type"]
            == OrderListPlaceOtocoPendingAboveTypeEnum["STOP_LOSS_LIMIT"].value
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.place.otoco".replace("/", ""),
                "params": params,
            },
            response_model=OrderListPlaceOtocoResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_success_with_optional_params(self):
        """Test order_list_place_otoco() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "1712544408508",
            "status": 200,
            "result": {
                "orderListId": 629,
                "contingencyType": "OTO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "GaeJHjZPasPItFj4x7Mqm6",
                "transactionTime": 1712544408537,
                "symbol": "1712544378871",
                "orders": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 25,
                        "clientOrderId": "ilpIoShcFZ1ZGgSASKxMPt",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 24,
                        "clientOrderId": "YcCPKCDMQIjNvLtNswt82X",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 23,
                        "clientOrderId": "OVQOpKwfmPCfaBTD0n7e7H",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "LTCBNB",
                        "orderId": 25,
                        "orderListId": 629,
                        "clientOrderId": "ilpIoShcFZ1ZGgSASKxMPt",
                        "transactTime": 1712544408537,
                        "price": "5.000000",
                        "origQty": "5.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "PENDING_NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "SELL",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 24,
                        "orderListId": 629,
                        "clientOrderId": "YcCPKCDMQIjNvLtNswt82X",
                        "transactTime": 1712544408537,
                        "price": "0.000000",
                        "origQty": "5.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "PENDING_NEW",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS",
                        "side": "SELL",
                        "stopPrice": "0.500000",
                        "workingTime": -1,
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "LTCBNB",
                        "orderId": 23,
                        "orderListId": 629,
                        "clientOrderId": "OVQOpKwfmPCfaBTD0n7e7H",
                        "transactTime": 1712544408537,
                        "price": "1.500000",
                        "origQty": "1.000000",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "NEW",
                        "timeInForce": "GTC",
                        "type": "LIMIT",
                        "side": "BUY",
                        "workingTime": 1712544408537,
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 10000000,
                    "count": 18,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 1000,
                    "count": 65,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_list_place_otoco(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.place.otoco".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert (
            params["working_type"] == OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value
        )
        assert params["working_side"] == OrderListPlaceOtocoWorkingSideEnum["BUY"].value
        assert params["working_price"] == 1.0
        assert params["working_quantity"] == 1.0
        assert params["pending_side"] == OrderListPlaceOtocoPendingSideEnum["BUY"].value
        assert params["pending_quantity"] == 1.0
        assert (
            params["pending_above_type"]
            == OrderListPlaceOtocoPendingAboveTypeEnum["STOP_LOSS_LIMIT"].value
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["list_client_order_id"] == "list_client_order_id_example"
        assert (
            params["new_order_resp_type"]
            == OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value
        )
        assert (
            params["self_trade_prevention_mode"]
            == OrderListPlaceOtocoSelfTradePreventionModeEnum["NONE"].value
        )
        assert params["working_client_order_id"] == "working_client_order_id_example"
        assert params["working_iceberg_qty"] == 1.0
        assert (
            params["working_time_in_force"]
            == OrderListPlaceOtocoWorkingTimeInForceEnum["GTC"].value
        )
        assert params["working_strategy_id"] == 1
        assert params["working_strategy_type"] == 1
        assert (
            params["pending_above_client_order_id"]
            == "pending_above_client_order_id_example"
        )
        assert params["pending_above_price"] == 1.0
        assert params["pending_above_stop_price"] == 1.0
        assert params["pending_above_trailing_delta"] == 1.0
        assert params["pending_above_iceberg_qty"] == 1.0
        assert (
            params["pending_above_time_in_force"]
            == OrderListPlaceOtocoPendingAboveTimeInForceEnum["GTC"].value
        )
        assert params["pending_above_strategy_id"] == 1
        assert params["pending_above_strategy_type"] == 1
        assert (
            params["pending_below_type"]
            == OrderListPlaceOtocoPendingBelowTypeEnum["STOP_LOSS"].value
        )
        assert (
            params["pending_below_client_order_id"]
            == "pending_below_client_order_id_example"
        )
        assert params["pending_below_price"] == 1.0
        assert params["pending_below_stop_price"] == 1.0
        assert params["pending_below_trailing_delta"] == 1.0
        assert params["pending_below_iceberg_qty"] == 1.0
        assert (
            params["pending_below_time_in_force"]
            == OrderListPlaceOtocoPendingBelowTimeInForceEnum["GTC"].value
        )
        assert params["pending_below_strategy_id"] == 1
        assert params["pending_below_strategy_type"] == 1
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.place.otoco".replace("/", ""),
                "params": params,
            },
            response_model=OrderListPlaceOtocoResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_symbol(self):
        """Test that order_list_place_otoco() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_working_type(self):
        """Test that order_list_place_otoco() raises RequiredError when 'working_type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_type'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_working_side(self):
        """Test that order_list_place_otoco() raises RequiredError when 'working_side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_side'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_working_price(self):
        """Test that order_list_place_otoco() raises RequiredError when 'working_price' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_price"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_price'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_working_quantity(self):
        """Test that order_list_place_otoco() raises RequiredError when 'working_quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["working_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_quantity'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_pending_side(self):
        """Test that order_list_place_otoco() raises RequiredError when 'pending_side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["pending_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_side'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_pending_quantity(self):
        """Test that order_list_place_otoco() raises RequiredError when 'pending_quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["pending_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_quantity'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_missing_required_param_pending_above_type(
        self,
    ):
        """Test that order_list_place_otoco() raises RequiredError when 'pending_above_type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListPlaceOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListPlaceOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListPlaceOtocoWorkingTimeInForceEnum[
                "GTC"
            ].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListPlaceOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListPlaceOtocoPendingBelowTypeEnum[
                "STOP_LOSS"
            ].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListPlaceOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }
        del params["pending_above_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_above_type'"
        ):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_list_place_otoco_server_error(self):
        """Test that order_list_place_otoco() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListPlaceOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListPlaceOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListPlaceOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListPlaceOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_list_place_otoco(**params)

    @pytest.mark.asyncio
    async def test_order_place_success(self):
        """Test order_place() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderPlaceSideEnum["BUY"].value,
            "type": OrderPlaceTypeEnum["MARKET"].value,
        }

        expected_response = {
            "id": "56374a46-3061-486b-a311-99ee972eb648",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "orderId": 12569099453,
                "orderListId": -1,
                "clientOrderId": "4d96324ff9d44481926157ec08158a40",
                "transactTime": 1660801715793,
                "price": "23416.10000000",
                "origQty": "0.00847000",
                "executedQty": "0.00847000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "198.33521500",
                "status": "FILLED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "workingTime": 1660801715793,
                "selfTradePreventionMode": "NONE",
                "fills": [
                    {
                        "price": "23416.50000000",
                        "qty": "0.00212000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422482,
                    },
                    {
                        "price": "23416.10000000",
                        "qty": "0.00635000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422481,
                    },
                    {
                        "price": "23416.50000000",
                        "qty": "0.00212000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422482,
                    },
                    {
                        "price": "23416.10000000",
                        "qty": "0.00635000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422481,
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 1,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 1,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_place(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.place".replace("/", "")

        assert params["symbol"] == "BNBUSDT"

        assert params["side"] == OrderPlaceSideEnum["BUY"].value

        assert params["type"] == OrderPlaceTypeEnum["MARKET"].value

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.place".replace("/", ""), "params": params},
            response_model=OrderPlaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_place_success_with_optional_params(self):
        """Test order_place() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderPlaceSideEnum["BUY"].value,
            "type": OrderPlaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": OrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "56374a46-3061-486b-a311-99ee972eb648",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "orderId": 12569099453,
                "orderListId": -1,
                "clientOrderId": "4d96324ff9d44481926157ec08158a40",
                "transactTime": 1660801715793,
                "price": "23416.10000000",
                "origQty": "0.00847000",
                "executedQty": "0.00847000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "198.33521500",
                "status": "FILLED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "workingTime": 1660801715793,
                "selfTradePreventionMode": "NONE",
                "fills": [
                    {
                        "price": "23416.50000000",
                        "qty": "0.00212000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422482,
                    },
                    {
                        "price": "23416.10000000",
                        "qty": "0.00635000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422481,
                    },
                    {
                        "price": "23416.50000000",
                        "qty": "0.00212000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422482,
                    },
                    {
                        "price": "23416.10000000",
                        "qty": "0.00635000",
                        "commission": "0.000000",
                        "commissionAsset": "BNB",
                        "tradeId": 1650422481,
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 1,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 1,
                },
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                },
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_place(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.place".replace("/", "")
        assert params["symbol"] == "BNBUSDT"
        assert params["side"] == OrderPlaceSideEnum["BUY"].value
        assert params["type"] == OrderPlaceTypeEnum["MARKET"].value
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["time_in_force"] == OrderPlaceTimeInForceEnum["GTC"].value
        assert params["price"] == 1.0
        assert params["quantity"] == 1.0
        assert params["quote_order_qty"] == 1.0
        assert params["new_client_order_id"] == "new_client_order_id_example"
        assert (
            params["new_order_resp_type"] == OrderPlaceNewOrderRespTypeEnum["ACK"].value
        )
        assert params["stop_price"] == 1.0
        assert params["trailing_delta"] == 1
        assert params["iceberg_qty"] == 1.0
        assert params["strategy_id"] == 1
        assert params["strategy_type"] == 1
        assert (
            params["self_trade_prevention_mode"]
            == OrderPlaceSelfTradePreventionModeEnum["NONE"].value
        )
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.place".replace("/", ""), "params": params},
            response_model=OrderPlaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_place_missing_required_param_symbol(self):
        """Test that order_place() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderPlaceSideEnum["BUY"].value,
            "type": OrderPlaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": OrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_place(**params)

    @pytest.mark.asyncio
    async def test_order_place_missing_required_param_side(self):
        """Test that order_place() raises RequiredError when 'side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderPlaceSideEnum["BUY"].value,
            "type": OrderPlaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": OrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            await self.websocket_api.order_place(**params)

    @pytest.mark.asyncio
    async def test_order_place_missing_required_param_type(self):
        """Test that order_place() raises RequiredError when 'type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderPlaceSideEnum["BUY"].value,
            "type": OrderPlaceTypeEnum["MARKET"].value,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": OrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": OrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": OrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["type"]

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            await self.websocket_api.order_place(**params)

    @pytest.mark.asyncio
    async def test_order_place_server_error(self):
        """Test that order_place() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderPlaceSideEnum["BUY"].value,
            "type": OrderPlaceTypeEnum["MARKET"].value,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_place(**params)

    @pytest.mark.asyncio
    async def test_order_test_success(self):
        """Test order_test() successfully with required parameters only."""

        expected_response = {
            "id": "6ffebe91-01d9-43ac-be99-57cf062e0e30",
            "status": 200,
            "result": {
                "standardCommissionForOrder": {
                    "maker": "0.00000112",
                    "taker": "0.00000114",
                },
                "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
                "discount": {
                    "enabledForAccount": True,
                    "enabledForSymbol": True,
                    "discountAsset": "BNB",
                    "discount": "0.25000000",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_test()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.test".replace("/", "")

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.test".replace("/", ""), "params": {}},
            response_model=OrderTestResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_test_success_with_optional_params(self):
        """Test order_test() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "compute_commission_rates": False,
        }

        expected_response = {
            "id": "6ffebe91-01d9-43ac-be99-57cf062e0e30",
            "status": 200,
            "result": {
                "standardCommissionForOrder": {
                    "maker": "0.00000112",
                    "taker": "0.00000114",
                },
                "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
                "discount": {
                    "enabledForAccount": True,
                    "enabledForSymbol": True,
                    "discountAsset": "BNB",
                    "discount": "0.25000000",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_test(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.test".replace("/", "")
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["compute_commission_rates"] is False

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.test".replace("/", ""), "params": params},
            response_model=OrderTestResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_test_server_error(self):
        """Test that order_test() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_test()

    @pytest.mark.asyncio
    async def test_sor_order_place_success(self):
        """Test sor_order_place() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }

        expected_response = {
            "id": "3a4437e2-41a3-4c19-897c-9cadc5dce8b6",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 2,
                    "orderListId": -1,
                    "clientOrderId": "sBI1KM6nNtOfj5tccZSKly",
                    "transactTime": 1689149087774,
                    "price": "31000.00000000",
                    "origQty": "0.50000000",
                    "executedQty": "0.50000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "14000.00000000",
                    "status": "FILLED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "BUY",
                    "workingTime": 1689149087774,
                    "fills": [
                        {
                            "matchType": "ONE_PARTY_TRADE_REPORT",
                            "price": "28000.00000000",
                            "qty": "0.50000000",
                            "commission": "0.00000000",
                            "commissionAsset": "BTC",
                            "tradeId": -1,
                            "allocId": 0,
                        }
                    ],
                    "workingFloor": "SOR",
                    "selfTradePreventionMode": "NONE",
                    "usedSor": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.sor_order_place(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/sor.order.place".replace(
            "/", ""
        )

        assert params["symbol"] == "BNBUSDT"

        assert params["side"] == SorOrderPlaceSideEnum["BUY"].value

        assert params["type"] == SorOrderPlaceTypeEnum["MARKET"].value

        assert params["quantity"] == 1.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/sor.order.place".replace("/", ""), "params": params},
            response_model=SorOrderPlaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_sor_order_place_success_with_optional_params(self):
        """Test sor_order_place() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": SorOrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": SorOrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": SorOrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "id": "3a4437e2-41a3-4c19-897c-9cadc5dce8b6",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 2,
                    "orderListId": -1,
                    "clientOrderId": "sBI1KM6nNtOfj5tccZSKly",
                    "transactTime": 1689149087774,
                    "price": "31000.00000000",
                    "origQty": "0.50000000",
                    "executedQty": "0.50000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "14000.00000000",
                    "status": "FILLED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "BUY",
                    "workingTime": 1689149087774,
                    "fills": [
                        {
                            "matchType": "ONE_PARTY_TRADE_REPORT",
                            "price": "28000.00000000",
                            "qty": "0.50000000",
                            "commission": "0.00000000",
                            "commissionAsset": "BTC",
                            "tradeId": -1,
                            "allocId": 0,
                        }
                    ],
                    "workingFloor": "SOR",
                    "selfTradePreventionMode": "NONE",
                    "usedSor": True,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.sor_order_place(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/sor.order.place".replace(
            "/", ""
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["side"] == SorOrderPlaceSideEnum["BUY"].value
        assert params["type"] == SorOrderPlaceTypeEnum["MARKET"].value
        assert params["quantity"] == 1.0
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["time_in_force"] == SorOrderPlaceTimeInForceEnum["GTC"].value
        assert params["price"] == 1.0
        assert params["new_client_order_id"] == "new_client_order_id_example"
        assert (
            params["new_order_resp_type"]
            == SorOrderPlaceNewOrderRespTypeEnum["ACK"].value
        )
        assert params["iceberg_qty"] == 1.0
        assert params["strategy_id"] == 1
        assert params["strategy_type"] == 1
        assert (
            params["self_trade_prevention_mode"]
            == SorOrderPlaceSelfTradePreventionModeEnum["NONE"].value
        )
        assert params["recv_window"] == 5000

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/sor.order.place".replace("/", ""), "params": params},
            response_model=SorOrderPlaceResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_sor_order_place_missing_required_param_symbol(self):
        """Test that sor_order_place() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": SorOrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": SorOrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": SorOrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.sor_order_place(**params)

    @pytest.mark.asyncio
    async def test_sor_order_place_missing_required_param_side(self):
        """Test that sor_order_place() raises RequiredError when 'side' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": SorOrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": SorOrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": SorOrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            await self.websocket_api.sor_order_place(**params)

    @pytest.mark.asyncio
    async def test_sor_order_place_missing_required_param_type(self):
        """Test that sor_order_place() raises RequiredError when 'type' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": SorOrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": SorOrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": SorOrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["type"]

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            await self.websocket_api.sor_order_place(**params)

    @pytest.mark.asyncio
    async def test_sor_order_place_missing_required_param_quantity(self):
        """Test that sor_order_place() raises RequiredError when 'quantity' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
            "id": "e9d6b4349871b40611412680b3445fac",
            "time_in_force": SorOrderPlaceTimeInForceEnum["GTC"].value,
            "price": 1.0,
            "new_client_order_id": "new_client_order_id_example",
            "new_order_resp_type": SorOrderPlaceNewOrderRespTypeEnum["ACK"].value,
            "iceberg_qty": 1.0,
            "strategy_id": 1,
            "strategy_type": 1,
            "self_trade_prevention_mode": SorOrderPlaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }
        del params["quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            await self.websocket_api.sor_order_place(**params)

    @pytest.mark.asyncio
    async def test_sor_order_place_server_error(self):
        """Test that sor_order_place() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderPlaceSideEnum["BUY"].value,
            "type": SorOrderPlaceTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.sor_order_place(**params)

    @pytest.mark.asyncio
    async def test_sor_order_test_success(self):
        """Test sor_order_test() successfully with required parameters only."""

        expected_response = {
            "id": "3a4437e2-41a3-4c19-897c-9cadc5dce8b6",
            "status": 200,
            "result": {
                "standardCommissionForOrder": {
                    "maker": "0.00000112",
                    "taker": "0.00000114",
                },
                "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
                "discount": {
                    "enabledForAccount": True,
                    "enabledForSymbol": True,
                    "discountAsset": "BNB",
                    "discount": "0.25",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.sor_order_test()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/sor.order.test".replace("/", "")

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/sor.order.test".replace("/", ""), "params": {}},
            response_model=SorOrderTestResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_sor_order_test_success_with_optional_params(self):
        """Test sor_order_test() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "compute_commission_rates": False,
        }

        expected_response = {
            "id": "3a4437e2-41a3-4c19-897c-9cadc5dce8b6",
            "status": 200,
            "result": {
                "standardCommissionForOrder": {
                    "maker": "0.00000112",
                    "taker": "0.00000114",
                },
                "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
                "discount": {
                    "enabledForAccount": True,
                    "enabledForSymbol": True,
                    "discountAsset": "BNB",
                    "discount": "0.25",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 1,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.sor_order_test(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/sor.order.test".replace("/", "")
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["compute_commission_rates"] is False

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/sor.order.test".replace("/", ""), "params": params},
            response_model=SorOrderTestResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_sor_order_test_server_error(self):
        """Test that sor_order_test() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.sor_order_test()
