"""
Binance Spot WebSocket API

OpenAPI Specifications for the Binance Spot WebSocket API

API documents:
  - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
  - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest

from unittest.mock import AsyncMock, MagicMock

from binance_common.models import WebsocketApiResponse
from binance_common.utils import parse_ws_rate_limit_headers
from binance_common.errors import RequiredError
from binance_sdk_spot.websocket_api.api import AccountApi


from binance_sdk_spot.websocket_api.models import AccountCommissionResponse
from binance_sdk_spot.websocket_api.models import AccountRateLimitsOrdersResponse
from binance_sdk_spot.websocket_api.models import AccountStatusResponse
from binance_sdk_spot.websocket_api.models import AllOrderListsResponse
from binance_sdk_spot.websocket_api.models import AllOrdersResponse
from binance_sdk_spot.websocket_api.models import MyAllocationsResponse
from binance_sdk_spot.websocket_api.models import MyPreventedMatchesResponse
from binance_sdk_spot.websocket_api.models import MyTradesResponse
from binance_sdk_spot.websocket_api.models import OpenOrderListsStatusResponse
from binance_sdk_spot.websocket_api.models import OpenOrdersStatusResponse
from binance_sdk_spot.websocket_api.models import OrderAmendmentsResponse
from binance_sdk_spot.websocket_api.models import OrderListStatusResponse
from binance_sdk_spot.websocket_api.models import OrderStatusResponse


class TestWebSocketAccountApi:
    @pytest.fixture(autouse=True)
    def setup_method(self):
        self.mock_websocket_api = MagicMock()
        self.websocket_api = AccountApi(websocket_api=self.mock_websocket_api)

    @pytest.mark.asyncio
    async def test_account_commission_success(self):
        """Test account_commission() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "d3df8a61-98ea-4fe0-8f4e-0fcea5d418b0",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "standardCommission": {
                    "maker": "0.00000010",
                    "taker": "0.00000020",
                    "buyer": "0.00000030",
                    "seller": "0.00000040",
                },
                "specialCommission": {
                    "maker": "0.01000000",
                    "taker": "0.02000000",
                    "buyer": "0.03000000",
                    "seller": "0.04000000",
                },
                "taxCommission": {
                    "maker": "0.00000112",
                    "taker": "0.00000114",
                    "buyer": "0.00000118",
                    "seller": "0.00000116",
                },
                "discount": {
                    "enabledForAccount": True,
                    "enabledForSymbol": True,
                    "discountAsset": "BNB",
                    "discount": "0.75000000",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.account_commission(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/account.commission".replace(
            "/", "", 1
        )

        assert "params" in request_kwargs["payload"]
        params = request_kwargs["payload"]["params"]
        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/account.commission".replace("/", "", 1),
                "params": params,
            },
            response_model=AccountCommissionResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_account_commission_success_with_optional_params(self):
        """Test account_commission() successfully with optional parameters."""

        params = {"symbol": "BNBUSDT", "id": "e9d6b4349871b40611412680b3445fac"}

        expected_response = {
            "id": "d3df8a61-98ea-4fe0-8f4e-0fcea5d418b0",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "standardCommission": {
                    "maker": "0.00000010",
                    "taker": "0.00000020",
                    "buyer": "0.00000030",
                    "seller": "0.00000040",
                },
                "specialCommission": {
                    "maker": "0.01000000",
                    "taker": "0.02000000",
                    "buyer": "0.03000000",
                    "seller": "0.04000000",
                },
                "taxCommission": {
                    "maker": "0.00000112",
                    "taker": "0.00000114",
                    "buyer": "0.00000118",
                    "seller": "0.00000116",
                },
                "discount": {
                    "enabledForAccount": True,
                    "enabledForSymbol": True,
                    "discountAsset": "BNB",
                    "discount": "0.75000000",
                },
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.account_commission(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/account.commission".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/account.commission".replace("/", "", 1),
                "params": params,
            },
            response_model=AccountCommissionResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_account_commission_missing_required_param_symbol(self):
        """Test that account_commission() raises RequiredError when 'symbol' is missing."""

        params = {"symbol": "BNBUSDT", "id": "e9d6b4349871b40611412680b3445fac"}
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.account_commission(**params)

    @pytest.mark.asyncio
    async def test_account_commission_server_error(self):
        """Test that account_commission() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.account_commission(**params)

    @pytest.mark.asyncio
    async def test_account_rate_limits_orders_success(self):
        """Test account_rate_limits_orders() successfully with required parameters only."""

        expected_response = {
            "id": "d3783d8d-f8d1-4d2c-b8a0-b7596af5a664",
            "status": 200,
            "result": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 0,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 0,
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 40,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.account_rate_limits_orders()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"][
            "method"
        ] == "/account.rateLimits.orders".replace("/", "", 1)

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/account.rateLimits.orders".replace("/", "", 1),
                "params": {},
            },
            response_model=AccountRateLimitsOrdersResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_account_rate_limits_orders_success_with_optional_params(self):
        """Test account_rate_limits_orders() successfully with optional parameters."""

        params = {"id": "e9d6b4349871b40611412680b3445fac", "recv_window": 5000.0}

        expected_response = {
            "id": "d3783d8d-f8d1-4d2c-b8a0-b7596af5a664",
            "status": 200,
            "result": [
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                    "count": 0,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "SECOND",
                    "intervalNum": 10,
                    "limit": 50,
                    "count": 0,
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 40,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.account_rate_limits_orders(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"][
            "method"
        ] == "/account.rateLimits.orders".replace("/", "", 1)
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/account.rateLimits.orders".replace("/", "", 1),
                "params": params,
            },
            response_model=AccountRateLimitsOrdersResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_account_rate_limits_orders_server_error(self):
        """Test that account_rate_limits_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.account_rate_limits_orders()

    @pytest.mark.asyncio
    async def test_account_status_success(self):
        """Test account_status() successfully with required parameters only."""

        expected_response = {
            "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
            "status": 200,
            "result": {
                "makerCommission": 15,
                "takerCommission": 15,
                "buyerCommission": 0,
                "sellerCommission": 0,
                "canTrade": True,
                "canWithdraw": True,
                "canDeposit": True,
                "commissionRates": {
                    "maker": "0.00150000",
                    "taker": "0.00150000",
                    "buyer": "0.00000000",
                    "seller": "0.00000000",
                },
                "brokered": False,
                "requireSelfTradePrevention": False,
                "preventSor": False,
                "updateTime": 1660801833000,
                "accountType": "SPOT",
                "balances": [
                    {"asset": "USDT", "free": "1021.21000000", "locked": "0.00000000"},
                    {"asset": "BTC", "free": "1.3447112", "locked": "0.08600000"},
                    {"asset": "BNB", "free": "0.00000000", "locked": "0.00000000"},
                ],
                "permissions": ["SPOT"],
                "uid": 354937868,
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.account_status()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/account.status".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/account.status".replace("/", "", 1), "params": {}},
            response_model=AccountStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_account_status_success_with_optional_params(self):
        """Test account_status() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "omit_zero_balances": False,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
            "status": 200,
            "result": {
                "makerCommission": 15,
                "takerCommission": 15,
                "buyerCommission": 0,
                "sellerCommission": 0,
                "canTrade": True,
                "canWithdraw": True,
                "canDeposit": True,
                "commissionRates": {
                    "maker": "0.00150000",
                    "taker": "0.00150000",
                    "buyer": "0.00000000",
                    "seller": "0.00000000",
                },
                "brokered": False,
                "requireSelfTradePrevention": False,
                "preventSor": False,
                "updateTime": 1660801833000,
                "accountType": "SPOT",
                "balances": [
                    {"asset": "USDT", "free": "1021.21000000", "locked": "0.00000000"},
                    {"asset": "BTC", "free": "1.3447112", "locked": "0.08600000"},
                    {"asset": "BNB", "free": "0.00000000", "locked": "0.00000000"},
                ],
                "permissions": ["SPOT"],
                "uid": 354937868,
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.account_status(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/account.status".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["omit_zero_balances"] is False
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/account.status".replace("/", "", 1), "params": params},
            response_model=AccountStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_account_status_server_error(self):
        """Test that account_status() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.account_status()

    @pytest.mark.asyncio
    async def test_all_order_lists_success(self):
        """Test all_order_lists() successfully with required parameters only."""

        expected_response = {
            "id": "8617b7b3-1b3d-4dec-94cd-eefd929b8ceb",
            "status": 200,
            "result": [
                {
                    "orderListId": 1274512,
                    "contingencyType": "OCO",
                    "listStatusType": "EXEC_STARTED",
                    "listOrderStatus": "EXECUTING",
                    "listClientOrderId": "08985fedd9ea2cf6b28996",
                    "transactionTime": 1660801713793,
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569138902,
                            "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569138901,
                            "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                        },
                    ],
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.all_order_lists()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/allOrderLists".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/allOrderLists".replace("/", "", 1), "params": {}},
            response_model=AllOrderListsResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_all_order_lists_success_with_optional_params(self):
        """Test all_order_lists() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 100,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "8617b7b3-1b3d-4dec-94cd-eefd929b8ceb",
            "status": 200,
            "result": [
                {
                    "orderListId": 1274512,
                    "contingencyType": "OCO",
                    "listStatusType": "EXEC_STARTED",
                    "listOrderStatus": "EXECUTING",
                    "listClientOrderId": "08985fedd9ea2cf6b28996",
                    "transactionTime": 1660801713793,
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569138902,
                            "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 12569138901,
                            "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                        },
                    ],
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.all_order_lists(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/allOrderLists".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["from_id"] == 1
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["limit"] == 100
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/allOrderLists".replace("/", "", 1), "params": params},
            response_model=AllOrderListsResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_all_order_lists_server_error(self):
        """Test that all_order_lists() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.all_order_lists()

    @pytest.mark.asyncio
    async def test_all_orders_success(self):
        """Test all_orders() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "734235c2-13d2-4574-be68-723e818c08f3",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "4d96324ff9d44481926157",
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00847000",
                    "cummulativeQuoteQty": "198.33521500",
                    "status": "FILLED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "stopPrice": "0.00000000",
                    "icebergQty": "0.00000000",
                    "time": 1660801715639,
                    "updateTime": 1660801717945,
                    "isWorking": True,
                    "workingTime": 1660801715639,
                    "origQuoteOrderQty": "0.00000000",
                    "selfTradePreventionMode": "NONE",
                    "preventedMatchId": 0,
                    "preventedQuantity": "1.200000",
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.all_orders(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/allOrders".replace("/", "", 1)

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/allOrders".replace("/", "", 1), "params": params},
            response_model=AllOrdersResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_all_orders_success_with_optional_params(self):
        """Test all_orders() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 100,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "734235c2-13d2-4574-be68-723e818c08f3",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "4d96324ff9d44481926157",
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00847000",
                    "cummulativeQuoteQty": "198.33521500",
                    "status": "FILLED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "stopPrice": "0.00000000",
                    "icebergQty": "0.00000000",
                    "time": 1660801715639,
                    "updateTime": 1660801717945,
                    "isWorking": True,
                    "workingTime": 1660801715639,
                    "origQuoteOrderQty": "0.00000000",
                    "selfTradePreventionMode": "NONE",
                    "preventedMatchId": 0,
                    "preventedQuantity": "1.200000",
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.all_orders(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/allOrders".replace("/", "", 1)
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["order_id"] == 1
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["limit"] == 100
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/allOrders".replace("/", "", 1), "params": params},
            response_model=AllOrdersResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_all_orders_missing_required_param_symbol(self):
        """Test that all_orders() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 100,
            "recv_window": 5000.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.all_orders(**params)

    @pytest.mark.asyncio
    async def test_all_orders_server_error(self):
        """Test that all_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.all_orders(**params)

    @pytest.mark.asyncio
    async def test_my_allocations_success(self):
        """Test my_allocations() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "g4ce6a53-a39d-4f71-823b-4ab5r391d6y8",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "allocationId": 0,
                    "allocationType": "SOR",
                    "orderId": 500,
                    "orderListId": -1,
                    "price": "1.00000000",
                    "qty": "0.10000000",
                    "quoteQty": "0.10000000",
                    "commission": "0.00000000",
                    "commissionAsset": "BTC",
                    "time": 1687319487614,
                    "isBuyer": False,
                    "isMaker": False,
                    "isAllocator": False,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.my_allocations(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/myAllocations".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/myAllocations".replace("/", "", 1), "params": params},
            response_model=MyAllocationsResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_my_allocations_success_with_optional_params(self):
        """Test my_allocations() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "from_allocation_id": 1,
            "limit": 100,
            "order_id": 1,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "g4ce6a53-a39d-4f71-823b-4ab5r391d6y8",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "allocationId": 0,
                    "allocationType": "SOR",
                    "orderId": 500,
                    "orderListId": -1,
                    "price": "1.00000000",
                    "qty": "0.10000000",
                    "quoteQty": "0.10000000",
                    "commission": "0.00000000",
                    "commissionAsset": "BTC",
                    "time": 1687319487614,
                    "isBuyer": False,
                    "isMaker": False,
                    "isAllocator": False,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.my_allocations(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/myAllocations".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["from_allocation_id"] == 1
        assert params["limit"] == 100
        assert params["order_id"] == 1
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/myAllocations".replace("/", "", 1), "params": params},
            response_model=MyAllocationsResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_my_allocations_missing_required_param_symbol(self):
        """Test that my_allocations() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "from_allocation_id": 1,
            "limit": 100,
            "order_id": 1,
            "recv_window": 5000.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.my_allocations(**params)

    @pytest.mark.asyncio
    async def test_my_allocations_server_error(self):
        """Test that my_allocations() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.my_allocations(**params)

    @pytest.mark.asyncio
    async def test_my_prevented_matches_success(self):
        """Test my_prevented_matches() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "g4ce6a53-a39d-4f71-823b-4ab5r391d6y8",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "preventedMatchId": 1,
                    "takerOrderId": 5,
                    "makerSymbol": "BTCUSDT",
                    "makerOrderId": 3,
                    "tradeGroupId": 1,
                    "selfTradePreventionMode": "EXPIRE_MAKER",
                    "price": "1.100000",
                    "makerPreventedQuantity": "1.300000",
                    "transactTime": 1669101687094,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.my_prevented_matches(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/myPreventedMatches".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/myPreventedMatches".replace("/", "", 1),
                "params": params,
            },
            response_model=MyPreventedMatchesResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_my_prevented_matches_success_with_optional_params(self):
        """Test my_prevented_matches() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "prevented_match_id": 1,
            "order_id": 1,
            "from_prevented_match_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "g4ce6a53-a39d-4f71-823b-4ab5r391d6y8",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "preventedMatchId": 1,
                    "takerOrderId": 5,
                    "makerSymbol": "BTCUSDT",
                    "makerOrderId": 3,
                    "tradeGroupId": 1,
                    "selfTradePreventionMode": "EXPIRE_MAKER",
                    "price": "1.100000",
                    "makerPreventedQuantity": "1.300000",
                    "transactTime": 1669101687094,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.my_prevented_matches(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/myPreventedMatches".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["prevented_match_id"] == 1
        assert params["order_id"] == 1
        assert params["from_prevented_match_id"] == 1
        assert params["limit"] == 100
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/myPreventedMatches".replace("/", "", 1),
                "params": params,
            },
            response_model=MyPreventedMatchesResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_my_prevented_matches_missing_required_param_symbol(self):
        """Test that my_prevented_matches() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "prevented_match_id": 1,
            "order_id": 1,
            "from_prevented_match_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.my_prevented_matches(**params)

    @pytest.mark.asyncio
    async def test_my_prevented_matches_server_error(self):
        """Test that my_prevented_matches() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.my_prevented_matches(**params)

    @pytest.mark.asyncio
    async def test_my_trades_success(self):
        """Test my_trades() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "id": 1650422482,
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "price": "23416.50000000",
                    "qty": "0.00212000",
                    "quoteQty": "49.64298000",
                    "commission": "0.00000000",
                    "commissionAsset": "BNB",
                    "time": 1660801715793,
                    "isBuyer": False,
                    "isMaker": True,
                    "isBestMatch": True,
                },
                {
                    "symbol": "BTCUSDT",
                    "id": 1650422481,
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "price": "23416.10000000",
                    "qty": "0.00635000",
                    "quoteQty": "148.69223500",
                    "commission": "0.00000000",
                    "commissionAsset": "BNB",
                    "time": 1660801715793,
                    "isBuyer": False,
                    "isMaker": True,
                    "isBestMatch": True,
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.my_trades(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/myTrades".replace("/", "", 1)

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/myTrades".replace("/", "", 1), "params": params},
            response_model=MyTradesResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_my_trades_success_with_optional_params(self):
        """Test my_trades() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "f4ce6a53-a29d-4f70-823b-4ab59391d6e8",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "id": 1650422482,
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "price": "23416.50000000",
                    "qty": "0.00212000",
                    "quoteQty": "49.64298000",
                    "commission": "0.00000000",
                    "commissionAsset": "BNB",
                    "time": 1660801715793,
                    "isBuyer": False,
                    "isMaker": True,
                    "isBestMatch": True,
                },
                {
                    "symbol": "BTCUSDT",
                    "id": 1650422481,
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "price": "23416.10000000",
                    "qty": "0.00635000",
                    "quoteQty": "148.69223500",
                    "commission": "0.00000000",
                    "commissionAsset": "BNB",
                    "time": 1660801715793,
                    "isBuyer": False,
                    "isMaker": True,
                    "isBestMatch": True,
                },
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 20,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.my_trades(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/myTrades".replace("/", "", 1)
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["order_id"] == 1
        assert params["start_time"] == 1735693200000
        assert params["end_time"] == 1735693200000
        assert params["from_id"] == 1
        assert params["limit"] == 100
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/myTrades".replace("/", "", 1), "params": params},
            response_model=MyTradesResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_my_trades_missing_required_param_symbol(self):
        """Test that my_trades() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.my_trades(**params)

    @pytest.mark.asyncio
    async def test_my_trades_server_error(self):
        """Test that my_trades() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.my_trades(**params)

    @pytest.mark.asyncio
    async def test_open_order_lists_status_success(self):
        """Test open_order_lists_status() successfully with required parameters only."""

        expected_response = {
            "id": "3a4437e2-41a3-4c19-897c-9cadc5dce8b6",
            "status": 200,
            "result": [
                {
                    "orderListId": 0,
                    "contingencyType": "OCO",
                    "listStatusType": "EXEC_STARTED",
                    "listOrderStatus": "EXECUTING",
                    "listClientOrderId": "08985fedd9ea2cf6b28996",
                    "transactionTime": 1660801713793,
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 5,
                            "clientOrderId": "1ZqG7bBuYwaF4SU8CwnwHm",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 4,
                            "clientOrderId": "CUhLgTXnX5n2c0gWiLpV4d",
                        },
                    ],
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 6,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.open_order_lists_status()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/openOrderLists.status".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/openOrderLists.status".replace("/", "", 1),
                "params": {},
            },
            response_model=OpenOrderListsStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_open_order_lists_status_success_with_optional_params(self):
        """Test open_order_lists_status() successfully with optional parameters."""

        params = {"id": "e9d6b4349871b40611412680b3445fac", "recv_window": 5000.0}

        expected_response = {
            "id": "3a4437e2-41a3-4c19-897c-9cadc5dce8b6",
            "status": 200,
            "result": [
                {
                    "orderListId": 0,
                    "contingencyType": "OCO",
                    "listStatusType": "EXEC_STARTED",
                    "listOrderStatus": "EXECUTING",
                    "listClientOrderId": "08985fedd9ea2cf6b28996",
                    "transactionTime": 1660801713793,
                    "symbol": "BTCUSDT",
                    "orders": [
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 5,
                            "clientOrderId": "1ZqG7bBuYwaF4SU8CwnwHm",
                        },
                        {
                            "symbol": "BTCUSDT",
                            "orderId": 4,
                            "clientOrderId": "CUhLgTXnX5n2c0gWiLpV4d",
                        },
                    ],
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 6,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.open_order_lists_status(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/openOrderLists.status".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/openOrderLists.status".replace("/", "", 1),
                "params": params,
            },
            response_model=OpenOrderListsStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_open_order_lists_status_server_error(self):
        """Test that open_order_lists_status() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.open_order_lists_status()

    @pytest.mark.asyncio
    async def test_open_orders_status_success(self):
        """Test open_orders_status() successfully with required parameters only."""

        expected_response = {
            "id": "55f07876-4f6f-4c47-87dc-43e5fff3f2e7",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "4d96324ff9d44481926157",
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00720000",
                    "origQuoteOrderQty": "0.00000000",
                    "cummulativeQuoteQty": "172.43931000",
                    "status": "PARTIALLY_FILLED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "stopPrice": "0.00000000",
                    "icebergQty": "0.00000000",
                    "time": 1660801715639,
                    "updateTime": 1660801717945,
                    "isWorking": True,
                    "workingTime": 1660801715639,
                    "selfTradePreventionMode": "NONE",
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 6,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.open_orders_status()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/openOrders.status".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/openOrders.status".replace("/", "", 1), "params": {}},
            response_model=OpenOrdersStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_open_orders_status_success_with_optional_params(self):
        """Test open_orders_status() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "symbol": "BNBUSDT",
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "55f07876-4f6f-4c47-87dc-43e5fff3f2e7",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 12569099453,
                    "orderListId": -1,
                    "clientOrderId": "4d96324ff9d44481926157",
                    "price": "23416.10000000",
                    "origQty": "0.00847000",
                    "executedQty": "0.00720000",
                    "origQuoteOrderQty": "0.00000000",
                    "cummulativeQuoteQty": "172.43931000",
                    "status": "PARTIALLY_FILLED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "stopPrice": "0.00000000",
                    "icebergQty": "0.00000000",
                    "time": 1660801715639,
                    "updateTime": 1660801717945,
                    "isWorking": True,
                    "workingTime": 1660801715639,
                    "selfTradePreventionMode": "NONE",
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 6,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.open_orders_status(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/openOrders.status".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["symbol"] == "BNBUSDT"
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/openOrders.status".replace("/", "", 1),
                "params": params,
            },
            response_model=OpenOrdersStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_open_orders_status_server_error(self):
        """Test that open_orders_status() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.open_orders_status()

    @pytest.mark.asyncio
    async def test_order_amendments_success(self):
        """Test order_amendments() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
        }

        expected_response = {
            "id": "6f5ebe91-01d9-43ac-be99-57cf062e0e30",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 23,
                    "executionId": 60,
                    "origClientOrderId": "my_pending_order",
                    "newClientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                    "origQty": "7.00000000",
                    "newQty": "5.00000000",
                    "time": 1741924229819,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_amendments(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.amendments".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert params["order_id"] == 1

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/order.amendments".replace("/", "", 1),
                "params": params,
            },
            response_model=OrderAmendmentsResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_amendments_success_with_optional_params(self):
        """Test order_amendments() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_execution_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "6f5ebe91-01d9-43ac-be99-57cf062e0e30",
            "status": 200,
            "result": [
                {
                    "symbol": "BTCUSDT",
                    "orderId": 23,
                    "executionId": 60,
                    "origClientOrderId": "my_pending_order",
                    "newClientOrderId": "xbxXh5SSwaHS7oUEOCI88B",
                    "origQty": "7.00000000",
                    "newQty": "5.00000000",
                    "time": 1741924229819,
                }
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_amendments(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.amendments".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["order_id"] == 1
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["from_execution_id"] == 1
        assert params["limit"] == 100
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/order.amendments".replace("/", "", 1),
                "params": params,
            },
            response_model=OrderAmendmentsResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_amendments_missing_required_param_symbol(self):
        """Test that order_amendments() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_execution_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_amendments(**params)

    @pytest.mark.asyncio
    async def test_order_amendments_missing_required_param_order_id(self):
        """Test that order_amendments() raises RequiredError when 'order_id' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "id": "e9d6b4349871b40611412680b3445fac",
            "from_execution_id": 1,
            "limit": 100,
            "recv_window": 5000.0,
        }
        params["order_id"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'order_id'"
        ):
            await self.websocket_api.order_amendments(**params)

    @pytest.mark.asyncio
    async def test_order_amendments_server_error(self):
        """Test that order_amendments() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_amendments(**params)

    @pytest.mark.asyncio
    async def test_order_list_status_success(self):
        """Test order_list_status() successfully with required parameters only."""

        expected_response = {
            "id": "b53fd5ff-82c7-4a04-bd64-5f9dc42c2100",
            "status": 200,
            "result": {
                "orderListId": 1274512,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "08985fedd9ea2cf6b28996",
                "transactionTime": 1660801713793,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_list_status()

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.status".replace(
            "/", "", 1
        )

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/orderList.status".replace("/", "", 1), "params": {}},
            response_model=OrderListStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_status_success_with_optional_params(self):
        """Test order_list_status() successfully with optional parameters."""

        params = {
            "id": "e9d6b4349871b40611412680b3445fac",
            "orig_client_order_id": "orig_client_order_id_example",
            "order_list_id": 1,
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "b53fd5ff-82c7-4a04-bd64-5f9dc42c2100",
            "status": 200,
            "result": {
                "orderListId": 1274512,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "08985fedd9ea2cf6b28996",
                "transactionTime": 1660801713793,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138902,
                        "clientOrderId": "jLnZpj5enfMXTuhKB1d0us",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 12569138901,
                        "clientOrderId": "BqtFCj5odMoWtSqGk2X9tU",
                    },
                ],
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_list_status(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/orderList.status".replace(
            "/", "", 1
        )
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["orig_client_order_id"] == "orig_client_order_id_example"
        assert params["order_list_id"] == 1
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={
                "method": "/orderList.status".replace("/", "", 1),
                "params": params,
            },
            response_model=OrderListStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_list_status_server_error(self):
        """Test that order_list_status() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_list_status()

    @pytest.mark.asyncio
    async def test_order_status_success(self):
        """Test order_status() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "id": "aa62318a-5a97-4f3b-bdc7-640bbe33b291",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "orderId": 12569099453,
                "orderListId": -1,
                "clientOrderId": "4d96324ff9d44481926157",
                "price": "23416.10000000",
                "origQty": "0.00847000",
                "executedQty": "0.00847000",
                "cummulativeQuoteQty": "198.33521500",
                "status": "FILLED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "stopPrice": "0.00000000",
                "trailingDelta": 10,
                "trailingTime": -1,
                "icebergQty": "0.00000000",
                "time": 1660801715639,
                "updateTime": 1660801717945,
                "isWorking": True,
                "workingTime": 1660801715639,
                "origQuoteOrderQty": "0.00000000",
                "strategyId": 37463720,
                "strategyType": 1000000,
                "selfTradePreventionMode": "NONE",
                "preventedMatchId": 0,
                "preventedQuantity": "1.200000",
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )
        result = await self.websocket_api.order_status(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.status".replace(
            "/", "", 1
        )

        assert params["symbol"] == "BNBUSDT"

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.status".replace("/", "", 1), "params": params},
            response_model=OrderStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_status_success_with_optional_params(self):
        """Test order_status() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "recv_window": 5000.0,
        }

        expected_response = {
            "id": "aa62318a-5a97-4f3b-bdc7-640bbe33b291",
            "status": 200,
            "result": {
                "symbol": "BTCUSDT",
                "orderId": 12569099453,
                "orderListId": -1,
                "clientOrderId": "4d96324ff9d44481926157",
                "price": "23416.10000000",
                "origQty": "0.00847000",
                "executedQty": "0.00847000",
                "cummulativeQuoteQty": "198.33521500",
                "status": "FILLED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "stopPrice": "0.00000000",
                "trailingDelta": 10,
                "trailingTime": -1,
                "icebergQty": "0.00000000",
                "time": 1660801715639,
                "updateTime": 1660801717945,
                "isWorking": True,
                "workingTime": 1660801715639,
                "origQuoteOrderQty": "0.00000000",
                "strategyId": 37463720,
                "strategyType": 1000000,
                "selfTradePreventionMode": "NONE",
                "preventedMatchId": 0,
                "preventedQuantity": "1.200000",
            },
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "count": 4,
                }
            ],
        }

        self.mock_websocket_api.send_signed_message = AsyncMock(
            return_value=WebsocketApiResponse(
                data_function=lambda: expected_response,
                rate_limits=(
                    parse_ws_rate_limit_headers(expected_response["rateLimits"])
                    if "rateLimits" in expected_response
                    else None
                ),
            )
        )

        result = await self.websocket_api.order_status(**params)

        actual_call_args = self.mock_websocket_api.send_signed_message.call_args
        request_kwargs = actual_call_args.kwargs

        assert "payload" in request_kwargs
        assert "method" in request_kwargs["payload"]
        assert request_kwargs["payload"]["method"] == "/order.status".replace(
            "/", "", 1
        )
        assert params["symbol"] == "BNBUSDT"
        assert params["id"] == "e9d6b4349871b40611412680b3445fac"
        assert params["order_id"] == 1
        assert params["orig_client_order_id"] == "orig_client_order_id_example"
        assert params["recv_window"] == 5000.0

        assert result is not None
        assert result.data() == expected_response
        self.mock_websocket_api.send_signed_message.assert_called_once_with(
            payload={"method": "/order.status".replace("/", "", 1), "params": params},
            response_model=OrderStatusResponse,
            signer=None,
        )

    @pytest.mark.asyncio
    async def test_order_status_missing_required_param_symbol(self):
        """Test that order_status() raises RequiredError when 'symbol' is missing."""

        params = {
            "symbol": "BNBUSDT",
            "id": "e9d6b4349871b40611412680b3445fac",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "recv_window": 5000.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.websocket_api.order_status(**params)

    @pytest.mark.asyncio
    async def test_order_status_server_error(self):
        """Test that order_status() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.mock_websocket_api.send_signed_message.side_effect = mock_error

        with pytest.raises(Exception, match="ResponseError"):
            await self.websocket_api.order_status(**params)
