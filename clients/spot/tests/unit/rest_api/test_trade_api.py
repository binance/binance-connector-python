"""
Binance Spot REST API

OpenAPI Specifications for the Binance Spot REST API

API documents:
  - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
  - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_spot.rest_api.api import TradeApi
from binance_sdk_spot.rest_api.models import DeleteOpenOrdersResponse
from binance_sdk_spot.rest_api.models import DeleteOrderResponse
from binance_sdk_spot.rest_api.models import DeleteOrderListResponse
from binance_sdk_spot.rest_api.models import NewOrderResponse
from binance_sdk_spot.rest_api.models import OrderAmendKeepPriorityResponse
from binance_sdk_spot.rest_api.models import OrderCancelReplaceResponse
from binance_sdk_spot.rest_api.models import OrderListOcoResponse
from binance_sdk_spot.rest_api.models import OrderListOtoResponse
from binance_sdk_spot.rest_api.models import OrderListOtocoResponse
from binance_sdk_spot.rest_api.models import OrderOcoResponse
from binance_sdk_spot.rest_api.models import OrderTestResponse
from binance_sdk_spot.rest_api.models import SorOrderResponse
from binance_sdk_spot.rest_api.models import SorOrderTestResponse


from binance_sdk_spot.rest_api.models import DeleteOrderCancelRestrictionsEnum
from binance_sdk_spot.rest_api.models import NewOrderSideEnum
from binance_sdk_spot.rest_api.models import NewOrderTypeEnum
from binance_sdk_spot.rest_api.models import NewOrderTimeInForceEnum
from binance_sdk_spot.rest_api.models import NewOrderNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import NewOrderSelfTradePreventionModeEnum
from binance_sdk_spot.rest_api.models import OrderCancelReplaceSideEnum
from binance_sdk_spot.rest_api.models import OrderCancelReplaceTypeEnum
from binance_sdk_spot.rest_api.models import OrderCancelReplaceCancelReplaceModeEnum
from binance_sdk_spot.rest_api.models import OrderCancelReplaceTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderCancelReplaceNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import (
    OrderCancelReplaceSelfTradePreventionModeEnum,
)
from binance_sdk_spot.rest_api.models import OrderCancelReplaceCancelRestrictionsEnum
from binance_sdk_spot.rest_api.models import (
    OrderCancelReplaceOrderRateLimitExceededModeEnum,
)
from binance_sdk_spot.rest_api.models import OrderListOcoSideEnum
from binance_sdk_spot.rest_api.models import OrderListOcoAboveTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOcoBelowTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOcoBelowTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderListOcoNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOcoSelfTradePreventionModeEnum
from binance_sdk_spot.rest_api.models import OrderListOtoWorkingTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtoWorkingSideEnum
from binance_sdk_spot.rest_api.models import OrderListOtoPendingTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtoPendingSideEnum
from binance_sdk_spot.rest_api.models import OrderListOtoNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtoSelfTradePreventionModeEnum
from binance_sdk_spot.rest_api.models import OrderListOtoWorkingTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderListOtoPendingTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoWorkingTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoWorkingSideEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoPendingSideEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoPendingAboveTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoSelfTradePreventionModeEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoWorkingTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoPendingAboveTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoPendingBelowTypeEnum
from binance_sdk_spot.rest_api.models import OrderListOtocoPendingBelowTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderOcoSideEnum
from binance_sdk_spot.rest_api.models import OrderOcoStopLimitTimeInForceEnum
from binance_sdk_spot.rest_api.models import OrderOcoNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import OrderOcoSelfTradePreventionModeEnum
from binance_sdk_spot.rest_api.models import SorOrderSideEnum
from binance_sdk_spot.rest_api.models import SorOrderTypeEnum
from binance_sdk_spot.rest_api.models import SorOrderTimeInForceEnum
from binance_sdk_spot.rest_api.models import SorOrderNewOrderRespTypeEnum
from binance_sdk_spot.rest_api.models import SorOrderSelfTradePreventionModeEnum


class TestTradeApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = TradeApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_delete_open_orders_success(self, mock_get_signature):
        """Test delete_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "origClientOrderId": "E6APeyTJvkMvLMYMqu1KQ4",
                "orderId": 11,
                "orderListId": -1,
                "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                "transactTime": 1684804350068,
                "price": "0.089853",
                "origQty": "0.178622",
                "executedQty": "0.000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "selfTradePreventionMode": "NONE",
            },
            {
                "symbol": "BTCUSDT",
                "origClientOrderId": "A3EF2HCwxgZPFMrfwbgrhv",
                "orderId": 13,
                "orderListId": -1,
                "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                "transactTime": 1684804350069,
                "price": "0.090430",
                "origQty": "0.178622",
                "executedQty": "0.000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "selfTradePreventionMode": "NONE",
            },
            {
                "orderListId": 1929,
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "2inzWQdDvZLHbbAmAozX2N",
                "transactionTime": 1585230948299,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 20,
                        "clientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 21,
                        "clientOrderId": "461cPg51vQjV3zIMOXNz39",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                        "orderId": 20,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "transactTime": 1688005070874,
                        "price": "0.668611",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "0.378131",
                        "icebergQty": "0.017083",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "461cPg51vQjV3zIMOXNz39",
                        "orderId": 21,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "transactTime": 1688005070874,
                        "price": "0.008791",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "icebergQty": "0.639962",
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.delete_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DeleteOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DeleteOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = DeleteOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_delete_open_orders_success_with_optional_params(self, mock_get_signature):
        """Test delete_open_orders() successfully with optional parameters."""

        params = {"symbol": "BNBUSDT", "recv_window": 5000}

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "origClientOrderId": "E6APeyTJvkMvLMYMqu1KQ4",
                "orderId": 11,
                "orderListId": -1,
                "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                "transactTime": 1684804350068,
                "price": "0.089853",
                "origQty": "0.178622",
                "executedQty": "0.000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "selfTradePreventionMode": "NONE",
            },
            {
                "symbol": "BTCUSDT",
                "origClientOrderId": "A3EF2HCwxgZPFMrfwbgrhv",
                "orderId": 13,
                "orderListId": -1,
                "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                "transactTime": 1684804350069,
                "price": "0.090430",
                "origQty": "0.178622",
                "executedQty": "0.000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "selfTradePreventionMode": "NONE",
            },
            {
                "orderListId": 1929,
                "contingencyType": "OCO",
                "listStatusType": "ALL_DONE",
                "listOrderStatus": "ALL_DONE",
                "listClientOrderId": "2inzWQdDvZLHbbAmAozX2N",
                "transactionTime": 1585230948299,
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 20,
                        "clientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 21,
                        "clientOrderId": "461cPg51vQjV3zIMOXNz39",
                    },
                ],
                "orderReports": [
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "CwOOIPHSmYywx6jZX77TdL",
                        "orderId": 20,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "transactTime": 1688005070874,
                        "price": "0.668611",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "STOP_LOSS_LIMIT",
                        "side": "BUY",
                        "stopPrice": "0.378131",
                        "icebergQty": "0.017083",
                        "selfTradePreventionMode": "NONE",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "origClientOrderId": "461cPg51vQjV3zIMOXNz39",
                        "orderId": 21,
                        "orderListId": 1929,
                        "clientOrderId": "pXLV6Hz6mprAcVYpVMTGgx",
                        "transactTime": 1688005070874,
                        "price": "0.008791",
                        "origQty": "0.690354",
                        "executedQty": "0.000000",
                        "origQuoteOrderQty": "0.000000",
                        "cummulativeQuoteQty": "0.000000",
                        "status": "CANCELED",
                        "timeInForce": "GTC",
                        "type": "LIMIT_MAKER",
                        "side": "BUY",
                        "icebergQty": "0.639962",
                        "selfTradePreventionMode": "NONE",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.delete_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DeleteOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DeleteOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = DeleteOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_delete_open_orders_missing_required_param_symbol(self):
        """Test that delete_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.delete_open_orders(**params)

    def test_delete_open_orders_server_error(self):
        """Test that delete_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.delete_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.delete_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_delete_order_success(self, mock_get_signature):
        """Test delete_order() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "symbol": "LTCBTC",
            "origClientOrderId": "myOrder1",
            "orderId": 4,
            "orderListId": -1,
            "clientOrderId": "cancelMyOrder1",
            "transactTime": 1684804350068,
            "price": "2.00000000",
            "origQty": "1.00000000",
            "executedQty": "0.00000000",
            "origQuoteOrderQty": "0.000000",
            "cummulativeQuoteQty": "0.00000000",
            "status": "CANCELED",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "BUY",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.delete_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DeleteOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DeleteOrderResponse.from_dict(expected_response)
        else:
            expected = DeleteOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_delete_order_success_with_optional_params(self, mock_get_signature):
        """Test delete_order() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "cancel_restrictions": DeleteOrderCancelRestrictionsEnum["ONLY_NEW"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "symbol": "LTCBTC",
            "origClientOrderId": "myOrder1",
            "orderId": 4,
            "orderListId": -1,
            "clientOrderId": "cancelMyOrder1",
            "transactTime": 1684804350068,
            "price": "2.00000000",
            "origQty": "1.00000000",
            "executedQty": "0.00000000",
            "origQuoteOrderQty": "0.000000",
            "cummulativeQuoteQty": "0.00000000",
            "status": "CANCELED",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "BUY",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.delete_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DeleteOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DeleteOrderResponse.from_dict(expected_response)
        else:
            expected = DeleteOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_delete_order_missing_required_param_symbol(self):
        """Test that delete_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.delete_order(**params)

    def test_delete_order_server_error(self):
        """Test that delete_order() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.delete_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.delete_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_delete_order_list_success(self, mock_get_signature):
        """Test delete_order_list() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "ALL_DONE",
            "listOrderStatus": "ALL_DONE",
            "listClientOrderId": "C3wyj4WVEktd7u9aVBRXcN",
            "transactionTime": 1574040868128,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "transactTime": 1688005070874,
                    "price": "3.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "transactTime": 1688005070874,
                    "price": "1.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "SELL",
                    "stopPrice": "1.00000000",
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.delete_order_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DeleteOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DeleteOrderListResponse.from_dict(expected_response)
        else:
            expected = DeleteOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_delete_order_list_success_with_optional_params(self, mock_get_signature):
        """Test delete_order_list() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_list_id": 1,
            "list_client_order_id": "list_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "ALL_DONE",
            "listOrderStatus": "ALL_DONE",
            "listClientOrderId": "C3wyj4WVEktd7u9aVBRXcN",
            "transactionTime": 1574040868128,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "TXOvglzXuaubXAaENpaRCB",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "TXOvglzXuaubXAaENpaRCB",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "transactTime": 1688005070874,
                    "price": "3.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "origClientOrderId": "pO9ufTiFGg3nw2fOdgeOXa",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "unfWT8ig8i0uj6lPuYLez6",
                    "transactTime": 1688005070874,
                    "price": "1.00000000",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "SELL",
                    "stopPrice": "1.00000000",
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.delete_order_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DeleteOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DeleteOrderListResponse.from_dict(expected_response)
        else:
            expected = DeleteOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_delete_order_list_missing_required_param_symbol(self):
        """Test that delete_order_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.delete_order_list(**params)

    def test_delete_order_list_server_error(self):
        """Test that delete_order_list() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.delete_order_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.delete_order_list(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_order_success(self, mock_get_signature):
        """Test new_order() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["MARKET"].value,
        }

        expected_response = {
            "symbol": "BTCUSDT",
            "orderId": 28,
            "orderListId": -1,
            "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
            "transactTime": 1507725176595,
            "price": "0.00000000",
            "origQty": "10.00000000",
            "executedQty": "10.00000000",
            "origQuoteOrderQty": "0.000000",
            "cummulativeQuoteQty": "10.00000000",
            "status": "FILLED",
            "timeInForce": "GTC",
            "type": "MARKET",
            "side": "SELL",
            "workingTime": 1507725176595,
            "selfTradePreventionMode": "NONE",
            "fills": [
                {
                    "price": "3995.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 60,
                },
                {
                    "price": "3997.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99700000",
                    "commissionAsset": "USDT",
                    "tradeId": 59,
                },
                {
                    "price": "3998.00000000",
                    "qty": "2.00000000",
                    "commission": "7.99600000",
                    "commissionAsset": "USDT",
                    "tradeId": 58,
                },
                {
                    "price": "3999.00000000",
                    "qty": "5.00000000",
                    "commission": "19.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 57,
                },
                {
                    "price": "4000.00000000",
                    "qty": "1.00000000",
                    "commission": "4.00000000",
                    "commissionAsset": "USDT",
                    "tradeId": 56,
                },
                {
                    "price": "3995.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 60,
                },
                {
                    "price": "3997.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99700000",
                    "commissionAsset": "USDT",
                    "tradeId": 59,
                },
                {
                    "price": "3998.00000000",
                    "qty": "2.00000000",
                    "commission": "7.99600000",
                    "commissionAsset": "USDT",
                    "tradeId": 58,
                },
                {
                    "price": "3999.00000000",
                    "qty": "5.00000000",
                    "commission": "19.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 57,
                },
                {
                    "price": "4000.00000000",
                    "qty": "1.00000000",
                    "commission": "4.00000000",
                    "commissionAsset": "USDT",
                    "tradeId": 56,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["side"] == NewOrderSideEnum["BUY"].value
        assert normalized["type"] == NewOrderTypeEnum["MARKET"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = NewOrderResponse.from_dict(expected_response)
        else:
            expected = NewOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_order_success_with_optional_params(self, mock_get_signature):
        """Test new_order() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["MARKET"].value,
            "time_in_force": NewOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "price": 400.0,
            "new_client_order_id": "new_client_order_id_example",
            "strategy_id": 1,
            "strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "iceberg_qty": 1.0,
            "new_order_resp_type": NewOrderNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": NewOrderSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "symbol": "BTCUSDT",
            "orderId": 28,
            "orderListId": -1,
            "clientOrderId": "6gCrw2kRUAF9CvJDGP16IP",
            "transactTime": 1507725176595,
            "price": "0.00000000",
            "origQty": "10.00000000",
            "executedQty": "10.00000000",
            "origQuoteOrderQty": "0.000000",
            "cummulativeQuoteQty": "10.00000000",
            "status": "FILLED",
            "timeInForce": "GTC",
            "type": "MARKET",
            "side": "SELL",
            "workingTime": 1507725176595,
            "selfTradePreventionMode": "NONE",
            "fills": [
                {
                    "price": "3995.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 60,
                },
                {
                    "price": "3997.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99700000",
                    "commissionAsset": "USDT",
                    "tradeId": 59,
                },
                {
                    "price": "3998.00000000",
                    "qty": "2.00000000",
                    "commission": "7.99600000",
                    "commissionAsset": "USDT",
                    "tradeId": 58,
                },
                {
                    "price": "3999.00000000",
                    "qty": "5.00000000",
                    "commission": "19.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 57,
                },
                {
                    "price": "4000.00000000",
                    "qty": "1.00000000",
                    "commission": "4.00000000",
                    "commissionAsset": "USDT",
                    "tradeId": 56,
                },
                {
                    "price": "3995.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 60,
                },
                {
                    "price": "3997.00000000",
                    "qty": "1.00000000",
                    "commission": "3.99700000",
                    "commissionAsset": "USDT",
                    "tradeId": 59,
                },
                {
                    "price": "3998.00000000",
                    "qty": "2.00000000",
                    "commission": "7.99600000",
                    "commissionAsset": "USDT",
                    "tradeId": 58,
                },
                {
                    "price": "3999.00000000",
                    "qty": "5.00000000",
                    "commission": "19.99500000",
                    "commissionAsset": "USDT",
                    "tradeId": 57,
                },
                {
                    "price": "4000.00000000",
                    "qty": "1.00000000",
                    "commission": "4.00000000",
                    "commissionAsset": "USDT",
                    "tradeId": 56,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = NewOrderResponse.from_dict(expected_response)
        else:
            expected = NewOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_order_missing_required_param_symbol(self):
        """Test that new_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["MARKET"].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_order(**params)

    def test_new_order_missing_required_param_side(self):
        """Test that new_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["MARKET"].value,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_order(**params)

    def test_new_order_missing_required_param_type(self):
        """Test that new_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["MARKET"].value,
        }
        del params["type"]

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_order(**params)

    def test_new_order_server_error(self):
        """Test that new_order() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["MARKET"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_amend_keep_priority_success(self, mock_get_signature):
        """Test order_amend_keep_priority() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
        }

        expected_response = {
            "transactTime": 1741669661670,
            "executionId": 22,
            "amendedOrder": {
                "symbol": "BTCUSDT",
                "orderId": 9,
                "orderListId": 1,
                "origClientOrderId": "W0fJ9fiLKHOJutovPK3oJp",
                "clientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                "price": "0.00000000",
                "qty": "4.00000000",
                "executedQty": "0.00000000",
                "preventedQty": "0.00000000",
                "quoteOrderQty": "0.00000000",
                "cumulativeQuoteQty": "0.00000000",
                "status": "PENDING_NEW",
                "timeInForce": "GTC",
                "type": "MARKET",
                "side": "BUY",
                "workingTime": 1741926410242,
                "selfTradePreventionMode": "NONE",
            },
            "listStatus": {
                "orderListId": 1,
                "contingencyType": "OTO",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "AT7FTxZXylVSwRoZs52mt3",
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 9,
                        "clientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 8,
                        "clientOrderId": "GkwwHZUUbFtZOoH1YsZk9Q",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 9,
                        "clientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 8,
                        "clientOrderId": "GkwwHZUUbFtZOoH1YsZk9Q",
                    },
                ],
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_amend_keep_priority(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/amend/keepPriority" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["newQty"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderAmendKeepPriorityResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderAmendKeepPriorityResponse.from_dict(expected_response)
        else:
            expected = OrderAmendKeepPriorityResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_amend_keep_priority_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test order_amend_keep_priority() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "new_client_order_id": "new_client_order_id_example",
            "recv_window": 5000,
        }

        expected_response = {
            "transactTime": 1741669661670,
            "executionId": 22,
            "amendedOrder": {
                "symbol": "BTCUSDT",
                "orderId": 9,
                "orderListId": 1,
                "origClientOrderId": "W0fJ9fiLKHOJutovPK3oJp",
                "clientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                "price": "0.00000000",
                "qty": "4.00000000",
                "executedQty": "0.00000000",
                "preventedQty": "0.00000000",
                "quoteOrderQty": "0.00000000",
                "cumulativeQuoteQty": "0.00000000",
                "status": "PENDING_NEW",
                "timeInForce": "GTC",
                "type": "MARKET",
                "side": "BUY",
                "workingTime": 1741926410242,
                "selfTradePreventionMode": "NONE",
            },
            "listStatus": {
                "orderListId": 1,
                "contingencyType": "OTO",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "AT7FTxZXylVSwRoZs52mt3",
                "symbol": "BTCUSDT",
                "orders": [
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 9,
                        "clientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 8,
                        "clientOrderId": "GkwwHZUUbFtZOoH1YsZk9Q",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 9,
                        "clientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                    },
                    {
                        "symbol": "BTCUSDT",
                        "orderId": 8,
                        "clientOrderId": "GkwwHZUUbFtZOoH1YsZk9Q",
                    },
                ],
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_amend_keep_priority(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/amend/keepPriority" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderAmendKeepPriorityResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderAmendKeepPriorityResponse.from_dict(expected_response)
        else:
            expected = OrderAmendKeepPriorityResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_amend_keep_priority_missing_required_param_symbol(self):
        """Test that order_amend_keep_priority() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_amend_keep_priority(**params)

    def test_order_amend_keep_priority_missing_required_param_new_qty(self):
        """Test that order_amend_keep_priority() raises RequiredError when 'new_qty' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
        }
        del params["new_qty"]

        with pytest.raises(RequiredError, match="Missing required parameter 'new_qty'"):
            self.client.order_amend_keep_priority(**params)

    def test_order_amend_keep_priority_server_error(self):
        """Test that order_amend_keep_priority() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "new_qty": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.order_amend_keep_priority = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_amend_keep_priority(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_cancel_replace_success(self, mock_get_signature):
        """Test order_cancel_replace() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
        }

        expected_response = {
            "cancelResult": "SUCCESS",
            "newOrderResult": "SUCCESS",
            "cancelResponse": {
                "symbol": "BTCUSDT",
                "origClientOrderId": "DnLo3vTAQcjha43lAZhZ0y",
                "orderId": 9,
                "orderListId": -1,
                "clientOrderId": "osxN3JXAtJvKvCqGeMWMVR",
                "transactTime": 1684804350068,
                "price": "0.01000000",
                "origQty": "0.000100",
                "executedQty": "0.00000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.00000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "selfTradePreventionMode": "NONE",
            },
            "newOrderResponse": {
                "symbol": "BTCUSDT",
                "orderId": 10,
                "orderListId": -1,
                "clientOrderId": "wOceeeOzNORyLiQfw7jd8S",
                "transactTime": 1652928801803,
                "price": "0.02000000",
                "origQty": "0.040000",
                "executedQty": "0.00000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.00000000",
                "status": "NEW",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "workingTime": 1669277163808,
                "fills": [],
                "selfTradePreventionMode": "NONE",
            },
            "code": -2021,
            "msg": "Order cancel-replace partially failed.",
            "data": {
                "cancelResult": "SUCCESS",
                "newOrderResult": "FAILURE",
                "cancelResponse": {
                    "code": -2011,
                    "msg": "Unknown order sent.",
                    "symbol": "LTCBNB",
                    "origClientOrderId": "GKt5zzfOxRDSQLveDYCTkc",
                    "orderId": 64,
                    "orderListId": -1,
                    "clientOrderId": "loehOJF3FjoreUBDmv739R",
                    "transactTime": 1715779007228,
                    "price": "1.00",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
                "newOrderResponse": {
                    "code": -1015,
                    "msg": "Too many new orders; current limit is 1 orders per 10 SECOND.",
                    "symbol": "BTCUSDT",
                    "orderId": 11,
                    "orderListId": -1,
                    "clientOrderId": "pfojJMg6IMNDKuJqDxvoxN",
                    "transactTime": 1648540168818,
                },
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_cancel_replace(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/cancelReplace" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["side"] == OrderCancelReplaceSideEnum["BUY"].value
        assert normalized["type"] == OrderCancelReplaceTypeEnum["MARKET"].value
        assert (
            normalized["cancelReplaceMode"]
            == OrderCancelReplaceCancelReplaceModeEnum["STOP_ON_FAILURE"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderCancelReplaceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderCancelReplaceResponse.from_dict(expected_response)
        else:
            expected = OrderCancelReplaceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_cancel_replace_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test order_cancel_replace() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
            "time_in_force": OrderCancelReplaceTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "quote_order_qty": 1.0,
            "price": 400.0,
            "cancel_new_client_order_id": "cancel_new_client_order_id_example",
            "cancel_orig_client_order_id": "cancel_orig_client_order_id_example",
            "cancel_order_id": 1,
            "new_client_order_id": "new_client_order_id_example",
            "strategy_id": 1,
            "strategy_type": 1,
            "stop_price": 1.0,
            "trailing_delta": 1,
            "iceberg_qty": 1.0,
            "new_order_resp_type": OrderCancelReplaceNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderCancelReplaceSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "cancel_restrictions": OrderCancelReplaceCancelRestrictionsEnum[
                "ONLY_NEW"
            ].value,
            "order_rate_limit_exceeded_mode": OrderCancelReplaceOrderRateLimitExceededModeEnum[
                "DO_NOTHING"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "cancelResult": "SUCCESS",
            "newOrderResult": "SUCCESS",
            "cancelResponse": {
                "symbol": "BTCUSDT",
                "origClientOrderId": "DnLo3vTAQcjha43lAZhZ0y",
                "orderId": 9,
                "orderListId": -1,
                "clientOrderId": "osxN3JXAtJvKvCqGeMWMVR",
                "transactTime": 1684804350068,
                "price": "0.01000000",
                "origQty": "0.000100",
                "executedQty": "0.00000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.00000000",
                "status": "CANCELED",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "SELL",
                "selfTradePreventionMode": "NONE",
            },
            "newOrderResponse": {
                "symbol": "BTCUSDT",
                "orderId": 10,
                "orderListId": -1,
                "clientOrderId": "wOceeeOzNORyLiQfw7jd8S",
                "transactTime": 1652928801803,
                "price": "0.02000000",
                "origQty": "0.040000",
                "executedQty": "0.00000000",
                "origQuoteOrderQty": "0.000000",
                "cummulativeQuoteQty": "0.00000000",
                "status": "NEW",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "workingTime": 1669277163808,
                "fills": [],
                "selfTradePreventionMode": "NONE",
            },
            "code": -2021,
            "msg": "Order cancel-replace partially failed.",
            "data": {
                "cancelResult": "SUCCESS",
                "newOrderResult": "FAILURE",
                "cancelResponse": {
                    "code": -2011,
                    "msg": "Unknown order sent.",
                    "symbol": "LTCBNB",
                    "origClientOrderId": "GKt5zzfOxRDSQLveDYCTkc",
                    "orderId": 64,
                    "orderListId": -1,
                    "clientOrderId": "loehOJF3FjoreUBDmv739R",
                    "transactTime": 1715779007228,
                    "price": "1.00",
                    "origQty": "10.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00",
                    "status": "CANCELED",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "selfTradePreventionMode": "NONE",
                },
                "newOrderResponse": {
                    "code": -1015,
                    "msg": "Too many new orders; current limit is 1 orders per 10 SECOND.",
                    "symbol": "BTCUSDT",
                    "orderId": 11,
                    "orderListId": -1,
                    "clientOrderId": "pfojJMg6IMNDKuJqDxvoxN",
                    "transactTime": 1648540168818,
                },
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_cancel_replace(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/cancelReplace" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderCancelReplaceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderCancelReplaceResponse.from_dict(expected_response)
        else:
            expected = OrderCancelReplaceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_cancel_replace_missing_required_param_symbol(self):
        """Test that order_cancel_replace() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_cancel_replace(**params)

    def test_order_cancel_replace_missing_required_param_side(self):
        """Test that order_cancel_replace() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.order_cancel_replace(**params)

    def test_order_cancel_replace_missing_required_param_type(self):
        """Test that order_cancel_replace() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
        }
        del params["type"]

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.order_cancel_replace(**params)

    def test_order_cancel_replace_missing_required_param_cancel_replace_mode(self):
        """Test that order_cancel_replace() raises RequiredError when 'cancel_replace_mode' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
        }
        del params["cancel_replace_mode"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'cancel_replace_mode'"
        ):
            self.client.order_cancel_replace(**params)

    def test_order_cancel_replace_server_error(self):
        """Test that order_cancel_replace() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderCancelReplaceSideEnum["BUY"].value,
            "type": OrderCancelReplaceTypeEnum["MARKET"].value,
            "cancel_replace_mode": OrderCancelReplaceCancelReplaceModeEnum[
                "STOP_ON_FAILURE"
            ].value,
        }

        mock_error = Exception("ResponseError")
        self.client.order_cancel_replace = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_cancel_replace(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_list_oco_success(self, mock_get_signature):
        """Test order_list_oco() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }

        expected_response = {
            "orderListId": 1,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "lH1YDkuQKWiXVXHPSKYEIp",
            "transactionTime": 1710485608839,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 11,
                    "clientOrderId": "NuMp0nVYnciDiFmVqfpBqK",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 10,
                    "clientOrderId": "44nZvqpemY7sVYgPYbvPih",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 11,
                    "orderListId": 1,
                    "clientOrderId": "NuMp0nVYnciDiFmVqfpBqK",
                    "transactTime": 1710485608839,
                    "price": "3.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "SELL",
                    "workingTime": 1710485608839,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 10,
                    "orderListId": 1,
                    "clientOrderId": "44nZvqpemY7sVYgPYbvPih",
                    "transactTime": 1710485608839,
                    "price": "1.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "SELL",
                    "stopPrice": "1.00000000",
                    "workingTime": -1,
                    "icebergQty": "1.00000000",
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_list_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList/oco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["side"] == OrderListOcoSideEnum["BUY"].value
        assert normalized["quantity"] == 1.0
        assert (
            normalized["aboveType"]
            == OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value
        )
        assert normalized["belowType"] == OrderListOcoBelowTypeEnum["STOP_LOSS"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderListOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderListOcoResponse.from_dict(expected_response)
        else:
            expected = OrderListOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_list_oco_success_with_optional_params(self, mock_get_signature):
        """Test order_list_oco() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
            "list_client_order_id": "list_client_order_id_example",
            "above_client_order_id": "above_client_order_id_example",
            "above_iceberg_qty": 1,
            "above_price": 1.0,
            "above_stop_price": 1.0,
            "above_trailing_delta": 1,
            "above_time_in_force": 1.0,
            "above_strategy_id": 1,
            "above_strategy_type": 1,
            "below_client_order_id": "below_client_order_id_example",
            "below_iceberg_qty": 1,
            "below_price": 1.0,
            "below_stop_price": 1.0,
            "below_trailing_delta": 1,
            "below_time_in_force": OrderListOcoBelowTimeInForceEnum["belowType"].value,
            "below_strategy_id": 1,
            "below_strategy_type": 1,
            "new_order_resp_type": OrderListOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 1,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "lH1YDkuQKWiXVXHPSKYEIp",
            "transactionTime": 1710485608839,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 11,
                    "clientOrderId": "NuMp0nVYnciDiFmVqfpBqK",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 10,
                    "clientOrderId": "44nZvqpemY7sVYgPYbvPih",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 11,
                    "orderListId": 1,
                    "clientOrderId": "NuMp0nVYnciDiFmVqfpBqK",
                    "transactTime": 1710485608839,
                    "price": "3.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "SELL",
                    "workingTime": 1710485608839,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 10,
                    "orderListId": 1,
                    "clientOrderId": "44nZvqpemY7sVYgPYbvPih",
                    "transactTime": 1710485608839,
                    "price": "1.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "SELL",
                    "stopPrice": "1.00000000",
                    "workingTime": -1,
                    "icebergQty": "1.00000000",
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_list_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList/oco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderListOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderListOcoResponse.from_dict(expected_response)
        else:
            expected = OrderListOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_list_oco_missing_required_param_symbol(self):
        """Test that order_list_oco() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_list_oco(**params)

    def test_order_list_oco_missing_required_param_side(self):
        """Test that order_list_oco() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.order_list_oco(**params)

    def test_order_list_oco_missing_required_param_quantity(self):
        """Test that order_list_oco() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }
        del params["quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.order_list_oco(**params)

    def test_order_list_oco_missing_required_param_above_type(self):
        """Test that order_list_oco() raises RequiredError when 'above_type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }
        del params["above_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'above_type'"
        ):
            self.client.order_list_oco(**params)

    def test_order_list_oco_missing_required_param_below_type(self):
        """Test that order_list_oco() raises RequiredError when 'below_type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }
        del params["below_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'below_type'"
        ):
            self.client.order_list_oco(**params)

    def test_order_list_oco_server_error(self):
        """Test that order_list_oco() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderListOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "above_type": OrderListOcoAboveTypeEnum["STOP_LOSS_LIMIT"].value,
            "below_type": OrderListOcoBelowTypeEnum["STOP_LOSS"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.order_list_oco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_list_oco(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_list_oto_success(self, mock_get_signature):
        """Test order_list_oto() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OTO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "yl2ERtcar1o25zcWtqVBTC",
            "transactionTime": 1712289389158,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "clientOrderId": "arLFo0zGJVDE69cvGBaU0d",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "clientOrderId": "Bq17mn9fP6vyCn75Jw1xya",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "orderListId": 0,
                    "clientOrderId": "arLFo0zGJVDE69cvGBaU0d",
                    "transactTime": 1712289389158,
                    "price": "0.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "PENDING_NEW",
                    "timeInForce": "GTC",
                    "type": "MARKET",
                    "side": "BUY",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "orderListId": 0,
                    "clientOrderId": "Bq17mn9fP6vyCn75Jw1xya",
                    "transactTime": 1712289389158,
                    "price": "1.00000000",
                    "origQty": "1.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "workingTime": 1712289389158,
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_list_oto(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList/oto" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["workingType"] == OrderListOtoWorkingTypeEnum["LIMIT"].value
        assert normalized["workingSide"] == OrderListOtoWorkingSideEnum["BUY"].value
        assert normalized["workingPrice"] == 1.0
        assert normalized["workingQuantity"] == 1.0
        assert normalized["pendingType"] == OrderListOtoPendingTypeEnum["LIMIT"].value
        assert normalized["pendingSide"] == OrderListOtoPendingSideEnum["BUY"].value
        assert normalized["pendingQuantity"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderListOtoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderListOtoResponse.from_dict(expected_response)
        else:
            expected = OrderListOtoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_list_oto_success_with_optional_params(self, mock_get_signature):
        """Test order_list_oto() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListOtoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListOtoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListOtoWorkingTimeInForceEnum["GTC"].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_client_order_id": "pending_client_order_id_example",
            "pending_price": 1.0,
            "pending_stop_price": 1.0,
            "pending_trailing_delta": 1.0,
            "pending_iceberg_qty": 1.0,
            "pending_time_in_force": OrderListOtoPendingTimeInForceEnum["GTC"].value,
            "pending_strategy_id": 1,
            "pending_strategy_type": 1,
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OTO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "yl2ERtcar1o25zcWtqVBTC",
            "transactionTime": 1712289389158,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "clientOrderId": "arLFo0zGJVDE69cvGBaU0d",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "clientOrderId": "Bq17mn9fP6vyCn75Jw1xya",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "orderListId": 0,
                    "clientOrderId": "arLFo0zGJVDE69cvGBaU0d",
                    "transactTime": 1712289389158,
                    "price": "0.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "PENDING_NEW",
                    "timeInForce": "GTC",
                    "type": "MARKET",
                    "side": "BUY",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "orderListId": 0,
                    "clientOrderId": "Bq17mn9fP6vyCn75Jw1xya",
                    "transactTime": 1712289389158,
                    "price": "1.00000000",
                    "origQty": "1.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "workingTime": 1712289389158,
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_list_oto(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList/oto" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderListOtoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderListOtoResponse.from_dict(expected_response)
        else:
            expected = OrderListOtoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_list_oto_missing_required_param_symbol(self):
        """Test that order_list_oto() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_working_type(self):
        """Test that order_list_oto() raises RequiredError when 'working_type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["working_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_type'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_working_side(self):
        """Test that order_list_oto() raises RequiredError when 'working_side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["working_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_side'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_working_price(self):
        """Test that order_list_oto() raises RequiredError when 'working_price' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["working_price"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_price'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_working_quantity(self):
        """Test that order_list_oto() raises RequiredError when 'working_quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["working_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_quantity'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_pending_type(self):
        """Test that order_list_oto() raises RequiredError when 'pending_type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["pending_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_type'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_pending_side(self):
        """Test that order_list_oto() raises RequiredError when 'pending_side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["pending_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_side'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_missing_required_param_pending_quantity(self):
        """Test that order_list_oto() raises RequiredError when 'pending_quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }
        del params["pending_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_quantity'"
        ):
            self.client.order_list_oto(**params)

    def test_order_list_oto_server_error(self):
        """Test that order_list_oto() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_type": OrderListOtoPendingTypeEnum["LIMIT"].value,
            "pending_side": OrderListOtoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.order_list_oto = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_list_oto(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_list_otoco_success(self, mock_get_signature):
        """Test order_list_otoco() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }

        expected_response = {
            "orderListId": 1,
            "contingencyType": "OTO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "RumwQpBaDctlUu5jyG5rs0",
            "transactionTime": 1712291372842,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 8,
                    "clientOrderId": "r4JMv9cwAYYUwwBZfbussx",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 7,
                    "clientOrderId": "6pcQbFIzTXGZQ1e2MkGDq4",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 6,
                    "clientOrderId": "fM9Y4m23IFJVCQmIrlUmMK",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 8,
                    "orderListId": 1,
                    "clientOrderId": "r4JMv9cwAYYUwwBZfbussx",
                    "transactTime": 1712291372842,
                    "price": "3.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "PENDING_NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "BUY",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 7,
                    "orderListId": 1,
                    "clientOrderId": "6pcQbFIzTXGZQ1e2MkGDq4",
                    "transactTime": 1712291372842,
                    "price": "1.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "PENDING_NEW",
                    "timeInForce": "IOC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "BUY",
                    "stopPrice": "6.00000000",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 6,
                    "orderListId": 1,
                    "clientOrderId": "fM9Y4m23IFJVCQmIrlUmMK",
                    "transactTime": 1712291372842,
                    "price": "1.00000000",
                    "origQty": "1.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "workingTime": 1712291372842,
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_list_otoco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList/otoco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["workingType"] == OrderListOtocoWorkingTypeEnum["LIMIT"].value
        assert normalized["workingSide"] == OrderListOtocoWorkingSideEnum["BUY"].value
        assert normalized["workingPrice"] == 1.0
        assert normalized["workingQuantity"] == 1.0
        assert normalized["pendingSide"] == OrderListOtocoPendingSideEnum["BUY"].value
        assert normalized["pendingQuantity"] == 1.0
        assert (
            normalized["pendingAboveType"]
            == OrderListOtocoPendingAboveTypeEnum["STOP_LOSS_LIMIT"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderListOtocoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderListOtocoResponse.from_dict(expected_response)
        else:
            expected = OrderListOtocoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_list_otoco_success_with_optional_params(self, mock_get_signature):
        """Test order_list_otoco() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
            "list_client_order_id": "list_client_order_id_example",
            "new_order_resp_type": OrderListOtocoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderListOtocoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "working_client_order_id": "working_client_order_id_example",
            "working_iceberg_qty": 1.0,
            "working_time_in_force": OrderListOtocoWorkingTimeInForceEnum["GTC"].value,
            "working_strategy_id": 1,
            "working_strategy_type": 1,
            "pending_above_client_order_id": "pending_above_client_order_id_example",
            "pending_above_price": 1.0,
            "pending_above_stop_price": 1.0,
            "pending_above_trailing_delta": 1.0,
            "pending_above_iceberg_qty": 1.0,
            "pending_above_time_in_force": OrderListOtocoPendingAboveTimeInForceEnum[
                "GTC"
            ].value,
            "pending_above_strategy_id": 1,
            "pending_above_strategy_type": 1,
            "pending_below_type": OrderListOtocoPendingBelowTypeEnum["STOP_LOSS"].value,
            "pending_below_client_order_id": "pending_below_client_order_id_example",
            "pending_below_price": 1.0,
            "pending_below_stop_price": 1.0,
            "pending_below_trailing_delta": 1.0,
            "pending_below_iceberg_qty": 1.0,
            "pending_below_time_in_force": OrderListOtocoPendingBelowTimeInForceEnum[
                "GTC"
            ].value,
            "pending_below_strategy_id": 1,
            "pending_below_strategy_type": 1,
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 1,
            "contingencyType": "OTO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "RumwQpBaDctlUu5jyG5rs0",
            "transactionTime": 1712291372842,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 8,
                    "clientOrderId": "r4JMv9cwAYYUwwBZfbussx",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 7,
                    "clientOrderId": "6pcQbFIzTXGZQ1e2MkGDq4",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 6,
                    "clientOrderId": "fM9Y4m23IFJVCQmIrlUmMK",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 8,
                    "orderListId": 1,
                    "clientOrderId": "r4JMv9cwAYYUwwBZfbussx",
                    "transactTime": 1712291372842,
                    "price": "3.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "PENDING_NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "BUY",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 7,
                    "orderListId": 1,
                    "clientOrderId": "6pcQbFIzTXGZQ1e2MkGDq4",
                    "transactTime": 1712291372842,
                    "price": "1.00000000",
                    "origQty": "5.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "PENDING_NEW",
                    "timeInForce": "IOC",
                    "type": "STOP_LOSS_LIMIT",
                    "side": "BUY",
                    "stopPrice": "6.00000000",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 6,
                    "orderListId": 1,
                    "clientOrderId": "fM9Y4m23IFJVCQmIrlUmMK",
                    "transactTime": 1712291372842,
                    "price": "1.00000000",
                    "origQty": "1.00000000",
                    "executedQty": "0.00000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.00000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT",
                    "side": "SELL",
                    "workingTime": 1712291372842,
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_list_otoco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList/otoco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderListOtocoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderListOtocoResponse.from_dict(expected_response)
        else:
            expected = OrderListOtocoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_list_otoco_missing_required_param_symbol(self):
        """Test that order_list_otoco() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_working_type(self):
        """Test that order_list_otoco() raises RequiredError when 'working_type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["working_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_type'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_working_side(self):
        """Test that order_list_otoco() raises RequiredError when 'working_side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["working_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_side'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_working_price(self):
        """Test that order_list_otoco() raises RequiredError when 'working_price' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["working_price"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_price'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_working_quantity(self):
        """Test that order_list_otoco() raises RequiredError when 'working_quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["working_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'working_quantity'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_pending_side(self):
        """Test that order_list_otoco() raises RequiredError when 'pending_side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["pending_side"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_side'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_pending_quantity(self):
        """Test that order_list_otoco() raises RequiredError when 'pending_quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["pending_quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_quantity'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_missing_required_param_pending_above_type(self):
        """Test that order_list_otoco() raises RequiredError when 'pending_above_type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }
        del params["pending_above_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'pending_above_type'"
        ):
            self.client.order_list_otoco(**params)

    def test_order_list_otoco_server_error(self):
        """Test that order_list_otoco() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "working_type": OrderListOtocoWorkingTypeEnum["LIMIT"].value,
            "working_side": OrderListOtocoWorkingSideEnum["BUY"].value,
            "working_price": 1.0,
            "working_quantity": 1.0,
            "pending_side": OrderListOtocoPendingSideEnum["BUY"].value,
            "pending_quantity": 1.0,
            "pending_above_type": OrderListOtocoPendingAboveTypeEnum[
                "STOP_LOSS_LIMIT"
            ].value,
        }

        mock_error = Exception("ResponseError")
        self.client.order_list_otoco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_list_otoco(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_oco_success(self, mock_get_signature):
        """Test order_oco() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "JYVpp3F0f5CAG15DhtrqLp",
            "transactionTime": 1563417480525,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                    "transactTime": 1563417480525,
                    "price": "0.036435",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "BUY",
                    "workingTime": 1563417480525,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                    "transactTime": 1563417480525,
                    "price": "0.000000",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS",
                    "side": "BUY",
                    "stopPrice": "0.960664",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/oco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["side"] == OrderOcoSideEnum["BUY"].value
        assert normalized["quantity"] == 1.0
        assert normalized["price"] == 1.0
        assert normalized["stopPrice"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderOcoResponse.from_dict(expected_response)
        else:
            expected = OrderOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_oco_success_with_optional_params(self, mock_get_signature):
        """Test order_oco() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
            "list_client_order_id": "list_client_order_id_example",
            "limit_client_order_id": "limit_client_order_id_example",
            "limit_strategy_id": 1,
            "limit_strategy_type": 1,
            "limit_iceberg_qty": 1.0,
            "trailing_delta": 1,
            "stop_client_order_id": "stop_client_order_id_example",
            "stop_strategy_id": 1,
            "stop_strategy_type": 1,
            "stop_limit_price": 1.0,
            "stop_iceberg_qty": 1.0,
            "stop_limit_time_in_force": OrderOcoStopLimitTimeInForceEnum["GTC"].value,
            "new_order_resp_type": OrderOcoNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": OrderOcoSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderListId": 0,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "JYVpp3F0f5CAG15DhtrqLp",
            "transactionTime": 1563417480525,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                },
            ],
            "orderReports": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 3,
                    "orderListId": 0,
                    "clientOrderId": "xTXKaGYd4bluPVp78IVRvl",
                    "transactTime": 1563417480525,
                    "price": "0.036435",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "LIMIT_MAKER",
                    "side": "BUY",
                    "workingTime": 1563417480525,
                    "selfTradePreventionMode": "NONE",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 2,
                    "orderListId": 0,
                    "clientOrderId": "Kk7sqHb9J6mJWTMDVW7Vos",
                    "transactTime": 1563417480525,
                    "price": "0.000000",
                    "origQty": "0.624363",
                    "executedQty": "0.000000",
                    "origQuoteOrderQty": "0.000000",
                    "cummulativeQuoteQty": "0.000000",
                    "status": "NEW",
                    "timeInForce": "GTC",
                    "type": "STOP_LOSS",
                    "side": "BUY",
                    "stopPrice": "0.960664",
                    "workingTime": -1,
                    "selfTradePreventionMode": "NONE",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_oco(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/oco" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderOcoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderOcoResponse.from_dict(expected_response)
        else:
            expected = OrderOcoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_oco_missing_required_param_symbol(self):
        """Test that order_oco() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_oco(**params)

    def test_order_oco_missing_required_param_side(self):
        """Test that order_oco() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.order_oco(**params)

    def test_order_oco_missing_required_param_quantity(self):
        """Test that order_oco() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        del params["quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.order_oco(**params)

    def test_order_oco_missing_required_param_price(self):
        """Test that order_oco() raises RequiredError when 'price' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        del params["price"]

        with pytest.raises(RequiredError, match="Missing required parameter 'price'"):
            self.client.order_oco(**params)

    def test_order_oco_missing_required_param_stop_price(self):
        """Test that order_oco() raises RequiredError when 'stop_price' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }
        del params["stop_price"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'stop_price'"
        ):
            self.client.order_oco(**params)

    def test_order_oco_server_error(self):
        """Test that order_oco() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": OrderOcoSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "stop_price": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.order_oco = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_oco(**params)

    @patch("binance_common.utils.get_signature")
    def test_order_test_success(self, mock_get_signature):
        """Test order_test() successfully with required parameters only."""

        expected_response = {
            "standardCommissionForOrder": {
                "maker": "0.00000112",
                "taker": "0.00000114",
            },
            "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
            "discount": {
                "enabledForAccount": True,
                "enabledForSymbol": True,
                "discountAsset": "BNB",
                "discount": "0.25000000",
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_test()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/test" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderTestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderTestResponse.from_dict(expected_response)
        else:
            expected = OrderTestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_test_success_with_optional_params(self, mock_get_signature):
        """Test order_test() successfully with optional parameters."""

        params = {"compute_commission_rates": False}

        expected_response = {
            "standardCommissionForOrder": {
                "maker": "0.00000112",
                "taker": "0.00000114",
            },
            "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
            "discount": {
                "enabledForAccount": True,
                "enabledForSymbol": True,
                "discountAsset": "BNB",
                "discount": "0.25000000",
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_test(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/test" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderTestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderTestResponse.from_dict(expected_response)
        else:
            expected = OrderTestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_test_server_error(self):
        """Test that order_test() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.order_test = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_test()

    @patch("binance_common.utils.get_signature")
    def test_sor_order_success(self, mock_get_signature):
        """Test sor_order() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }

        expected_response = {
            "symbol": "BTCUSDT",
            "orderId": 2,
            "orderListId": -1,
            "clientOrderId": "sBI1KM6nNtOfj5tccZSKly",
            "transactTime": 1689149087774,
            "price": "31000.00000000",
            "origQty": "0.50000000",
            "executedQty": "0.50000000",
            "origQuoteOrderQty": "0.000000",
            "cummulativeQuoteQty": "14000.00000000",
            "status": "FILLED",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "BUY",
            "workingTime": 1689149087774,
            "fills": [
                {
                    "matchType": "ONE_PARTY_TRADE_REPORT",
                    "price": "28000.00000000",
                    "qty": "0.50000000",
                    "commission": "0.00000000",
                    "commissionAsset": "BTC",
                    "tradeId": -1,
                    "allocId": 0,
                }
            ],
            "workingFloor": "SOR",
            "selfTradePreventionMode": "NONE",
            "usedSor": True,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sor_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/sor/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["side"] == SorOrderSideEnum["BUY"].value
        assert normalized["type"] == SorOrderTypeEnum["MARKET"].value
        assert normalized["quantity"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SorOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SorOrderResponse.from_dict(expected_response)
        else:
            expected = SorOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_sor_order_success_with_optional_params(self, mock_get_signature):
        """Test sor_order() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
            "time_in_force": SorOrderTimeInForceEnum["GTC"].value,
            "price": 400.0,
            "new_client_order_id": "new_client_order_id_example",
            "strategy_id": 1,
            "strategy_type": 1,
            "iceberg_qty": 1.0,
            "new_order_resp_type": SorOrderNewOrderRespTypeEnum["ACK"].value,
            "self_trade_prevention_mode": SorOrderSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "symbol": "BTCUSDT",
            "orderId": 2,
            "orderListId": -1,
            "clientOrderId": "sBI1KM6nNtOfj5tccZSKly",
            "transactTime": 1689149087774,
            "price": "31000.00000000",
            "origQty": "0.50000000",
            "executedQty": "0.50000000",
            "origQuoteOrderQty": "0.000000",
            "cummulativeQuoteQty": "14000.00000000",
            "status": "FILLED",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "BUY",
            "workingTime": 1689149087774,
            "fills": [
                {
                    "matchType": "ONE_PARTY_TRADE_REPORT",
                    "price": "28000.00000000",
                    "qty": "0.50000000",
                    "commission": "0.00000000",
                    "commissionAsset": "BTC",
                    "tradeId": -1,
                    "allocId": 0,
                }
            ],
            "workingFloor": "SOR",
            "selfTradePreventionMode": "NONE",
            "usedSor": True,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sor_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/sor/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SorOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SorOrderResponse.from_dict(expected_response)
        else:
            expected = SorOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_sor_order_missing_required_param_symbol(self):
        """Test that sor_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.sor_order(**params)

    def test_sor_order_missing_required_param_side(self):
        """Test that sor_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }
        del params["side"]

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.sor_order(**params)

    def test_sor_order_missing_required_param_type(self):
        """Test that sor_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }
        del params["type"]

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.sor_order(**params)

    def test_sor_order_missing_required_param_quantity(self):
        """Test that sor_order() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }
        del params["quantity"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.sor_order(**params)

    def test_sor_order_server_error(self):
        """Test that sor_order() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "side": SorOrderSideEnum["BUY"].value,
            "type": SorOrderTypeEnum["MARKET"].value,
            "quantity": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.sor_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.sor_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_sor_order_test_success(self, mock_get_signature):
        """Test sor_order_test() successfully with required parameters only."""

        expected_response = {
            "standardCommissionForOrder": {
                "maker": "0.00000112",
                "taker": "0.00000114",
            },
            "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
            "discount": {
                "enabledForAccount": True,
                "enabledForSymbol": True,
                "discountAsset": "BNB",
                "discount": "0.25000000",
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sor_order_test()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/sor/order/test" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SorOrderTestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SorOrderTestResponse.from_dict(expected_response)
        else:
            expected = SorOrderTestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_sor_order_test_success_with_optional_params(self, mock_get_signature):
        """Test sor_order_test() successfully with optional parameters."""

        params = {"compute_commission_rates": False}

        expected_response = {
            "standardCommissionForOrder": {
                "maker": "0.00000112",
                "taker": "0.00000114",
            },
            "taxCommissionForOrder": {"maker": "0.00000112", "taker": "0.00000114"},
            "discount": {
                "enabledForAccount": True,
                "enabledForSymbol": True,
                "discountAsset": "BNB",
                "discount": "0.25000000",
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sor_order_test(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/sor/order/test" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SorOrderTestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SorOrderTestResponse.from_dict(expected_response)
        else:
            expected = SorOrderTestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_sor_order_test_server_error(self):
        """Test that sor_order_test() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.sor_order_test = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.sor_order_test()
