"""
Binance Spot REST API

OpenAPI Specifications for the Binance Spot REST API

API documents:
  - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
  - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import requests
from typing import Optional, List, TypeVar, Union
from binance_common.configuration import ConfigurationRestAPI
from binance_common.models import ApiResponse
from binance_common.signature import Signers
from binance_common.utils import send_request
from .api.account_api import AccountApi
from .api.general_api import GeneralApi
from .api.market_api import MarketApi
from .api.trade_api import TradeApi
from .api.user_data_stream_api import UserDataStreamApi

from .models import AccountCommissionResponse
from .models import AllOrderListResponse
from .models import AllOrdersResponse
from .models import GetAccountResponse
from .models import GetOpenOrdersResponse
from .models import GetOrderResponse
from .models import GetOrderListResponse
from .models import MyAllocationsResponse
from .models import MyPreventedMatchesResponse
from .models import MyTradesResponse
from .models import OpenOrderListResponse
from .models import OrderAmendmentsResponse
from .models import RateLimitOrderResponse
from .models import ExchangeInfoResponse

from .models import TimeResponse
from .models import AggTradesResponse
from .models import AvgPriceResponse
from .models import DepthResponse
from .models import GetTradesResponse
from .models import HistoricalTradesResponse
from .models import KlinesResponse
from .models import TickerResponse
from .models import Ticker24hrResponse
from .models import TickerBookTickerResponse
from .models import TickerPriceResponse
from .models import TickerTradingDayResponse
from .models import UiKlinesResponse
from .models import DeleteOpenOrdersResponse
from .models import DeleteOrderResponse
from .models import DeleteOrderListResponse
from .models import NewOrderResponse
from .models import OrderAmendKeepPriorityResponse
from .models import OrderCancelReplaceResponse
from .models import OrderListOcoResponse
from .models import OrderListOtoResponse
from .models import OrderListOtocoResponse
from .models import OrderOcoResponse
from .models import OrderTestResponse
from .models import SorOrderResponse
from .models import SorOrderTestResponse

from .models import NewUserDataStreamResponse


from .models import ExchangeInfoSymbolStatusEnum
from .models import KlinesIntervalEnum
from .models import TickerWindowSizeEnum
from .models import TickerTypeEnum
from .models import Ticker24hrTypeEnum
from .models import TickerTradingDayTypeEnum
from .models import UiKlinesIntervalEnum
from .models import DeleteOrderCancelRestrictionsEnum
from .models import NewOrderSideEnum
from .models import NewOrderTypeEnum
from .models import NewOrderTimeInForceEnum
from .models import NewOrderNewOrderRespTypeEnum
from .models import NewOrderSelfTradePreventionModeEnum
from .models import NewOrderPegPriceTypeEnum
from .models import NewOrderPegOffsetTypeEnum
from .models import OrderCancelReplaceSideEnum
from .models import OrderCancelReplaceTypeEnum
from .models import OrderCancelReplaceCancelReplaceModeEnum
from .models import OrderCancelReplaceTimeInForceEnum
from .models import OrderCancelReplaceNewOrderRespTypeEnum
from .models import OrderCancelReplaceSelfTradePreventionModeEnum
from .models import OrderCancelReplaceCancelRestrictionsEnum
from .models import OrderCancelReplaceOrderRateLimitExceededModeEnum
from .models import OrderCancelReplacePegPriceTypeEnum
from .models import OrderCancelReplacePegOffsetTypeEnum
from .models import OrderListOcoSideEnum
from .models import OrderListOcoAboveTypeEnum
from .models import OrderListOcoBelowTypeEnum
from .models import OrderListOcoAbovePegPriceTypeEnum
from .models import OrderListOcoAbovePegOffsetTypeEnum
from .models import OrderListOcoBelowTimeInForceEnum
from .models import OrderListOcoBelowPegPriceTypeEnum
from .models import OrderListOcoBelowPegOffsetTypeEnum
from .models import OrderListOcoNewOrderRespTypeEnum
from .models import OrderListOcoSelfTradePreventionModeEnum
from .models import OrderListOtoWorkingTypeEnum
from .models import OrderListOtoWorkingSideEnum
from .models import OrderListOtoPendingTypeEnum
from .models import OrderListOtoPendingSideEnum
from .models import OrderListOtoNewOrderRespTypeEnum
from .models import OrderListOtoSelfTradePreventionModeEnum
from .models import OrderListOtoWorkingTimeInForceEnum
from .models import OrderListOtoWorkingPegPriceTypeEnum
from .models import OrderListOtoWorkingPegOffsetTypeEnum
from .models import OrderListOtoPendingTimeInForceEnum
from .models import OrderListOtoPendingPegPriceTypeEnum
from .models import OrderListOtoPendingPegOffsetTypeEnum
from .models import OrderListOtocoWorkingTypeEnum
from .models import OrderListOtocoWorkingSideEnum
from .models import OrderListOtocoPendingSideEnum
from .models import OrderListOtocoPendingAboveTypeEnum
from .models import OrderListOtocoNewOrderRespTypeEnum
from .models import OrderListOtocoSelfTradePreventionModeEnum
from .models import OrderListOtocoWorkingTimeInForceEnum
from .models import OrderListOtocoWorkingPegPriceTypeEnum
from .models import OrderListOtocoWorkingPegOffsetTypeEnum
from .models import OrderListOtocoPendingAboveTimeInForceEnum
from .models import OrderListOtocoPendingAbovePegPriceTypeEnum
from .models import OrderListOtocoPendingAbovePegOffsetTypeEnum
from .models import OrderListOtocoPendingBelowTypeEnum
from .models import OrderListOtocoPendingBelowTimeInForceEnum
from .models import OrderListOtocoPendingBelowPegPriceTypeEnum
from .models import OrderListOtocoPendingBelowPegOffsetTypeEnum
from .models import OrderOcoSideEnum
from .models import OrderOcoStopLimitTimeInForceEnum
from .models import OrderOcoNewOrderRespTypeEnum
from .models import OrderOcoSelfTradePreventionModeEnum
from .models import OrderTestSideEnum
from .models import OrderTestTypeEnum
from .models import OrderTestTimeInForceEnum
from .models import OrderTestNewOrderRespTypeEnum
from .models import OrderTestSelfTradePreventionModeEnum
from .models import OrderTestPegPriceTypeEnum
from .models import OrderTestPegOffsetTypeEnum
from .models import SorOrderSideEnum
from .models import SorOrderTypeEnum
from .models import SorOrderTimeInForceEnum
from .models import SorOrderNewOrderRespTypeEnum
from .models import SorOrderSelfTradePreventionModeEnum
from .models import SorOrderTestSideEnum
from .models import SorOrderTestTypeEnum
from .models import SorOrderTestTimeInForceEnum
from .models import SorOrderTestNewOrderRespTypeEnum
from .models import SorOrderTestSelfTradePreventionModeEnum


T = TypeVar("T")


class SpotRestAPI:
    def __init__(
        self,
        configuration: ConfigurationRestAPI,
    ) -> None:
        self.configuration = configuration
        self._session = requests.Session()
        self._signer = (
            Signers.get_signer(
                configuration.private_key, configuration.private_key_passphrase
            )
            if configuration.private_key is not None
            else None
        )

        self._accountApi = AccountApi(self.configuration, self._session, self._signer)
        self._generalApi = GeneralApi(self.configuration, self._session, self._signer)
        self._marketApi = MarketApi(self.configuration, self._session, self._signer)
        self._tradeApi = TradeApi(self.configuration, self._session, self._signer)
        self._userDataStreamApi = UserDataStreamApi(
            self.configuration, self._session, self._signer
        )

    def send_request(
        self,
        endpoint: str,
        method: str,
        params: Optional[dict] = None,
        time_unit: Optional[str] = None,
    ) -> ApiResponse[T]:
        """
        Sends an request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.
            time_unit (Optional[str]): The time unit to use for the request, or None to use the default.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session,
            self.configuration,
            method,
            endpoint,
            params,
            time_unit or self.configuration.time_unit,
        )

    def send_signed_request(
        self,
        endpoint: str,
        method: str,
        params: Optional[dict] = None,
        time_unit: Optional[str] = None,
    ) -> ApiResponse[T]:
        """
        Sends a signed request to the Binance REST API.

        Args:
            endpoint (str): The API endpoint path to send the request to.
            method (str): The HTTP method to use for the request (e.g. "GET", "POST", "PUT", "DELETE").
            params (Optional[dict]): The request payload as a dictionary, or None if no payload is required.
            time_unit (Optional[str]): The time unit to use for the request, or None to use the default.

        Returns:
            ApiResponse[T]: The API response, where T is the expected response type.
        """
        return send_request[T](
            self._session,
            self.configuration,
            method,
            endpoint,
            params,
            time_unit or self.configuration.time_unit,
            is_signed=True,
            signer=self._signer,
        )

    def account_commission(
        self,
        symbol: Union[str, None],
    ) -> ApiResponse[AccountCommissionResponse]:
        """
                Query Commission Rates

                Get current account commission rates.
        Weight: 20

                Args:
                    symbol (Union[str, None]):

                Returns:
                    ApiResponse[AccountCommissionResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.account_commission(symbol)

    def all_order_list(
        self,
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AllOrderListResponse]:
        """
                Query all Order lists

                Retrieves all order lists based on provided optional parameters.

        Note that the time between `startTime` and `endTime` can't be longer than 24 hours.
        Weight: 20

                Args:
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[AllOrderListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.all_order_list(
            from_id, start_time, end_time, limit, recv_window
        )

    def all_orders(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[AllOrdersResponse]:
        """
                All orders

                Get all account orders; active, canceled, or filled.
        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[AllOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.all_orders(
            symbol, order_id, start_time, end_time, limit, recv_window
        )

    def get_account(
        self,
        omit_zero_balances: Optional[bool] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetAccountResponse]:
        """
                Account information

                Get current account information.
        Weight: 20

                Args:
                    omit_zero_balances (Optional[bool] = None): When set to `true`, emits only the non-zero balances of an account. <br>Default value: `false`
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[GetAccountResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_account(omit_zero_balances, recv_window)

    def get_open_orders(
        self,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetOpenOrdersResponse]:
        """
                Current open orders

                Get all open orders on a symbol. **Careful** when accessing this with no symbol.
        Weight: 6 for a single symbol; **80** when the symbol parameter is omitted

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[GetOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_open_orders(symbol, recv_window)

    def get_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetOrderResponse]:
        """
                Query order

                Check an order's status.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[GetOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_order(
            symbol, order_id, orig_client_order_id, recv_window
        )

    def get_order_list(
        self,
        order_list_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[GetOrderListResponse]:
        """
                Query Order list

                Retrieves a specific order list based on provided optional parameters.
        Weight: 4

                Args:
                    order_list_id (Optional[int] = None): Either `orderListId` or `listClientOrderId` must be provided
                    orig_client_order_id (Optional[str] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[GetOrderListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.get_order_list(
            order_list_id, orig_client_order_id, recv_window
        )

    def my_allocations(
        self,
        symbol: Union[str, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_allocation_id: Optional[int] = None,
        limit: Optional[int] = None,
        order_id: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MyAllocationsResponse]:
        """
                Query Allocations

                Retrieves allocations resulting from SOR order placement.
        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    from_allocation_id (Optional[int] = None):
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.
                    order_id (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[MyAllocationsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.my_allocations(
            symbol,
            start_time,
            end_time,
            from_allocation_id,
            limit,
            order_id,
            recv_window,
        )

    def my_prevented_matches(
        self,
        symbol: Union[str, None],
        prevented_match_id: Optional[int] = None,
        order_id: Optional[int] = None,
        from_prevented_match_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MyPreventedMatchesResponse]:
        """
                Query Prevented Matches

                Displays the list of orders that were expired due to STP.

        These are the combinations supported:

        * `symbol` + `preventedMatchId`
        * `symbol` + `orderId`
        * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
        * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
        Weight: Case                            | Weight
        ----                            | -----
        If `symbol` is invalid          | 2
        Querying by `preventedMatchId`  | 2
        Querying by `orderId`           | 20

                Args:
                    symbol (Union[str, None]):
                    prevented_match_id (Optional[int] = None):
                    order_id (Optional[int] = None):
                    from_prevented_match_id (Optional[int] = None):
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[MyPreventedMatchesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.my_prevented_matches(
            symbol,
            prevented_match_id,
            order_id,
            from_prevented_match_id,
            limit,
            recv_window,
        )

    def my_trades(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[MyTradesResponse]:
        """
                Account trade list

                Get trades for a specific account and symbol.
        Weight: Condition| Weight|
        ---| ---
        |Without orderId|20|
        |With orderId|5|

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[MyTradesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.my_trades(
            symbol, order_id, start_time, end_time, from_id, limit, recv_window
        )

    def open_order_list(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OpenOrderListResponse]:
        """
                Query Open Order lists


        Weight: 6

                Args:
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OpenOrderListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.open_order_list(recv_window)

    def order_amendments(
        self,
        symbol: Union[str, None],
        order_id: Union[int, None],
        from_execution_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderAmendmentsResponse]:
        """
                Query Order Amendments

                Queries all amendments of a single order.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    order_id (Union[int, None]):
                    from_execution_id (Optional[int] = None):
                    limit (Optional[int] = None): Default:500; Maximum: 1000
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderAmendmentsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.order_amendments(
            symbol, order_id, from_execution_id, limit, recv_window
        )

    def rate_limit_order(
        self,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[RateLimitOrderResponse]:
        """
                Query Unfilled Order Count

                Displays the user's unfilled order count for all intervals.
        Weight: 40

                Args:
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[RateLimitOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._accountApi.rate_limit_order(recv_window)

    def exchange_info(
        self,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        permissions: Optional[List[str]] = None,
        show_permission_sets: Optional[bool] = None,
        symbol_status: Optional[ExchangeInfoSymbolStatusEnum] = None,
    ) -> ApiResponse[ExchangeInfoResponse]:
        """
                Exchange information

                Current exchange trading rules and symbol information
        Weight: 20

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    symbols (Optional[List[str]] = None): List of symbols to query
                    permissions (Optional[List[str]] = None): List of permissions to query
                    show_permission_sets (Optional[bool] = None): Controls whether the content of the `permissionSets` field is populated or not. Defaults to `true`
                    symbol_status (Optional[ExchangeInfoSymbolStatusEnum] = None):

                Returns:
                    ApiResponse[ExchangeInfoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._generalApi.exchange_info(
            symbol, symbols, permissions, show_permission_sets, symbol_status
        )

    def ping(
        self,
    ) -> ApiResponse[None]:
        """
                Test connectivity

                Test connectivity to the Rest API.
        Weight: 1

                Args:

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._generalApi.ping()

    def time(
        self,
    ) -> ApiResponse[TimeResponse]:
        """
                Check server time

                Test connectivity to the Rest API and get the current server time.
        Weight: 1

                Args:

                Returns:
                    ApiResponse[TimeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._generalApi.time()

    def agg_trades(
        self,
        symbol: Union[str, None],
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[AggTradesResponse]:
        """
                Compressed/Aggregate trades list

                Get compressed, aggregate trades. Trades that fill at the time, from the same taker order, with the same price will have the quantity aggregated.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.

                Returns:
                    ApiResponse[AggTradesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.agg_trades(symbol, from_id, start_time, end_time, limit)

    def avg_price(
        self,
        symbol: Union[str, None],
    ) -> ApiResponse[AvgPriceResponse]:
        """
                Current average price

                Current average price for a symbol.
        Weight: 2

                Args:
                    symbol (Union[str, None]):

                Returns:
                    ApiResponse[AvgPriceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.avg_price(symbol)

    def depth(
        self,
        symbol: Union[str, None],
        limit: Optional[int] = None,
    ) -> ApiResponse[DepthResponse]:
        """
                Order book


        Weight: Adjusted based on the limit:

        |Limit|Request Weight
        ------|-------
        1-100|  5
        101-500| 25
        501-1000| 50
        1001-5000| 250

                Args:
                    symbol (Union[str, None]):
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.

                Returns:
                    ApiResponse[DepthResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.depth(symbol, limit)

    def get_trades(
        self,
        symbol: Union[str, None],
        limit: Optional[int] = None,
    ) -> ApiResponse[GetTradesResponse]:
        """
                Recent trades list

                Get recent trades.
        Weight: 25

                Args:
                    symbol (Union[str, None]):
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.

                Returns:
                    ApiResponse[GetTradesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.get_trades(symbol, limit)

    def historical_trades(
        self,
        symbol: Union[str, None],
        limit: Optional[int] = None,
        from_id: Optional[int] = None,
    ) -> ApiResponse[HistoricalTradesResponse]:
        """
                Old trade lookup

                Get older trades.
        Weight: 25

                Args:
                    symbol (Union[str, None]):
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.
                    from_id (Optional[int] = None): ID to get aggregate trades from INCLUSIVE.

                Returns:
                    ApiResponse[HistoricalTradesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.historical_trades(symbol, limit, from_id)

    def klines(
        self,
        symbol: Union[str, None],
        interval: Union[KlinesIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        time_zone: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[KlinesResponse]:
        """
                Kline/Candlestick data

                Kline/candlestick bars for a symbol.
        Klines are uniquely identified by their open time.
        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    interval (Union[KlinesIntervalEnum, None]):
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    time_zone (Optional[str] = None): Default: 0 (UTC)
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.

                Returns:
                    ApiResponse[KlinesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.klines(
            symbol, interval, start_time, end_time, time_zone, limit
        )

    def ticker(
        self,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        window_size: Optional[TickerWindowSizeEnum] = None,
        type: Optional[TickerTypeEnum] = None,
    ) -> ApiResponse[TickerResponse]:
        """
                Rolling window price change statistics


        Weight: 4 for each requested <tt>symbol</tt> regardless of <tt>windowSize</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    symbols (Optional[List[str]] = None): List of symbols to query
                    window_size (Optional[TickerWindowSizeEnum] = None):
                    type (Optional[TickerTypeEnum] = None):

                Returns:
                    ApiResponse[TickerResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.ticker(symbol, symbols, window_size, type)

    def ticker24hr(
        self,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        type: Optional[Ticker24hrTypeEnum] = None,
    ) -> ApiResponse[Ticker24hrResponse]:
        """
                24hr ticker price change statistics

                24 hour rolling window price change statistics. **Careful** when accessing this with no symbol.
        Weight: <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Symbols Provided</th>
                <th>Weight</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">symbol</td>
                <td>1</td>
                <td>2</td>
            </tr>
            <tr>
                <td>symbol parameter is omitted</td>
                <td>80</td>
            </tr>
            <tr>
                <td rowspan="4">symbols</td>
                <td>1-20</td>
                <td>2</td>
            </tr>
            <tr>
                <td>21-100</td>
                <td>40</td>
            </tr>
            <tr>
                <td>101 or more</td>
                <td>80</td>
            </tr>
            <tr>
                <td>symbols parameter is omitted</td>
                <td>80</td>
            </tr>
        </tbody>
        </table>

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    symbols (Optional[List[str]] = None): List of symbols to query
                    type (Optional[Ticker24hrTypeEnum] = None):

                Returns:
                    ApiResponse[Ticker24hrResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.ticker24hr(symbol, symbols, type)

    def ticker_book_ticker(
        self,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
    ) -> ApiResponse[TickerBookTickerResponse]:
        """
                Symbol order book ticker

                Best price/qty on the order book for a symbol or symbols.
        Weight: <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Symbols Provided</th>
                <th>Weight</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">symbol</td>
                <td>1</td>
                <td>2</td>
            </tr>
            <tr>
                <td>symbol parameter is omitted</td>
                <td>4</td>
            </tr>
            <tr>
                <td>symbols</td>
                <td>Any</td>
                <td>4</td>
            </tr>
        </tbody>
        </table>

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    symbols (Optional[List[str]] = None): List of symbols to query

                Returns:
                    ApiResponse[TickerBookTickerResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.ticker_book_ticker(symbol, symbols)

    def ticker_price(
        self,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
    ) -> ApiResponse[TickerPriceResponse]:
        """
                Symbol price ticker

                Latest price for a symbol or symbols.
        Weight: <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Symbols Provided</th>
                <th>Weight</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td rowspan="2">symbol</td>
                <td>1</td>
                <td>2</td>
            </tr>
            <tr>
                <td>symbol parameter is omitted</td>
                <td>4</td>
            </tr>
            <tr>
                <td>symbols</td>
                <td>Any</td>
                <td>4</td>
            </tr>
        </tbody>
        </table>

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    symbols (Optional[List[str]] = None): List of symbols to query

                Returns:
                    ApiResponse[TickerPriceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.ticker_price(symbol, symbols)

    def ticker_trading_day(
        self,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        time_zone: Optional[str] = None,
        type: Optional[TickerTradingDayTypeEnum] = None,
    ) -> ApiResponse[TickerTradingDayResponse]:
        """
                Trading Day Ticker

                Price change statistics for a trading day.
        Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.

                Args:
                    symbol (Optional[str] = None): Symbol to query
                    symbols (Optional[List[str]] = None): List of symbols to query
                    time_zone (Optional[str] = None): Default: 0 (UTC)
                    type (Optional[TickerTradingDayTypeEnum] = None):

                Returns:
                    ApiResponse[TickerTradingDayResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.ticker_trading_day(symbol, symbols, time_zone, type)

    def ui_klines(
        self,
        symbol: Union[str, None],
        interval: Union[UiKlinesIntervalEnum, None],
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        time_zone: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> ApiResponse[UiKlinesResponse]:
        """
                UIKlines

                The request is similar to klines having the same parameters and response.

        `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    interval (Union[UiKlinesIntervalEnum, None]):
                    start_time (Optional[int] = None): Timestamp in ms to get aggregate trades from INCLUSIVE.
                    end_time (Optional[int] = None): Timestamp in ms to get aggregate trades until INCLUSIVE.
                    time_zone (Optional[str] = None): Default: 0 (UTC)
                    limit (Optional[int] = None): Default: 500; Maximum: 1000.

                Returns:
                    ApiResponse[UiKlinesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._marketApi.ui_klines(
            symbol, interval, start_time, end_time, time_zone, limit
        )

    def delete_open_orders(
        self,
        symbol: Union[str, None],
        recv_window: Optional[int] = None,
    ) -> ApiResponse[DeleteOpenOrdersResponse]:
        """
                Cancel All Open Orders on a Symbol

                Cancels all active orders on a symbol.
        This includes orders that are part of an order list.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[DeleteOpenOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.delete_open_orders(symbol, recv_window)

    def delete_order(
        self,
        symbol: Union[str, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        cancel_restrictions: Optional[DeleteOrderCancelRestrictionsEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[DeleteOrderResponse]:
        """
                Cancel order

                Cancel an active order.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    cancel_restrictions (Optional[DeleteOrderCancelRestrictionsEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[DeleteOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.delete_order(
            symbol,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            cancel_restrictions,
            recv_window,
        )

    def delete_order_list(
        self,
        symbol: Union[str, None],
        order_list_id: Optional[int] = None,
        list_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[DeleteOrderListResponse]:
        """
                Cancel Order list

                Cancel an entire Order list
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    order_list_id (Optional[int] = None): Either `orderListId` or `listClientOrderId` must be provided
                    list_client_order_id (Optional[str] = None): A unique Id for the entire orderList
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[DeleteOrderListResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.delete_order_list(
            symbol,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        )

    def new_order(
        self,
        symbol: Union[str, None],
        side: Union[NewOrderSideEnum, None],
        type: Union[NewOrderTypeEnum, None],
        time_in_force: Optional[NewOrderTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        new_order_resp_type: Optional[NewOrderNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            NewOrderSelfTradePreventionModeEnum
        ] = None,
        peg_price_type: Optional[NewOrderPegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[NewOrderPegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[NewOrderResponse]:
        """
                New order

                Send in a new order.

        This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[NewOrderSideEnum, None]):
                    type (Union[NewOrderTypeEnum, None]):
                    time_in_force (Optional[NewOrderTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    strategy_id (Optional[int] = None):
                    strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    stop_price (Optional[float] = None): Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
                    new_order_resp_type (Optional[NewOrderNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[NewOrderSelfTradePreventionModeEnum] = None):
                    peg_price_type (Optional[NewOrderPegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Priceleveltopegthepriceto(max:100).<br>See[PeggedOrdersInfo](#pegged-orders-info)
                    peg_offset_type (Optional[NewOrderPegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[NewOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.new_order(
            symbol,
            side,
            type,
            time_in_force,
            quantity,
            quote_order_qty,
            price,
            new_client_order_id,
            strategy_id,
            strategy_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            peg_price_type,
            peg_offset_value,
            peg_offset_type,
            recv_window,
        )

    def order_amend_keep_priority(
        self,
        symbol: Union[str, None],
        new_qty: Union[float, None],
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderAmendKeepPriorityResponse]:
        """
                Order Amend Keep Priority

                Reduce the quantity of an existing open order.

        This adds 0 orders to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.

        Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    new_qty (Union[float, None]): `newQty` must be greater than 0 and less than the order's quantity.
                    order_id (Optional[int] = None):
                    orig_client_order_id (Optional[str] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderAmendKeepPriorityResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_amend_keep_priority(
            symbol,
            new_qty,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            recv_window,
        )

    def order_cancel_replace(
        self,
        symbol: Union[str, None],
        side: Union[OrderCancelReplaceSideEnum, None],
        type: Union[OrderCancelReplaceTypeEnum, None],
        cancel_replace_mode: Union[OrderCancelReplaceCancelReplaceModeEnum, None],
        time_in_force: Optional[OrderCancelReplaceTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        price: Optional[float] = None,
        cancel_new_client_order_id: Optional[str] = None,
        cancel_orig_client_order_id: Optional[str] = None,
        cancel_order_id: Optional[int] = None,
        new_client_order_id: Optional[str] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        new_order_resp_type: Optional[OrderCancelReplaceNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderCancelReplaceSelfTradePreventionModeEnum
        ] = None,
        cancel_restrictions: Optional[OrderCancelReplaceCancelRestrictionsEnum] = None,
        order_rate_limit_exceeded_mode: Optional[
            OrderCancelReplaceOrderRateLimitExceededModeEnum
        ] = None,
        peg_price_type: Optional[OrderCancelReplacePegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderCancelReplacePegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderCancelReplaceResponse]:
        """
                Cancel an Existing Order and Send a New Order

                Cancels an existing order and places a new order on the same symbol.

        Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.

        A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED`), will still increase the unfilled order count by 1.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderCancelReplaceSideEnum, None]):
                    type (Union[OrderCancelReplaceTypeEnum, None]):
                    cancel_replace_mode (Union[OrderCancelReplaceCancelReplaceModeEnum, None]):
                    time_in_force (Optional[OrderCancelReplaceTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    price (Optional[float] = None):
                    cancel_new_client_order_id (Optional[str] = None): Used to uniquely identify this cancel. Automatically generated by default.
                    cancel_orig_client_order_id (Optional[str] = None): Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br> If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br> If both conditions are not met the request will be rejected.
                    cancel_order_id (Optional[int] = None): Either `cancelOrderId` or `cancelOrigClientOrderId` must be sent. <br></br>If both `cancelOrderId` and `cancelOrigClientOrderId` parameters are provided, the `cancelOrderId` is searched first, then the `cancelOrigClientOrderId` from that result is checked against that order. <br></br>If both conditions are not met the request will be rejected.
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    strategy_id (Optional[int] = None):
                    strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    stop_price (Optional[float] = None): Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
                    new_order_resp_type (Optional[OrderCancelReplaceNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderCancelReplaceSelfTradePreventionModeEnum] = None):
                    cancel_restrictions (Optional[OrderCancelReplaceCancelRestrictionsEnum] = None):
                    order_rate_limit_exceeded_mode (Optional[OrderCancelReplaceOrderRateLimitExceededModeEnum] = None):
                    peg_price_type (Optional[OrderCancelReplacePegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Priceleveltopegthepriceto(max:100).<br>See[PeggedOrdersInfo](#pegged-orders-info)
                    peg_offset_type (Optional[OrderCancelReplacePegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderCancelReplaceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_cancel_replace(
            symbol,
            side,
            type,
            cancel_replace_mode,
            time_in_force,
            quantity,
            quote_order_qty,
            price,
            cancel_new_client_order_id,
            cancel_orig_client_order_id,
            cancel_order_id,
            new_client_order_id,
            strategy_id,
            strategy_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            cancel_restrictions,
            order_rate_limit_exceeded_mode,
            peg_price_type,
            peg_offset_value,
            peg_offset_type,
            recv_window,
        )

    def order_list_oco(
        self,
        symbol: Union[str, None],
        side: Union[OrderListOcoSideEnum, None],
        quantity: Union[float, None],
        above_type: Union[OrderListOcoAboveTypeEnum, None],
        below_type: Union[OrderListOcoBelowTypeEnum, None],
        list_client_order_id: Optional[str] = None,
        above_client_order_id: Optional[str] = None,
        above_iceberg_qty: Optional[int] = None,
        above_price: Optional[float] = None,
        above_stop_price: Optional[float] = None,
        above_trailing_delta: Optional[int] = None,
        above_time_in_force: Optional[float] = None,
        above_strategy_id: Optional[int] = None,
        above_strategy_type: Optional[int] = None,
        above_peg_price_type: Optional[OrderListOcoAbovePegPriceTypeEnum] = None,
        above_peg_offset_type: Optional[OrderListOcoAbovePegOffsetTypeEnum] = None,
        above_peg_offset_value: Optional[int] = None,
        below_client_order_id: Optional[str] = None,
        below_iceberg_qty: Optional[int] = None,
        below_price: Optional[float] = None,
        below_stop_price: Optional[float] = None,
        below_trailing_delta: Optional[int] = None,
        below_time_in_force: Optional[OrderListOcoBelowTimeInForceEnum] = None,
        below_strategy_id: Optional[int] = None,
        below_strategy_type: Optional[int] = None,
        below_peg_price_type: Optional[OrderListOcoBelowPegPriceTypeEnum] = None,
        below_peg_offset_type: Optional[OrderListOcoBelowPegOffsetTypeEnum] = None,
        below_peg_offset_value: Optional[int] = None,
        new_order_resp_type: Optional[OrderListOcoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListOcoSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderListOcoResponse]:
        """
                New Order list - OCO

                Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.

        * An OCO has 2 orders called the **above order** and **below order**.
        * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
        * Price restrictions
          * If the OCO is on the `SELL` side:
            * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price >  `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
            * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
          * If the OCO is on the `BUY` side:
            * `LIMIT_MAKER/TAKE_PROFIT_LIMIT price` < Last Traded Price < `stopPrice`
            * `TAKE_PROFIT stopPrice` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
        * OCOs add **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderListOcoSideEnum, None]):
                    quantity (Union[float, None]):
                    above_type (Union[OrderListOcoAboveTypeEnum, None]):
                    below_type (Union[OrderListOcoBelowTypeEnum, None]):
                    list_client_order_id (Optional[str] = None): A unique Id for the entire orderList
                    above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
                    above_iceberg_qty (Optional[int] = None): Note that this can only be used if `aboveTimeInForce` is `GTC`.
                    above_price (Optional[float] = None): Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    above_stop_price (Optional[float] = None): Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
                    above_trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    above_time_in_force (Optional[float] = None): Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`
                    above_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the above order within an order strategy.
                    above_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
                    above_peg_price_type (Optional[OrderListOcoAbovePegPriceTypeEnum] = None):
                    above_peg_offset_type (Optional[OrderListOcoAbovePegOffsetTypeEnum] = None):
                    above_peg_offset_value (Optional[int] = None):
                    below_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the below order. Automatically generated if not sent
                    below_iceberg_qty (Optional[int] = None): Note that this can only be used if `belowTimeInForce` is `GTC`.
                    below_price (Optional[float] = None): Can be used if `belowType` is `STOP_LOSS_LIMIT`, `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    below_stop_price (Optional[float] = None): Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT` or `TAKE_PROFIT_LIMIT` <br>Either belowStopPrice or belowTrailingDelta or both, must be specified.
                    below_trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    below_time_in_force (Optional[OrderListOcoBelowTimeInForceEnum] = None):
                    below_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the below order within an order strategy.
                    below_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
                    below_peg_price_type (Optional[OrderListOcoBelowPegPriceTypeEnum] = None):
                    below_peg_offset_type (Optional[OrderListOcoBelowPegOffsetTypeEnum] = None):
                    below_peg_offset_value (Optional[int] = None):
                    new_order_resp_type (Optional[OrderListOcoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListOcoSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderListOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_list_oco(
            symbol,
            side,
            quantity,
            above_type,
            below_type,
            list_client_order_id,
            above_client_order_id,
            above_iceberg_qty,
            above_price,
            above_stop_price,
            above_trailing_delta,
            above_time_in_force,
            above_strategy_id,
            above_strategy_type,
            above_peg_price_type,
            above_peg_offset_type,
            above_peg_offset_value,
            below_client_order_id,
            below_iceberg_qty,
            below_price,
            below_stop_price,
            below_trailing_delta,
            below_time_in_force,
            below_strategy_id,
            below_strategy_type,
            below_peg_price_type,
            below_peg_offset_type,
            below_peg_offset_value,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        )

    def order_list_oto(
        self,
        symbol: Union[str, None],
        working_type: Union[OrderListOtoWorkingTypeEnum, None],
        working_side: Union[OrderListOtoWorkingSideEnum, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_type: Union[OrderListOtoPendingTypeEnum, None],
        pending_side: Union[OrderListOtoPendingSideEnum, None],
        pending_quantity: Union[float, None],
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderListOtoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListOtoSelfTradePreventionModeEnum
        ] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[OrderListOtoWorkingTimeInForceEnum] = None,
        working_strategy_id: Optional[int] = None,
        working_strategy_type: Optional[int] = None,
        working_peg_price_type: Optional[OrderListOtoWorkingPegPriceTypeEnum] = None,
        working_peg_offset_type: Optional[OrderListOtoWorkingPegOffsetTypeEnum] = None,
        working_peg_offset_value: Optional[int] = None,
        pending_client_order_id: Optional[str] = None,
        pending_price: Optional[float] = None,
        pending_stop_price: Optional[float] = None,
        pending_trailing_delta: Optional[float] = None,
        pending_iceberg_qty: Optional[float] = None,
        pending_time_in_force: Optional[OrderListOtoPendingTimeInForceEnum] = None,
        pending_strategy_id: Optional[int] = None,
        pending_strategy_type: Optional[int] = None,
        pending_peg_price_type: Optional[OrderListOtoPendingPegPriceTypeEnum] = None,
        pending_peg_offset_type: Optional[OrderListOtoPendingPegOffsetTypeEnum] = None,
        pending_peg_offset_value: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderListOtoResponse]:
        """
                New Order list - OTO

                Place an OTO.

        * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
        * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
        * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
        * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
        * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
        * OTOs add **2 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

                Args:
                    symbol (Union[str, None]):
                    working_type (Union[OrderListOtoWorkingTypeEnum, None]):
                    working_side (Union[OrderListOtoWorkingSideEnum, None]):
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]): Sets the quantity for the working order.
                    pending_type (Union[OrderListOtoPendingTypeEnum, None]):
                    pending_side (Union[OrderListOtoPendingSideEnum, None]):
                    pending_quantity (Union[float, None]): Sets the quantity for the pending order.
                    list_client_order_id (Optional[str] = None): A unique Id for the entire orderList
                    new_order_resp_type (Optional[OrderListOtoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListOtoSelfTradePreventionModeEnum] = None):
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
                    working_time_in_force (Optional[OrderListOtoWorkingTimeInForceEnum] = None):
                    working_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the working order within an order strategy.
                    working_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    working_peg_price_type (Optional[OrderListOtoWorkingPegPriceTypeEnum] = None):
                    working_peg_offset_type (Optional[OrderListOtoWorkingPegOffsetTypeEnum] = None):
                    working_peg_offset_value (Optional[int] = None):
                    pending_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
                    pending_price (Optional[float] = None):
                    pending_stop_price (Optional[float] = None):
                    pending_trailing_delta (Optional[float] = None):
                    pending_iceberg_qty (Optional[float] = None): This can only be used if `pendingTimeInForce` is `GTC` or if `pendingType` is `LIMIT_MAKER`.
                    pending_time_in_force (Optional[OrderListOtoPendingTimeInForceEnum] = None):
                    pending_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending order within an order strategy.
                    pending_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_peg_price_type (Optional[OrderListOtoPendingPegPriceTypeEnum] = None):
                    pending_peg_offset_type (Optional[OrderListOtoPendingPegOffsetTypeEnum] = None):
                    pending_peg_offset_value (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderListOtoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_list_oto(
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_type,
            pending_side,
            pending_quantity,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            working_peg_price_type,
            working_peg_offset_type,
            working_peg_offset_value,
            pending_client_order_id,
            pending_price,
            pending_stop_price,
            pending_trailing_delta,
            pending_iceberg_qty,
            pending_time_in_force,
            pending_strategy_id,
            pending_strategy_type,
            pending_peg_price_type,
            pending_peg_offset_type,
            pending_peg_offset_value,
            recv_window,
        )

    def order_list_otoco(
        self,
        symbol: Union[str, None],
        working_type: Union[OrderListOtocoWorkingTypeEnum, None],
        working_side: Union[OrderListOtocoWorkingSideEnum, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_side: Union[OrderListOtocoPendingSideEnum, None],
        pending_quantity: Union[float, None],
        pending_above_type: Union[OrderListOtocoPendingAboveTypeEnum, None],
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderListOtocoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListOtocoSelfTradePreventionModeEnum
        ] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[OrderListOtocoWorkingTimeInForceEnum] = None,
        working_strategy_id: Optional[int] = None,
        working_strategy_type: Optional[int] = None,
        working_peg_price_type: Optional[OrderListOtocoWorkingPegPriceTypeEnum] = None,
        working_peg_offset_type: Optional[
            OrderListOtocoWorkingPegOffsetTypeEnum
        ] = None,
        working_peg_offset_value: Optional[int] = None,
        pending_above_client_order_id: Optional[str] = None,
        pending_above_price: Optional[float] = None,
        pending_above_stop_price: Optional[float] = None,
        pending_above_trailing_delta: Optional[float] = None,
        pending_above_iceberg_qty: Optional[float] = None,
        pending_above_time_in_force: Optional[
            OrderListOtocoPendingAboveTimeInForceEnum
        ] = None,
        pending_above_strategy_id: Optional[int] = None,
        pending_above_strategy_type: Optional[int] = None,
        pending_above_peg_price_type: Optional[
            OrderListOtocoPendingAbovePegPriceTypeEnum
        ] = None,
        pending_above_peg_offset_type: Optional[
            OrderListOtocoPendingAbovePegOffsetTypeEnum
        ] = None,
        pending_above_peg_offset_value: Optional[int] = None,
        pending_below_type: Optional[OrderListOtocoPendingBelowTypeEnum] = None,
        pending_below_client_order_id: Optional[str] = None,
        pending_below_price: Optional[float] = None,
        pending_below_stop_price: Optional[float] = None,
        pending_below_trailing_delta: Optional[float] = None,
        pending_below_iceberg_qty: Optional[float] = None,
        pending_below_time_in_force: Optional[
            OrderListOtocoPendingBelowTimeInForceEnum
        ] = None,
        pending_below_strategy_id: Optional[int] = None,
        pending_below_strategy_type: Optional[int] = None,
        pending_below_peg_price_type: Optional[
            OrderListOtocoPendingBelowPegPriceTypeEnum
        ] = None,
        pending_below_peg_offset_type: Optional[
            OrderListOtocoPendingBelowPegOffsetTypeEnum
        ] = None,
        pending_below_peg_offset_value: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderListOtocoResponse]:
        """
                New Order list - OTOCO

                Place an OTOCO.

        * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
        * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
          * The behavior of the working order is the same as the [OTO](#new-order-list---oto-trade).
        * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
            * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
        * OTOCOs add **3 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 3

                Args:
                    symbol (Union[str, None]):
                    working_type (Union[OrderListOtocoWorkingTypeEnum, None]):
                    working_side (Union[OrderListOtocoWorkingSideEnum, None]):
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]): Sets the quantity for the working order.
                    pending_side (Union[OrderListOtocoPendingSideEnum, None]):
                    pending_quantity (Union[float, None]): Sets the quantity for the pending order.
                    pending_above_type (Union[OrderListOtocoPendingAboveTypeEnum, None]):
                    list_client_order_id (Optional[str] = None): A unique Id for the entire orderList
                    new_order_resp_type (Optional[OrderListOtocoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListOtocoSelfTradePreventionModeEnum] = None):
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
                    working_time_in_force (Optional[OrderListOtocoWorkingTimeInForceEnum] = None):
                    working_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the working order within an order strategy.
                    working_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    working_peg_price_type (Optional[OrderListOtocoWorkingPegPriceTypeEnum] = None):
                    working_peg_offset_type (Optional[OrderListOtocoWorkingPegOffsetTypeEnum] = None):
                    working_peg_offset_value (Optional[int] = None):
                    pending_above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
                    pending_above_price (Optional[float] = None): Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    pending_above_stop_price (Optional[float] = None): Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
                    pending_above_trailing_delta (Optional[float] = None): See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
                    pending_above_iceberg_qty (Optional[float] = None): This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
                    pending_above_time_in_force (Optional[OrderListOtocoPendingAboveTimeInForceEnum] = None):
                    pending_above_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending above order within an order strategy.
                    pending_above_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_above_peg_price_type (Optional[OrderListOtocoPendingAbovePegPriceTypeEnum] = None):
                    pending_above_peg_offset_type (Optional[OrderListOtocoPendingAbovePegOffsetTypeEnum] = None):
                    pending_above_peg_offset_value (Optional[int] = None):
                    pending_below_type (Optional[OrderListOtocoPendingBelowTypeEnum] = None):
                    pending_below_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
                    pending_below_price (Optional[float] = None): Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify limit price
                    pending_below_stop_price (Optional[float] = None): Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
                    pending_below_trailing_delta (Optional[float] = None):
                    pending_below_iceberg_qty (Optional[float] = None): This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
                    pending_below_time_in_force (Optional[OrderListOtocoPendingBelowTimeInForceEnum] = None):
                    pending_below_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending below order within an order strategy.
                    pending_below_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_below_peg_price_type (Optional[OrderListOtocoPendingBelowPegPriceTypeEnum] = None):
                    pending_below_peg_offset_type (Optional[OrderListOtocoPendingBelowPegOffsetTypeEnum] = None):
                    pending_below_peg_offset_value (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderListOtocoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_list_otoco(
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_side,
            pending_quantity,
            pending_above_type,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            working_peg_price_type,
            working_peg_offset_type,
            working_peg_offset_value,
            pending_above_client_order_id,
            pending_above_price,
            pending_above_stop_price,
            pending_above_trailing_delta,
            pending_above_iceberg_qty,
            pending_above_time_in_force,
            pending_above_strategy_id,
            pending_above_strategy_type,
            pending_above_peg_price_type,
            pending_above_peg_offset_type,
            pending_above_peg_offset_value,
            pending_below_type,
            pending_below_client_order_id,
            pending_below_price,
            pending_below_stop_price,
            pending_below_trailing_delta,
            pending_below_iceberg_qty,
            pending_below_time_in_force,
            pending_below_strategy_id,
            pending_below_strategy_type,
            pending_below_peg_price_type,
            pending_below_peg_offset_type,
            pending_below_peg_offset_value,
            recv_window,
        )

    def order_oco(
        self,
        symbol: Union[str, None],
        side: Union[OrderOcoSideEnum, None],
        quantity: Union[float, None],
        price: Union[float, None],
        stop_price: Union[float, None],
        list_client_order_id: Optional[str] = None,
        limit_client_order_id: Optional[str] = None,
        limit_strategy_id: Optional[int] = None,
        limit_strategy_type: Optional[int] = None,
        limit_iceberg_qty: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        stop_client_order_id: Optional[str] = None,
        stop_strategy_id: Optional[int] = None,
        stop_strategy_type: Optional[int] = None,
        stop_limit_price: Optional[float] = None,
        stop_iceberg_qty: Optional[float] = None,
        stop_limit_time_in_force: Optional[OrderOcoStopLimitTimeInForceEnum] = None,
        new_order_resp_type: Optional[OrderOcoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderOcoSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderOcoResponse]:
        """
                New OCO - Deprecated

                Send in a new OCO.

        * Price Restrictions:
            * `SELL`: Limit Price > Last Price > Stop Price
            * `BUY`: Limit Price < Last Price < Stop Price
        * Quantity Restrictions:
            * Both legs must have the same quantity.
            * `ICEBERG` quantities however do not have to be the same
        * `OCO` adds **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderOcoSideEnum, None]):
                    quantity (Union[float, None]):
                    price (Union[float, None]):
                    stop_price (Union[float, None]):
                    list_client_order_id (Optional[str] = None): A unique Id for the entire orderList
                    limit_client_order_id (Optional[str] = None): A unique Id for the limit order
                    limit_strategy_id (Optional[int] = None):
                    limit_strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    limit_iceberg_qty (Optional[float] = None): Used to make the `LIMIT_MAKER` leg an iceberg order.
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    stop_client_order_id (Optional[str] = None): A unique Id for the stop loss/stop loss limit leg
                    stop_strategy_id (Optional[int] = None):
                    stop_strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    stop_limit_price (Optional[float] = None): If provided, `stopLimitTimeInForce` is required.
                    stop_iceberg_qty (Optional[float] = None): Used with `STOP_LOSS_LIMIT` leg to make an iceberg order.
                    stop_limit_time_in_force (Optional[OrderOcoStopLimitTimeInForceEnum] = None):
                    new_order_resp_type (Optional[OrderOcoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderOcoSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_oco(
            symbol,
            side,
            quantity,
            price,
            stop_price,
            list_client_order_id,
            limit_client_order_id,
            limit_strategy_id,
            limit_strategy_type,
            limit_iceberg_qty,
            trailing_delta,
            stop_client_order_id,
            stop_strategy_id,
            stop_strategy_type,
            stop_limit_price,
            stop_iceberg_qty,
            stop_limit_time_in_force,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        )

    def order_test(
        self,
        symbol: Union[str, None],
        side: Union[OrderTestSideEnum, None],
        type: Union[OrderTestTypeEnum, None],
        compute_commission_rates: Optional[bool] = None,
        time_in_force: Optional[OrderTestTimeInForceEnum] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        new_order_resp_type: Optional[OrderTestNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderTestSelfTradePreventionModeEnum
        ] = None,
        peg_price_type: Optional[OrderTestPegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderTestPegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[OrderTestResponse]:
        """
                Test new order

                Test new order creation and signature/recvWindow long.
        Creates and validates a new order but does not send it into the matching engine.
        Weight: |Condition| Request Weight|
        |------------           | ------------ |
        |Without `computeCommissionRates`| 1|
        |With `computeCommissionRates`|20|

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderTestSideEnum, None]):
                    type (Union[OrderTestTypeEnum, None]):
                    compute_commission_rates (Optional[bool] = None): Default: `false` <br> See [Commissions FAQ](faqs/commission_faq.md#test-order-diferences) to learn more.
                    time_in_force (Optional[OrderTestTimeInForceEnum] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    strategy_id (Optional[int] = None):
                    strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    stop_price (Optional[float] = None): Used with `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, and `TAKE_PROFIT_LIMIT` orders.
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
                    new_order_resp_type (Optional[OrderTestNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderTestSelfTradePreventionModeEnum] = None):
                    peg_price_type (Optional[OrderTestPegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Priceleveltopegthepriceto(max:100).<br>See[PeggedOrdersInfo](#pegged-orders-info)
                    peg_offset_type (Optional[OrderTestPegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[OrderTestResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.order_test(
            symbol,
            side,
            type,
            compute_commission_rates,
            time_in_force,
            quantity,
            quote_order_qty,
            price,
            new_client_order_id,
            strategy_id,
            strategy_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            peg_price_type,
            peg_offset_value,
            peg_offset_type,
            recv_window,
        )

    def sor_order(
        self,
        symbol: Union[str, None],
        side: Union[SorOrderSideEnum, None],
        type: Union[SorOrderTypeEnum, None],
        quantity: Union[float, None],
        time_in_force: Optional[SorOrderTimeInForceEnum] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        new_order_resp_type: Optional[SorOrderNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            SorOrderSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[SorOrderResponse]:
        """
                New order using SOR

                Places an order using smart order routing (SOR).

        This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.

        Read [SOR FAQ](faqs/sor_faq.md) to learn more.
        Weight: 1

        Unfilled Order Count: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[SorOrderSideEnum, None]):
                    type (Union[SorOrderTypeEnum, None]):
                    quantity (Union[float, None]):
                    time_in_force (Optional[SorOrderTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    strategy_id (Optional[int] = None):
                    strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
                    new_order_resp_type (Optional[SorOrderNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[SorOrderSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[SorOrderResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.sor_order(
            symbol,
            side,
            type,
            quantity,
            time_in_force,
            price,
            new_client_order_id,
            strategy_id,
            strategy_type,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        )

    def sor_order_test(
        self,
        symbol: Union[str, None],
        side: Union[SorOrderTestSideEnum, None],
        type: Union[SorOrderTestTypeEnum, None],
        quantity: Union[float, None],
        compute_commission_rates: Optional[bool] = None,
        time_in_force: Optional[SorOrderTestTimeInForceEnum] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        new_order_resp_type: Optional[SorOrderTestNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            SorOrderTestSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> ApiResponse[SorOrderTestResponse]:
        """
                Test new order using SOR

                Test new order creation and signature/recvWindow using smart order routing (SOR).
        Creates and validates a new order but does not send it into the matching engine.
        Weight: | Condition | Request Weight |
        | --------- | -------------- |
        | Without `computeCommissionRates`  |  1 |
        | With `computeCommissionRates`     | 20 |

                Args:
                    symbol (Union[str, None]):
                    side (Union[SorOrderTestSideEnum, None]):
                    type (Union[SorOrderTestTypeEnum, None]):
                    quantity (Union[float, None]):
                    compute_commission_rates (Optional[bool] = None): Default: `false` <br> See [Commissions FAQ](faqs/commission_faq.md#test-order-diferences) to learn more.
                    time_in_force (Optional[SorOrderTestTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): A unique id among open orders. Automatically generated if not sent.<br/> Orders with the same `newClientOrderID` can be accepted only when the previous one is filled, otherwise the order will be rejected.
                    strategy_id (Optional[int] = None):
                    strategy_type (Optional[int] = None): The value cannot be less than `1000000`.
                    iceberg_qty (Optional[float] = None): Used with `LIMIT`, `STOP_LOSS_LIMIT`, and `TAKE_PROFIT_LIMIT` to create an iceberg order.
                    new_order_resp_type (Optional[SorOrderTestNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[SorOrderTestSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    ApiResponse[SorOrderTestResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._tradeApi.sor_order_test(
            symbol,
            side,
            type,
            quantity,
            compute_commission_rates,
            time_in_force,
            price,
            new_client_order_id,
            strategy_id,
            strategy_type,
            iceberg_qty,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        )

    def delete_user_data_stream(
        self,
        listen_key: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Close user data stream

                Close out a user data stream.
        Weight: 2

                Args:
                    listen_key (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamApi.delete_user_data_stream(listen_key)

    def new_user_data_stream(
        self,
    ) -> ApiResponse[NewUserDataStreamResponse]:
        """
                Start user data stream

                Start a new user data stream. The stream will close after 60 minutes unless a keepalive is sent.
        Weight: 2

                Args:

                Returns:
                    ApiResponse[NewUserDataStreamResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamApi.new_user_data_stream()

    def put_user_data_stream(
        self,
        listen_key: Union[str, None],
    ) -> ApiResponse[None]:
        """
                Keepalive user data stream

                Keepalive a user data stream to prevent a time out. User data streams will close after 60 minutes. It's recommended to send a ping about every 30 minutes.
        Weight: 2

                Args:
                    listen_key (Union[str, None]):

                Returns:
                    ApiResponse[None]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return self._userDataStreamApi.put_user_data_stream(listen_key)
