"""
Binance Spot WebSocket API

OpenAPI Specifications for the Binance Spot WebSocket API

API documents:
  - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
  - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from typing import Dict, Optional, List, TypeVar, Type, Union
from pydantic import BaseModel

from binance_common.configuration import ConfigurationWebSocketAPI
from binance_common.models import (
    WebsocketApiResponse,
    WebsocketApiUserDataEndpoints,
    WebsocketApiUserDataStreamResponse,
)
from binance_common.signature import Signers
from binance_common.websocket import (
    WebSocketAPIBase,
    WebSocketConnection,
    RequestStreamHandle,
    RequestStream,
)

from .api.account_api import AccountApi
from .api.auth_api import AuthApi
from .api.general_api import GeneralApi
from .api.market_api import MarketApi
from .api.trade_api import TradeApi
from .api.user_data_stream_api import UserDataStreamApi

from .models import AccountCommissionResponse
from .models import AccountRateLimitsOrdersResponse
from .models import AccountStatusResponse
from .models import AllOrderListsResponse
from .models import AllOrdersResponse
from .models import MyAllocationsResponse
from .models import MyPreventedMatchesResponse
from .models import MyTradesResponse
from .models import OpenOrderListsStatusResponse
from .models import OpenOrdersStatusResponse
from .models import OrderAmendmentsResponse
from .models import OrderListStatusResponse
from .models import OrderStatusResponse
from .models import SessionLogonResponse
from .models import SessionLogoutResponse
from .models import SessionStatusResponse
from .models import ExchangeInfoResponse
from .models import PingResponse
from .models import TimeResponse
from .models import AvgPriceResponse
from .models import DepthResponse
from .models import KlinesResponse
from .models import TickerResponse
from .models import Ticker24hrResponse
from .models import TickerBookResponse
from .models import TickerPriceResponse
from .models import TickerTradingDayResponse
from .models import TradesAggregateResponse
from .models import TradesHistoricalResponse
from .models import TradesRecentResponse
from .models import UiKlinesResponse
from .models import OpenOrdersCancelAllResponse
from .models import OrderAmendKeepPriorityResponse
from .models import OrderCancelResponse
from .models import OrderCancelReplaceResponse
from .models import OrderListCancelResponse
from .models import OrderListPlaceResponse
from .models import OrderListPlaceOcoResponse
from .models import OrderListPlaceOtoResponse
from .models import OrderListPlaceOtocoResponse
from .models import OrderPlaceResponse
from .models import OrderTestResponse
from .models import SorOrderPlaceResponse
from .models import SorOrderTestResponse
from .models import SessionSubscriptionsResponse
from .models import UserDataStreamPingResponse
from .models import UserDataStreamStartResponse
from .models import UserDataStreamStopResponse
from .models import UserDataStreamSubscribeResponse
from .models import UserDataStreamSubscribeSignatureResponse
from .models import UserDataStreamUnsubscribeResponse

from .models import UserDataStreamEventsResponse

from .models import ExchangeInfoSymbolStatusEnum
from .models import KlinesIntervalEnum
from .models import TickerTypeEnum
from .models import TickerWindowSizeEnum
from .models import Ticker24hrTypeEnum
from .models import TickerTradingDayTypeEnum
from .models import UiKlinesIntervalEnum
from .models import OrderCancelCancelRestrictionsEnum
from .models import OrderCancelReplaceCancelReplaceModeEnum
from .models import OrderCancelReplaceSideEnum
from .models import OrderCancelReplaceTypeEnum
from .models import OrderCancelReplaceTimeInForceEnum
from .models import OrderCancelReplaceNewOrderRespTypeEnum
from .models import OrderCancelReplaceSelfTradePreventionModeEnum
from .models import OrderCancelReplaceCancelRestrictionsEnum
from .models import OrderCancelReplaceOrderRateLimitExceededModeEnum
from .models import OrderCancelReplacePegPriceTypeEnum
from .models import OrderCancelReplacePegOffsetTypeEnum
from .models import OrderListPlaceSideEnum
from .models import OrderListPlaceStopLimitTimeInForceEnum
from .models import OrderListPlaceNewOrderRespTypeEnum
from .models import OrderListPlaceSelfTradePreventionModeEnum
from .models import OrderListPlaceOcoSideEnum
from .models import OrderListPlaceOcoAboveTypeEnum
from .models import OrderListPlaceOcoBelowTypeEnum
from .models import OrderListPlaceOcoAbovePegPriceTypeEnum
from .models import OrderListPlaceOcoAbovePegOffsetTypeEnum
from .models import OrderListPlaceOcoBelowTimeInForceEnum
from .models import OrderListPlaceOcoBelowPegPriceTypeEnum
from .models import OrderListPlaceOcoBelowPegOffsetTypeEnum
from .models import OrderListPlaceOcoNewOrderRespTypeEnum
from .models import OrderListPlaceOcoSelfTradePreventionModeEnum
from .models import OrderListPlaceOtoWorkingTypeEnum
from .models import OrderListPlaceOtoWorkingSideEnum
from .models import OrderListPlaceOtoPendingTypeEnum
from .models import OrderListPlaceOtoPendingSideEnum
from .models import OrderListPlaceOtoNewOrderRespTypeEnum
from .models import OrderListPlaceOtoSelfTradePreventionModeEnum
from .models import OrderListPlaceOtoWorkingTimeInForceEnum
from .models import OrderListPlaceOtoWorkingPegPriceTypeEnum
from .models import OrderListPlaceOtoWorkingPegOffsetTypeEnum
from .models import OrderListPlaceOtoPendingTimeInForceEnum
from .models import OrderListPlaceOtoPendingPegOffsetTypeEnum
from .models import OrderListPlaceOtoPendingPegPriceTypeEnum
from .models import OrderListPlaceOtocoWorkingTypeEnum
from .models import OrderListPlaceOtocoWorkingSideEnum
from .models import OrderListPlaceOtocoPendingSideEnum
from .models import OrderListPlaceOtocoPendingAboveTypeEnum
from .models import OrderListPlaceOtocoNewOrderRespTypeEnum
from .models import OrderListPlaceOtocoSelfTradePreventionModeEnum
from .models import OrderListPlaceOtocoWorkingTimeInForceEnum
from .models import OrderListPlaceOtocoWorkingPegPriceTypeEnum
from .models import OrderListPlaceOtocoWorkingPegOffsetTypeEnum
from .models import OrderListPlaceOtocoPendingAboveTimeInForceEnum
from .models import OrderListPlaceOtocoPendingAbovePegPriceTypeEnum
from .models import OrderListPlaceOtocoPendingAbovePegOffsetTypeEnum
from .models import OrderListPlaceOtocoPendingBelowTypeEnum
from .models import OrderListPlaceOtocoPendingBelowTimeInForceEnum
from .models import OrderListPlaceOtocoPendingBelowPegPriceTypeEnum
from .models import OrderListPlaceOtocoPendingBelowPegOffsetTypeEnum
from .models import OrderPlaceSideEnum
from .models import OrderPlaceTypeEnum
from .models import OrderPlaceTimeInForceEnum
from .models import OrderPlaceNewOrderRespTypeEnum
from .models import OrderPlaceSelfTradePreventionModeEnum
from .models import OrderPlacePegPriceTypeEnum
from .models import OrderPlacePegOffsetTypeEnum
from .models import OrderTestSideEnum
from .models import OrderTestTypeEnum
from .models import OrderTestTimeInForceEnum
from .models import OrderTestNewOrderRespTypeEnum
from .models import OrderTestSelfTradePreventionModeEnum
from .models import OrderTestPegPriceTypeEnum
from .models import OrderTestPegOffsetTypeEnum
from .models import SorOrderPlaceSideEnum
from .models import SorOrderPlaceTypeEnum
from .models import SorOrderPlaceTimeInForceEnum
from .models import SorOrderPlaceNewOrderRespTypeEnum
from .models import SorOrderPlaceSelfTradePreventionModeEnum
from .models import SorOrderTestSideEnum
from .models import SorOrderTestTypeEnum
from .models import SorOrderTestTimeInForceEnum
from .models import SorOrderTestNewOrderRespTypeEnum
from .models import SorOrderTestSelfTradePreventionModeEnum

T = TypeVar("T", bound=BaseModel)


class SpotWebSocketAPI(WebSocketAPIBase):
    def __init__(
        self,
        configuration: ConfigurationWebSocketAPI,
    ) -> None:
        self.user_data_endpoints = WebsocketApiUserDataEndpoints(
            user_data_stream_subscribe="userDataStream.subscribe",
            user_data_stream_logout="/session.logout".replace("/", "", 1),
        )
        super().__init__(configuration, self.user_data_endpoints)
        self.configuration = configuration
        self.signer = (
            Signers.get_signer(
                configuration.private_key, configuration.private_key_passphrase
            )
            if configuration.private_key is not None
            else None
        )

        self._accountApi = AccountApi(self, self.signer)
        self._authApi = AuthApi(self, self.signer)
        self._generalApi = GeneralApi(self, self.signer)
        self._marketApi = MarketApi(self, self.signer)
        self._tradeApi = TradeApi(self, self.signer)
        self._userDataStreamApi = UserDataStreamApi(self, self.signer)

    async def ping_server(self, connection: WebSocketConnection):
        """Sends a ping message to the WebSocket server to check the connection status.

        Args:
            connection (WebSocketConnection): The WebSocket connection to send the ping message to.
        """
        if self.session:
            return await super().ping_ws_api(connection=connection)
        else:
            raise ValueError("WebSocket session is not initialized.")

    async def send_message(
        self,
        payload: Dict,
        promised: bool = True,
        response_model: Type[T] = None,
        api_key: Optional[bool] = False,
        session_logon: Optional[bool] = False,
        session_logout: Optional[bool] = False,
    ) -> WebsocketApiResponse[T]:
        """Sends a message to the WebSocket server.

        Args:
            payload (Dict): The message payload to send.
            promised (bool): Whether the message is promised or not.
            response_model (Type[T]): The expected response model type.
            api_key (Optional[bool]): Whether to include the API key in the request.
            session_logon (Optional[bool]): Whether the message is for session logon.
            session_logout (Optional[bool]): Whether the message is for session logout.
        Returns:
            WebsocketApiResponse[T]: The response from the WebSocket server.
        """

        return await super().send_message(
            payload, promised, response_model, api_key, session_logon, session_logout
        )

    async def send_signed_message(
        self,
        payload: Dict,
        signer: Optional[Signers] = None,
        promised: bool = True,
        response_model: Type[T] = None,
        api_key: Optional[bool] = False,
        session_logon: Optional[bool] = False,
        session_logout: Optional[bool] = False,
    ):
        """Sends a signed message to the WebSocket server.

        Args:
            payload (Dict): The message payload to send.
            signer (Optional[Signers]): The signer to use for signing the message.
            promised (bool): Whether the message is promised or not.
            response_model (Type[T]): The expected response model type.
            api_key (Optional[bool]): Whether to include the API key in the request.
            session_logon (Optional[bool]): Whether the message is for session logon.
            session_logout (Optional[bool]): Whether the message is for session logout.
        Returns:
            WebsocketApiResponse[T]: The response from the WebSocket server.
        """

        return await super().send_signed_message(
            payload,
            signer,
            promised,
            response_model,
            api_key=api_key,
            session_logon=session_logon,
            session_logout=session_logout,
        )

    async def close_connection(
        self, connection: WebSocketConnection = None, close_session: bool = True
    ):
        """Closes the WebSocket connection and optionally the session.

        Args:
            connection (WebSocketConnection, optional): The WebSocket connection to close. If None, the current session's connection is used.
            close_session (bool, optional): Whether to close the session after closing the connection. Defaults to True.
        """

        await super().close_connection(connection, close_session)

    async def account_commission(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[AccountCommissionResponse]:
        """
                WebSocket Account Commission Rates

                Get current account commission rates.
        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[AccountCommissionResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.account_commission(symbol, id)

    async def account_rate_limits_orders(
        self,
        id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[AccountRateLimitsOrdersResponse]:
        """
                WebSocket Unfilled Order Count

                Query your current unfilled order count for all intervals.
        Weight: 40

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[AccountRateLimitsOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.account_rate_limits_orders(id, recv_window)

    async def account_status(
        self,
        id: Optional[str] = None,
        omit_zero_balances: Optional[bool] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[AccountStatusResponse]:
        """
                WebSocket Account information

                Query information about your account.
        Weight: 20

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    omit_zero_balances (Optional[bool] = None): When set to `true`, emits only the non-zero balances of an account. <br>Default value: false
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[AccountStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.account_status(
            id, omit_zero_balances, recv_window
        )

    async def all_order_lists(
        self,
        id: Optional[str] = None,
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[AllOrderListsResponse]:
        """
                WebSocket Account order list history

                Query information about all your order lists, filtered by time range.
        Weight: 20

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    from_id (Optional[int] = None): Aggregate trade ID to begin at
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default: 100; Maximum: 5000
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[AllOrderListsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.all_order_lists(
            id, from_id, start_time, end_time, limit, recv_window
        )

    async def all_orders(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[AllOrdersResponse]:
        """
                WebSocket Account order history

                Query information about all your orders – active, canceled, filled – filtered by time range.
        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default: 100; Maximum: 5000
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[AllOrdersResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.all_orders(
            symbol, id, order_id, start_time, end_time, limit, recv_window
        )

    async def my_allocations(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_allocation_id: Optional[int] = None,
        limit: Optional[int] = None,
        order_id: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[MyAllocationsResponse]:
        """
                WebSocket Account allocations

                Retrieves allocations resulting from SOR order placement.
        Weight: 20

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    from_allocation_id (Optional[int] = None):
                    limit (Optional[int] = None): Default: 100; Maximum: 5000
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[MyAllocationsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.my_allocations(
            symbol,
            id,
            start_time,
            end_time,
            from_allocation_id,
            limit,
            order_id,
            recv_window,
        )

    async def my_prevented_matches(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        prevented_match_id: Optional[int] = None,
        order_id: Optional[int] = None,
        from_prevented_match_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[MyPreventedMatchesResponse]:
        """
                WebSocket Account prevented matches

                Displays the list of orders that were expired due to STP.

        These are the combinations supported:

        * `symbol` + `preventedMatchId`
        * `symbol` + `orderId`
        * `symbol` + `orderId` + `fromPreventedMatchId` (`limit` will default to 500)
        * `symbol` + `orderId` + `fromPreventedMatchId` + `limit`
        Weight: Case                            | Weight
        ----                            | -----
        If `symbol` is invalid          | 2
        Querying by `preventedMatchId`  | 2
        Querying by `orderId`           | 20

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    prevented_match_id (Optional[int] = None):
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    from_prevented_match_id (Optional[int] = None):
                    limit (Optional[int] = None): Default: 100; Maximum: 5000
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[MyPreventedMatchesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.my_prevented_matches(
            symbol,
            id,
            prevented_match_id,
            order_id,
            from_prevented_match_id,
            limit,
            recv_window,
        )

    async def my_trades(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[MyTradesResponse]:
        """
                WebSocket Account trade history

                Query information about all your trades, filtered by time range.
        Weight: Condition| Weight|
        ---| ---
        |Without orderId|20|
        |With orderId|5|

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    from_id (Optional[int] = None): Aggregate trade ID to begin at
                    limit (Optional[int] = None): Default: 100; Maximum: 5000
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[MyTradesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.my_trades(
            symbol, id, order_id, start_time, end_time, from_id, limit, recv_window
        )

    async def open_order_lists_status(
        self,
        id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OpenOrderListsStatusResponse]:
        """
                WebSocket Current open Order lists

                Query execution status of all open order lists.

        If you need to continuously monitor order status updates, please consider using WebSocket Streams:

        * `userDataStream.start` request
        * `executionReport` user data stream event
        Weight: 6

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OpenOrderListsStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.open_order_lists_status(id, recv_window)

    async def open_orders_status(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OpenOrdersStatusResponse]:
        """
                WebSocket Current open orders

                Query execution status of all open orders.

        If you need to continuously monitor order status updates, please consider using WebSocket Streams:

        * `userDataStream.start` request
        * `executionReport` user data stream event
        Weight: Adjusted based on the number of requested symbols:

        | Parameter | Weight |
        | --------- | ------ |
        | `symbol`  |      6 |
        | none      |     80 |

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OpenOrdersStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.open_orders_status(id, symbol, recv_window)

    async def order_amendments(
        self,
        symbol: Union[str, None],
        order_id: Union[int, None],
        id: Optional[str] = None,
        from_execution_id: Optional[int] = None,
        limit: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderAmendmentsResponse]:
        """
                WebSocket Query Order Amendments

                Queries all amendments of a single order.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    order_id (Union[int, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    from_execution_id (Optional[int] = None):
                    limit (Optional[int] = None): Default: 100; Maximum: 5000
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderAmendmentsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.order_amendments(
            symbol, order_id, id, from_execution_id, limit, recv_window
        )

    async def order_list_status(
        self,
        id: Optional[str] = None,
        orig_client_order_id: Optional[str] = None,
        order_list_id: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListStatusResponse]:
        """
                WebSocket Query Order list

                Check execution status of an Order list.

        For execution status of individual orders, use `order.status`.
        Weight: 4

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    orig_client_order_id (Optional[str] = None): `orderId`or`origClientOrderId`mustbesent
                    order_list_id (Optional[int] = None): Cancel order list by orderListId
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderListStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.order_list_status(
            id, orig_client_order_id, order_list_id, recv_window
        )

    async def order_status(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderStatusResponse]:
        """
                WebSocket Query order

                Check execution status of an order.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    orig_client_order_id (Optional[str] = None): `orderId`or`origClientOrderId`mustbesent
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._accountApi.order_status(
            symbol, id, order_id, orig_client_order_id, recv_window
        )

    async def session_logon(
        self,
        id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[SessionLogonResponse]:
        """
                WebSocket Log in with API key

                Authenticate WebSocket connection using the provided API key.

        After calling `session.logon`, you can omit `apiKey` and `signature` parameters for future requests that require them.

        Note that only one API key can be authenticated.
        Calling `session.logon` multiple times changes the current authenticated API key.
        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[SessionLogonResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._authApi.session_logon(id, recv_window)

    async def session_logout(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[SessionLogoutResponse]:
        """
                WebSocket Log out of the session

                Forget the API key previously authenticated.
        If the connection is not authenticated, this request does nothing.

        Note that the WebSocket connection stays open after `session.logout` request.
        You can continue using the connection,
        but now you will have to explicitly provide the `apiKey` and `signature` parameters where needed.
        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[SessionLogoutResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._authApi.session_logout(id)

    async def session_status(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[SessionStatusResponse]:
        """
                WebSocket Query session status

                Query the status of the WebSocket connection,
        inspecting which API key (if any) is used to authorize requests.
        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[SessionStatusResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._authApi.session_status(id)

    async def exchange_info(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        permissions: Optional[List[str]] = None,
        show_permission_sets: Optional[bool] = None,
        symbol_status: Optional[ExchangeInfoSymbolStatusEnum] = None,
    ) -> WebsocketApiResponse[ExchangeInfoResponse]:
        """
                WebSocket Exchange information

                Query current exchange trading rules, rate limits, and symbol information.
        Weight: 20

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    symbols (Optional[List[str]] = None): List of symbols to query
                    permissions (Optional[List[str]] = None):
                    show_permission_sets (Optional[bool] = None):
                    symbol_status (Optional[ExchangeInfoSymbolStatusEnum] = None):

                Returns:
                    WebsocketApiResponse[ExchangeInfoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._generalApi.exchange_info(
            id, symbol, symbols, permissions, show_permission_sets, symbol_status
        )

    async def ping(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[PingResponse]:
        """
                WebSocket Test connectivity

                Test connectivity to the WebSocket API.
        Weight: 1

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[PingResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._generalApi.ping(id)

    async def time(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[TimeResponse]:
        """
                WebSocket Check server time

                Test connectivity to the WebSocket API and get the current server time.
        Weight: 1

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[TimeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._generalApi.time(id)

    async def avg_price(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[AvgPriceResponse]:
        """
                WebSocket Current average price

                Get current average price for a symbol.
        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[AvgPriceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.avg_price(symbol, id)

    async def depth(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> WebsocketApiResponse[DepthResponse]:
        """
                WebSocket Order book

                Get current order book.

        Note that this request returns limited market depth.

        If you need to continuously monitor order book updates, please consider using WebSocket Streams:

        * `<symbol>@depth<levels>`
        * `<symbol>@depth`

        You can use `depth` request together with `<symbol>@depth` streams to [maintain a local order book](web-socket-streams.md#how-to-manage-a-local-order-book-correctly).
        Weight: Adjusted based on the limit:

        |  Limit    | Weight |
        |:---------:|:------:|
        |     1–100 |      5 |
        |   101–500 |      25|
        |  501–1000 |     50 |
        | 1001–5000 |     250 |

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    limit (Optional[int] = None): Default: 100; Maximum: 5000

                Returns:
                    WebsocketApiResponse[DepthResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.depth(symbol, id, limit)

    async def klines(
        self,
        symbol: Union[str, None],
        interval: Union[KlinesIntervalEnum, None],
        id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        time_zone: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> WebsocketApiResponse[KlinesResponse]:
        """
                WebSocket Klines

                Get klines (candlestick bars).

        Klines are uniquely identified by their open & close time.

        If you need access to real-time kline updates, please consider using WebSocket Streams:

        * `<symbol>@kline_<interval>`

        If you need historical kline data,
        please consider using [data.binance.vision](https://github.com/binance/binance-public-data/#klines).
        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    interval (Union[KlinesIntervalEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    time_zone (Optional[str] = None): Default: 0 (UTC)
                    limit (Optional[int] = None): Default: 100; Maximum: 5000

                Returns:
                    WebsocketApiResponse[KlinesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.klines(
            symbol, interval, id, start_time, end_time, time_zone, limit
        )

    async def ticker(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        type: Optional[TickerTypeEnum] = None,
        window_size: Optional[TickerWindowSizeEnum] = None,
    ) -> WebsocketApiResponse[TickerResponse]:
        """
                WebSocket Rolling window price change statistics

                Get rolling window price change statistics with a custom window.

        This request is similar to `ticker.24hr`,
        but statistics are computed on demand using the arbitrary window you specify.
        Weight: Adjusted based on the number of requested symbols:

        | Symbols | Weight |
        |:-------:|:------:|
        |    1–50 | 4 per symbol |
        |  51–100 |    200 |

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    symbols (Optional[List[str]] = None): List of symbols to query
                    type (Optional[TickerTypeEnum] = None):
                    window_size (Optional[TickerWindowSizeEnum] = None):

                Returns:
                    WebsocketApiResponse[TickerResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.ticker(id, symbol, symbols, type, window_size)

    async def ticker24hr(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        type: Optional[Ticker24hrTypeEnum] = None,
    ) -> WebsocketApiResponse[Ticker24hrResponse]:
        """
                WebSocket 24hr ticker price change statistics

                Get 24-hour rolling window price change statistics.

        If you need to continuously monitor trading statistics, please consider using WebSocket Streams:

        * `<symbol>@ticker` or `!ticker@arr`
        * `<symbol>@miniTicker` or `!miniTicker@arr`

        If you need different window sizes,
        use the `ticker` request.
        Weight: Adjusted based on the number of requested symbols:

        | Symbols     | Weight |
        |:-----------:|:------:|
        |        1–20 |      2 |
        |      21–100 |     40 |
        | 101 or more |     80 |
        | all symbols |     80 |

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    symbols (Optional[List[str]] = None): List of symbols to query
                    type (Optional[Ticker24hrTypeEnum] = None):

                Returns:
                    WebsocketApiResponse[Ticker24hrResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.ticker24hr(id, symbol, symbols, type)

    async def ticker_book(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
    ) -> WebsocketApiResponse[TickerBookResponse]:
        """
                WebSocket Symbol order book ticker

                Get the current best price and quantity on the order book.

        If you need access to real-time order book ticker updates, please consider using WebSocket Streams:

        * `<symbol>@bookTicker`
        Weight: Adjusted based on the number of requested symbols:

        | Parameter | Weight |
        | --------- |:------:|
        | `symbol`  |      2 |
        | `symbols` |      4 |
        | none      |      4 |

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    symbols (Optional[List[str]] = None): List of symbols to query

                Returns:
                    WebsocketApiResponse[TickerBookResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.ticker_book(id, symbol, symbols)

    async def ticker_price(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
    ) -> WebsocketApiResponse[TickerPriceResponse]:
        """
                WebSocket Symbol price ticker

                Get the latest market price for a symbol.

        If you need access to real-time price updates, please consider using WebSocket Streams:

        * `<symbol>@aggTrade`
        * `<symbol>@trade`
        Weight: Adjusted based on the number of requested symbols:

        | Parameter | Weight |
        | --------- |:------:|
        | `symbol`  |      2 |
        | `symbols` |      4 |
        | none      |      4 |

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    symbols (Optional[List[str]] = None): List of symbols to query

                Returns:
                    WebsocketApiResponse[TickerPriceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.ticker_price(id, symbol, symbols)

    async def ticker_trading_day(
        self,
        id: Optional[str] = None,
        symbol: Optional[str] = None,
        symbols: Optional[List[str]] = None,
        time_zone: Optional[str] = None,
        type: Optional[TickerTradingDayTypeEnum] = None,
    ) -> WebsocketApiResponse[TickerTradingDayResponse]:
        """
                WebSocket Trading Day Ticker

                Price change statistics for a trading day.
        Weight: 4 for each requested <tt>symbol</tt>. <br/><br/> The weight for this request will cap at 200 once the number of `symbols` in the request is more than 50.

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    symbol (Optional[str] = None): Describe a single symbol
                    symbols (Optional[List[str]] = None): List of symbols to query
                    time_zone (Optional[str] = None): Default: 0 (UTC)
                    type (Optional[TickerTradingDayTypeEnum] = None):

                Returns:
                    WebsocketApiResponse[TickerTradingDayResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.ticker_trading_day(
            id, symbol, symbols, time_zone, type
        )

    async def trades_aggregate(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        from_id: Optional[int] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> WebsocketApiResponse[TradesAggregateResponse]:
        """
                WebSocket Aggregate trades

                Get aggregate trades.

        An *aggregate trade* (aggtrade) represents one or more individual trades.
        Trades that fill at the same time, from the same taker order, with the same price –
        those trades are collected into an aggregate trade with total quantity of the individual trades.

        If you need access to real-time trading activity, please consider using WebSocket Streams:

        * `<symbol>@aggTrade`

        If you need historical aggregate trade data,
        please consider using [data.binance.vision](https://github.com/binance/binance-public-data/#aggtrades).
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    from_id (Optional[int] = None): Aggregate trade ID to begin at
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    limit (Optional[int] = None): Default: 100; Maximum: 5000

                Returns:
                    WebsocketApiResponse[TradesAggregateResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.trades_aggregate(
            symbol, id, from_id, start_time, end_time, limit
        )

    async def trades_historical(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        from_id: Optional[int] = None,
        limit: Optional[int] = None,
    ) -> WebsocketApiResponse[TradesHistoricalResponse]:
        """
                WebSocket Historical trades

                Get historical trades.
        Weight: 25

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    from_id (Optional[int] = None): Aggregate trade ID to begin at
                    limit (Optional[int] = None): Default: 100; Maximum: 5000

                Returns:
                    WebsocketApiResponse[TradesHistoricalResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.trades_historical(symbol, id, from_id, limit)

    async def trades_recent(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> WebsocketApiResponse[TradesRecentResponse]:
        """
                WebSocket Recent trades

                Get recent trades.

        If you need access to real-time trading activity, please consider using WebSocket Streams:

        * `<symbol>@trade`
        Weight: 25

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    limit (Optional[int] = None): Default: 100; Maximum: 5000

                Returns:
                    WebsocketApiResponse[TradesRecentResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.trades_recent(symbol, id, limit)

    async def ui_klines(
        self,
        symbol: Union[str, None],
        interval: Union[UiKlinesIntervalEnum, None],
        id: Optional[str] = None,
        start_time: Optional[int] = None,
        end_time: Optional[int] = None,
        time_zone: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> WebsocketApiResponse[UiKlinesResponse]:
        """
                WebSocket UI Klines

                Get klines (candlestick bars) optimized for presentation.

        This request is similar to `klines`, having the same parameters and response.
        `uiKlines` return modified kline data, optimized for presentation of candlestick charts.
        Weight: 2

                Args:
                    symbol (Union[str, None]):
                    interval (Union[UiKlinesIntervalEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    start_time (Optional[int] = None):
                    end_time (Optional[int] = None):
                    time_zone (Optional[str] = None): Default: 0 (UTC)
                    limit (Optional[int] = None): Default: 100; Maximum: 5000

                Returns:
                    WebsocketApiResponse[UiKlinesResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._marketApi.ui_klines(
            symbol, interval, id, start_time, end_time, time_zone, limit
        )

    async def open_orders_cancel_all(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OpenOrdersCancelAllResponse]:
        """
                WebSocket Cancel open orders

                Cancel all open orders on a symbol.
        This includes orders that are part of an order list.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OpenOrdersCancelAllResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.open_orders_cancel_all(symbol, id, recv_window)

    async def order_amend_keep_priority(
        self,
        symbol: Union[str, None],
        new_qty: Union[float, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderAmendKeepPriorityResponse]:
        """
                WebSocket Order Amend Keep Priority

                Reduce the quantity of an existing open order.

        This adds 0 orders to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.

        Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more.
        Weight: 4

                Args:
                    symbol (Union[str, None]):
                    new_qty (Union[float, None]): `newQty` must be greater than 0 and less than the order's quantity.
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    orig_client_order_id (Optional[str] = None): `orderId`or`origClientOrderId`mustbesent
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderAmendKeepPriorityResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_amend_keep_priority(
            symbol,
            new_qty,
            id,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            recv_window,
        )

    async def order_cancel(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        cancel_restrictions: Optional[OrderCancelCancelRestrictionsEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderCancelResponse]:
        """
                WebSocket Cancel order

                Cancel an active order.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    orig_client_order_id (Optional[str] = None): `orderId`or`origClientOrderId`mustbesent
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    cancel_restrictions (Optional[OrderCancelCancelRestrictionsEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderCancelResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_cancel(
            symbol,
            id,
            order_id,
            orig_client_order_id,
            new_client_order_id,
            cancel_restrictions,
            recv_window,
        )

    async def order_cancel_replace(
        self,
        symbol: Union[str, None],
        cancel_replace_mode: Union[OrderCancelReplaceCancelReplaceModeEnum, None],
        side: Union[OrderCancelReplaceSideEnum, None],
        type: Union[OrderCancelReplaceTypeEnum, None],
        id: Optional[str] = None,
        cancel_order_id: Optional[int] = None,
        cancel_orig_client_order_id: Optional[str] = None,
        cancel_new_client_order_id: Optional[str] = None,
        time_in_force: Optional[OrderCancelReplaceTimeInForceEnum] = None,
        price: Optional[float] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderCancelReplaceNewOrderRespTypeEnum] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[float] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            OrderCancelReplaceSelfTradePreventionModeEnum
        ] = None,
        cancel_restrictions: Optional[OrderCancelReplaceCancelRestrictionsEnum] = None,
        order_rate_limit_exceeded_mode: Optional[
            OrderCancelReplaceOrderRateLimitExceededModeEnum
        ] = None,
        peg_price_type: Optional[OrderCancelReplacePegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderCancelReplacePegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderCancelReplaceResponse]:
        """
                WebSocket Cancel and replace order

                Cancel an existing order and immediately place a new order instead of the canceled one.

        A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED`), will still increase the unfilled order count by 1.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    cancel_replace_mode (Union[OrderCancelReplaceCancelReplaceModeEnum, None]):
                    side (Union[OrderCancelReplaceSideEnum, None]):
                    type (Union[OrderCancelReplaceTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    cancel_order_id (Optional[int] = None): Cancel order by orderId
                    cancel_orig_client_order_id (Optional[str] = None):
                    cancel_new_client_order_id (Optional[str] = None): New ID for the canceled order. Automatically generated if not sent
                    time_in_force (Optional[OrderCancelReplaceTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[OrderCancelReplaceNewOrderRespTypeEnum] = None):
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[float] = None): See Trailing Stop order FAQ
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[OrderCancelReplaceSelfTradePreventionModeEnum] = None):
                    cancel_restrictions (Optional[OrderCancelReplaceCancelRestrictionsEnum] = None):
                    order_rate_limit_exceeded_mode (Optional[OrderCancelReplaceOrderRateLimitExceededModeEnum] = None):
                    peg_price_type (Optional[OrderCancelReplacePegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Price level to peg the price to (max: 100)
             See Pegged Orders
                    peg_offset_type (Optional[OrderCancelReplacePegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderCancelReplaceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_cancel_replace(
            symbol,
            cancel_replace_mode,
            side,
            type,
            id,
            cancel_order_id,
            cancel_orig_client_order_id,
            cancel_new_client_order_id,
            time_in_force,
            price,
            quantity,
            quote_order_qty,
            new_client_order_id,
            new_order_resp_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            cancel_restrictions,
            order_rate_limit_exceeded_mode,
            peg_price_type,
            peg_offset_value,
            peg_offset_type,
            recv_window,
        )

    async def order_list_cancel(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_list_id: Optional[int] = None,
        list_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListCancelResponse]:
        """
                WebSocket Cancel Order list

                Cancel an active order list.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_list_id (Optional[int] = None): Cancel order list by orderListId
                    list_client_order_id (Optional[str] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderListCancelResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_list_cancel(
            symbol,
            id,
            order_list_id,
            list_client_order_id,
            new_client_order_id,
            recv_window,
        )

    async def order_list_place(
        self,
        symbol: Union[str, None],
        side: Union[OrderListPlaceSideEnum, None],
        price: Union[float, None],
        quantity: Union[float, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        limit_client_order_id: Optional[str] = None,
        limit_iceberg_qty: Optional[float] = None,
        limit_strategy_id: Optional[int] = None,
        limit_strategy_type: Optional[int] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        stop_client_order_id: Optional[str] = None,
        stop_limit_price: Optional[float] = None,
        stop_limit_time_in_force: Optional[
            OrderListPlaceStopLimitTimeInForceEnum
        ] = None,
        stop_iceberg_qty: Optional[float] = None,
        stop_strategy_id: Optional[int] = None,
        stop_strategy_type: Optional[int] = None,
        new_order_resp_type: Optional[OrderListPlaceNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceResponse]:
        """
                WebSocket Place new OCO - Deprecated

                Send in a new one-cancels-the-other (OCO) pair:
        `LIMIT_MAKER` + `STOP_LOSS`/`STOP_LOSS_LIMIT` orders (called *legs*),
        where activation of one order immediately cancels the other.

        This adds 1 order to `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter
        Weight: 1

        Unfilled Order Count: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderListPlaceSideEnum, None]):
                    price (Union[float, None]): Price for the limit order
                    quantity (Union[float, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    limit_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the limit order. Automatically generated if not sent
                    limit_iceberg_qty (Optional[float] = None):
                    limit_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the limit order within an order strategy.
                    limit_strategy_type (Optional[int] = None): <p>Arbitrary numeric value identifying the limit order strategy.</p><p>Values smaller than `1000000` are reserved and cannot be used.</p>
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
                    stop_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the stop order. Automatically generated if not sent
                    stop_limit_price (Optional[float] = None):
                    stop_limit_time_in_force (Optional[OrderListPlaceStopLimitTimeInForceEnum] = None):
                    stop_iceberg_qty (Optional[float] = None):
                    stop_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the stop order within an order strategy.
                    stop_strategy_type (Optional[int] = None): <p>Arbitrary numeric value identifying the stop order strategy.</p><p>Values smaller than `1000000` are reserved and cannot be used.</p>
                    new_order_resp_type (Optional[OrderListPlaceNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderListPlaceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_list_place(
            symbol,
            side,
            price,
            quantity,
            id,
            list_client_order_id,
            limit_client_order_id,
            limit_iceberg_qty,
            limit_strategy_id,
            limit_strategy_type,
            stop_price,
            trailing_delta,
            stop_client_order_id,
            stop_limit_price,
            stop_limit_time_in_force,
            stop_iceberg_qty,
            stop_strategy_id,
            stop_strategy_type,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        )

    async def order_list_place_oco(
        self,
        symbol: Union[str, None],
        side: Union[OrderListPlaceOcoSideEnum, None],
        quantity: Union[float, None],
        above_type: Union[OrderListPlaceOcoAboveTypeEnum, None],
        below_type: Union[OrderListPlaceOcoBelowTypeEnum, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        above_client_order_id: Optional[str] = None,
        above_iceberg_qty: Optional[int] = None,
        above_price: Optional[float] = None,
        above_stop_price: Optional[float] = None,
        above_trailing_delta: Optional[int] = None,
        above_time_in_force: Optional[float] = None,
        above_strategy_id: Optional[int] = None,
        above_strategy_type: Optional[int] = None,
        above_peg_price_type: Optional[OrderListPlaceOcoAbovePegPriceTypeEnum] = None,
        above_peg_offset_type: Optional[OrderListPlaceOcoAbovePegOffsetTypeEnum] = None,
        above_peg_offset_value: Optional[int] = None,
        below_client_order_id: Optional[str] = None,
        below_iceberg_qty: Optional[int] = None,
        below_price: Optional[float] = None,
        below_stop_price: Optional[float] = None,
        below_trailing_delta: Optional[int] = None,
        below_time_in_force: Optional[OrderListPlaceOcoBelowTimeInForceEnum] = None,
        below_strategy_id: Optional[int] = None,
        below_strategy_type: Optional[int] = None,
        below_peg_price_type: Optional[OrderListPlaceOcoBelowPegPriceTypeEnum] = None,
        below_peg_offset_type: Optional[OrderListPlaceOcoBelowPegOffsetTypeEnum] = None,
        below_peg_offset_value: Optional[int] = None,
        new_order_resp_type: Optional[OrderListPlaceOcoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceOcoSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceOcoResponse]:
        """
                WebSocket Place new Order list - OCO

                Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.

        * An OCO has 2 orders called the **above order** and **below order**.
        * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
        * Price restrictions:
          * If the OCO is on the `SELL` side:
            * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
            * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
          * If the OCO is on the `BUY` side:
            * `LIMIT_MAKER` `price` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
            * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
        * OCOs add **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderListPlaceOcoSideEnum, None]):
                    quantity (Union[float, None]):
                    above_type (Union[OrderListPlaceOcoAboveTypeEnum, None]):
                    below_type (Union[OrderListPlaceOcoBelowTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
                    above_iceberg_qty (Optional[int] = None): Note that this can only be used if `aboveTimeInForce` is `GTC`.
                    above_price (Optional[float] = None): Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    above_stop_price (Optional[float] = None): Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
                    above_trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    above_time_in_force (Optional[float] = None): Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`.
                    above_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the above order within an order strategy.
                    above_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
                    above_peg_price_type (Optional[OrderListPlaceOcoAbovePegPriceTypeEnum] = None):
                    above_peg_offset_type (Optional[OrderListPlaceOcoAbovePegOffsetTypeEnum] = None):
                    above_peg_offset_value (Optional[int] = None):
                    below_client_order_id (Optional[str] = None):
                    below_iceberg_qty (Optional[int] = None): Note that this can only be used if `belowTimeInForce` is `GTC`.
                    below_price (Optional[float] = None): Can be used if `belowType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    below_stop_price (Optional[float] = None): Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT` or `TAKE_PROFIT_LIMIT`. <br>Either `belowStopPrice` or `belowTrailingDelta` or both, must be specified.
                    below_trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    below_time_in_force (Optional[OrderListPlaceOcoBelowTimeInForceEnum] = None):
                    below_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the below order within an order strategy.
                    below_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
                    below_peg_price_type (Optional[OrderListPlaceOcoBelowPegPriceTypeEnum] = None):
                    below_peg_offset_type (Optional[OrderListPlaceOcoBelowPegOffsetTypeEnum] = None):
                    below_peg_offset_value (Optional[int] = None):
                    new_order_resp_type (Optional[OrderListPlaceOcoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceOcoSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderListPlaceOcoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_list_place_oco(
            symbol,
            side,
            quantity,
            above_type,
            below_type,
            id,
            list_client_order_id,
            above_client_order_id,
            above_iceberg_qty,
            above_price,
            above_stop_price,
            above_trailing_delta,
            above_time_in_force,
            above_strategy_id,
            above_strategy_type,
            above_peg_price_type,
            above_peg_offset_type,
            above_peg_offset_value,
            below_client_order_id,
            below_iceberg_qty,
            below_price,
            below_stop_price,
            below_trailing_delta,
            below_time_in_force,
            below_strategy_id,
            below_strategy_type,
            below_peg_price_type,
            below_peg_offset_type,
            below_peg_offset_value,
            new_order_resp_type,
            self_trade_prevention_mode,
            recv_window,
        )

    async def order_list_place_oto(
        self,
        symbol: Union[str, None],
        working_type: Union[OrderListPlaceOtoWorkingTypeEnum, None],
        working_side: Union[OrderListPlaceOtoWorkingSideEnum, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_type: Union[OrderListPlaceOtoPendingTypeEnum, None],
        pending_side: Union[OrderListPlaceOtoPendingSideEnum, None],
        pending_quantity: Union[float, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderListPlaceOtoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceOtoSelfTradePreventionModeEnum
        ] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[OrderListPlaceOtoWorkingTimeInForceEnum] = None,
        working_strategy_id: Optional[int] = None,
        working_strategy_type: Optional[int] = None,
        working_peg_price_type: Optional[
            OrderListPlaceOtoWorkingPegPriceTypeEnum
        ] = None,
        working_peg_offset_type: Optional[
            OrderListPlaceOtoWorkingPegOffsetTypeEnum
        ] = None,
        working_peg_offset_value: Optional[int] = None,
        pending_client_order_id: Optional[str] = None,
        pending_price: Optional[float] = None,
        pending_stop_price: Optional[float] = None,
        pending_trailing_delta: Optional[float] = None,
        pending_iceberg_qty: Optional[float] = None,
        pending_time_in_force: Optional[OrderListPlaceOtoPendingTimeInForceEnum] = None,
        pending_strategy_id: Optional[int] = None,
        pending_strategy_type: Optional[int] = None,
        pending_peg_offset_type: Optional[
            OrderListPlaceOtoPendingPegOffsetTypeEnum
        ] = None,
        pending_peg_price_type: Optional[
            OrderListPlaceOtoPendingPegPriceTypeEnum
        ] = None,
        pending_peg_offset_value: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceOtoResponse]:
        """
                WebSocket Place new Order list - OTO

                Places an OTO.

        * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
        * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
        * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
        * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
        * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
        * OTOs add **2 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

                Args:
                    symbol (Union[str, None]):
                    working_type (Union[OrderListPlaceOtoWorkingTypeEnum, None]):
                    working_side (Union[OrderListPlaceOtoWorkingSideEnum, None]):
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]): Sets the quantity for the working order.
                    pending_type (Union[OrderListPlaceOtoPendingTypeEnum, None]):
                    pending_side (Union[OrderListPlaceOtoPendingSideEnum, None]):
                    pending_quantity (Union[float, None]): Sets the quantity for the pending order.
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    new_order_resp_type (Optional[OrderListPlaceOtoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceOtoSelfTradePreventionModeEnum] = None):
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
                    working_time_in_force (Optional[OrderListPlaceOtoWorkingTimeInForceEnum] = None):
                    working_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the working order within an order strategy.
                    working_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    working_peg_price_type (Optional[OrderListPlaceOtoWorkingPegPriceTypeEnum] = None):
                    working_peg_offset_type (Optional[OrderListPlaceOtoWorkingPegOffsetTypeEnum] = None):
                    working_peg_offset_value (Optional[int] = None):
                    pending_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
                    pending_price (Optional[float] = None):
                    pending_stop_price (Optional[float] = None):
                    pending_trailing_delta (Optional[float] = None):
                    pending_iceberg_qty (Optional[float] = None): This can only be used if `pendingTimeInForce` is `GTC`, or if `pendingType` is `LIMIT_MAKER`.
                    pending_time_in_force (Optional[OrderListPlaceOtoPendingTimeInForceEnum] = None):
                    pending_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending order within an order strategy.
                    pending_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_peg_offset_type (Optional[OrderListPlaceOtoPendingPegOffsetTypeEnum] = None):
                    pending_peg_price_type (Optional[OrderListPlaceOtoPendingPegPriceTypeEnum] = None):
                    pending_peg_offset_value (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderListPlaceOtoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_list_place_oto(
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_type,
            pending_side,
            pending_quantity,
            id,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            working_peg_price_type,
            working_peg_offset_type,
            working_peg_offset_value,
            pending_client_order_id,
            pending_price,
            pending_stop_price,
            pending_trailing_delta,
            pending_iceberg_qty,
            pending_time_in_force,
            pending_strategy_id,
            pending_strategy_type,
            pending_peg_offset_type,
            pending_peg_price_type,
            pending_peg_offset_value,
            recv_window,
        )

    async def order_list_place_otoco(
        self,
        symbol: Union[str, None],
        working_type: Union[OrderListPlaceOtocoWorkingTypeEnum, None],
        working_side: Union[OrderListPlaceOtocoWorkingSideEnum, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_side: Union[OrderListPlaceOtocoPendingSideEnum, None],
        pending_quantity: Union[float, None],
        pending_above_type: Union[OrderListPlaceOtocoPendingAboveTypeEnum, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderListPlaceOtocoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceOtocoSelfTradePreventionModeEnum
        ] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[
            OrderListPlaceOtocoWorkingTimeInForceEnum
        ] = None,
        working_strategy_id: Optional[int] = None,
        working_strategy_type: Optional[int] = None,
        working_peg_price_type: Optional[
            OrderListPlaceOtocoWorkingPegPriceTypeEnum
        ] = None,
        working_peg_offset_type: Optional[
            OrderListPlaceOtocoWorkingPegOffsetTypeEnum
        ] = None,
        working_peg_offset_value: Optional[int] = None,
        pending_above_client_order_id: Optional[str] = None,
        pending_above_price: Optional[float] = None,
        pending_above_stop_price: Optional[float] = None,
        pending_above_trailing_delta: Optional[float] = None,
        pending_above_iceberg_qty: Optional[float] = None,
        pending_above_time_in_force: Optional[
            OrderListPlaceOtocoPendingAboveTimeInForceEnum
        ] = None,
        pending_above_strategy_id: Optional[int] = None,
        pending_above_strategy_type: Optional[int] = None,
        pending_above_peg_price_type: Optional[
            OrderListPlaceOtocoPendingAbovePegPriceTypeEnum
        ] = None,
        pending_above_peg_offset_type: Optional[
            OrderListPlaceOtocoPendingAbovePegOffsetTypeEnum
        ] = None,
        pending_above_peg_offset_value: Optional[int] = None,
        pending_below_type: Optional[OrderListPlaceOtocoPendingBelowTypeEnum] = None,
        pending_below_client_order_id: Optional[str] = None,
        pending_below_price: Optional[float] = None,
        pending_below_stop_price: Optional[float] = None,
        pending_below_trailing_delta: Optional[float] = None,
        pending_below_iceberg_qty: Optional[float] = None,
        pending_below_time_in_force: Optional[
            OrderListPlaceOtocoPendingBelowTimeInForceEnum
        ] = None,
        pending_below_strategy_id: Optional[int] = None,
        pending_below_strategy_type: Optional[int] = None,
        pending_below_peg_price_type: Optional[
            OrderListPlaceOtocoPendingBelowPegPriceTypeEnum
        ] = None,
        pending_below_peg_offset_type: Optional[
            OrderListPlaceOtocoPendingBelowPegOffsetTypeEnum
        ] = None,
        pending_below_peg_offset_value: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceOtocoResponse]:
        """
                WebSocket Place new Order list - OTOCO

                Place an OTOCO.

        * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
        * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
          * The behavior of the working order is the same as the [OTO](#place-new-order-list---oto-trade).
        * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
            * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
        * OTOCOs add **3 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 3

                Args:
                    symbol (Union[str, None]):
                    working_type (Union[OrderListPlaceOtocoWorkingTypeEnum, None]):
                    working_side (Union[OrderListPlaceOtocoWorkingSideEnum, None]):
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]): Sets the quantity for the working order.
                    pending_side (Union[OrderListPlaceOtocoPendingSideEnum, None]):
                    pending_quantity (Union[float, None]): Sets the quantity for the pending order.
                    pending_above_type (Union[OrderListPlaceOtocoPendingAboveTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    new_order_resp_type (Optional[OrderListPlaceOtocoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceOtocoSelfTradePreventionModeEnum] = None):
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
                    working_time_in_force (Optional[OrderListPlaceOtocoWorkingTimeInForceEnum] = None):
                    working_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the working order within an order strategy.
                    working_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    working_peg_price_type (Optional[OrderListPlaceOtocoWorkingPegPriceTypeEnum] = None):
                    working_peg_offset_type (Optional[OrderListPlaceOtocoWorkingPegOffsetTypeEnum] = None):
                    working_peg_offset_value (Optional[int] = None):
                    pending_above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
                    pending_above_price (Optional[float] = None): Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    pending_above_stop_price (Optional[float] = None): Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
                    pending_above_trailing_delta (Optional[float] = None): See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
                    pending_above_iceberg_qty (Optional[float] = None): This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
                    pending_above_time_in_force (Optional[OrderListPlaceOtocoPendingAboveTimeInForceEnum] = None):
                    pending_above_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending above order within an order strategy.
                    pending_above_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_above_peg_price_type (Optional[OrderListPlaceOtocoPendingAbovePegPriceTypeEnum] = None):
                    pending_above_peg_offset_type (Optional[OrderListPlaceOtocoPendingAbovePegOffsetTypeEnum] = None):
                    pending_above_peg_offset_value (Optional[int] = None):
                    pending_below_type (Optional[OrderListPlaceOtocoPendingBelowTypeEnum] = None):
                    pending_below_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
                    pending_below_price (Optional[float] = None): Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    pending_below_stop_price (Optional[float] = None): Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
                    pending_below_trailing_delta (Optional[float] = None):
                    pending_below_iceberg_qty (Optional[float] = None): This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
                    pending_below_time_in_force (Optional[OrderListPlaceOtocoPendingBelowTimeInForceEnum] = None):
                    pending_below_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending below order within an order strategy.
                    pending_below_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_below_peg_price_type (Optional[OrderListPlaceOtocoPendingBelowPegPriceTypeEnum] = None):
                    pending_below_peg_offset_type (Optional[OrderListPlaceOtocoPendingBelowPegOffsetTypeEnum] = None):
                    pending_below_peg_offset_value (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderListPlaceOtocoResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_list_place_otoco(
            symbol,
            working_type,
            working_side,
            working_price,
            working_quantity,
            pending_side,
            pending_quantity,
            pending_above_type,
            id,
            list_client_order_id,
            new_order_resp_type,
            self_trade_prevention_mode,
            working_client_order_id,
            working_iceberg_qty,
            working_time_in_force,
            working_strategy_id,
            working_strategy_type,
            working_peg_price_type,
            working_peg_offset_type,
            working_peg_offset_value,
            pending_above_client_order_id,
            pending_above_price,
            pending_above_stop_price,
            pending_above_trailing_delta,
            pending_above_iceberg_qty,
            pending_above_time_in_force,
            pending_above_strategy_id,
            pending_above_strategy_type,
            pending_above_peg_price_type,
            pending_above_peg_offset_type,
            pending_above_peg_offset_value,
            pending_below_type,
            pending_below_client_order_id,
            pending_below_price,
            pending_below_stop_price,
            pending_below_trailing_delta,
            pending_below_iceberg_qty,
            pending_below_time_in_force,
            pending_below_strategy_id,
            pending_below_strategy_type,
            pending_below_peg_price_type,
            pending_below_peg_offset_type,
            pending_below_peg_offset_value,
            recv_window,
        )

    async def order_place(
        self,
        symbol: Union[str, None],
        side: Union[OrderPlaceSideEnum, None],
        type: Union[OrderPlaceTypeEnum, None],
        id: Optional[str] = None,
        time_in_force: Optional[OrderPlaceTimeInForceEnum] = None,
        price: Optional[float] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderPlaceNewOrderRespTypeEnum] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            OrderPlaceSelfTradePreventionModeEnum
        ] = None,
        peg_price_type: Optional[OrderPlacePegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderPlacePegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderPlaceResponse]:
        """
                WebSocket Place new order

                Send in a new order.

        This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
        Weight: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderPlaceSideEnum, None]):
                    type (Union[OrderPlaceTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    time_in_force (Optional[OrderPlaceTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[OrderPlaceNewOrderRespTypeEnum] = None):
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[OrderPlaceSelfTradePreventionModeEnum] = None):
                    peg_price_type (Optional[OrderPlacePegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Price level to peg the price to (max: 100)
             See Pegged Orders
                    peg_offset_type (Optional[OrderPlacePegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderPlaceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_place(
            symbol,
            side,
            type,
            id,
            time_in_force,
            price,
            quantity,
            quote_order_qty,
            new_client_order_id,
            new_order_resp_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            peg_price_type,
            peg_offset_value,
            peg_offset_type,
            recv_window,
        )

    async def order_test(
        self,
        symbol: Union[str, None],
        side: Union[OrderTestSideEnum, None],
        type: Union[OrderTestTypeEnum, None],
        id: Optional[str] = None,
        compute_commission_rates: Optional[bool] = None,
        time_in_force: Optional[OrderTestTimeInForceEnum] = None,
        price: Optional[float] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderTestNewOrderRespTypeEnum] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            OrderTestSelfTradePreventionModeEnum
        ] = None,
        peg_price_type: Optional[OrderTestPegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderTestPegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderTestResponse]:
        """
                WebSocket Test new order

                Test order placement.

        Validates new order parameters and verifies your signature
        but does not send the order into the matching engine.
        Weight: |Condition| Request Weight|
        |------------           | ------------ |
        |Without `computeCommissionRates`| 1|
        |With `computeCommissionRates`|20|

                Args:
                    symbol (Union[str, None]):
                    side (Union[OrderTestSideEnum, None]):
                    type (Union[OrderTestTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    compute_commission_rates (Optional[bool] = None): Default: `false` <br> See [Commissions FAQ](faqs/commission_faq.md#test-order-diferences) to learn more.
                    time_in_force (Optional[OrderTestTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[OrderTestNewOrderRespTypeEnum] = None):
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[OrderTestSelfTradePreventionModeEnum] = None):
                    peg_price_type (Optional[OrderTestPegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Price level to peg the price to (max: 100)
             See Pegged Orders
                    peg_offset_type (Optional[OrderTestPegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[OrderTestResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.order_test(
            symbol,
            side,
            type,
            id,
            compute_commission_rates,
            time_in_force,
            price,
            quantity,
            quote_order_qty,
            new_client_order_id,
            new_order_resp_type,
            stop_price,
            trailing_delta,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            peg_price_type,
            peg_offset_value,
            peg_offset_type,
            recv_window,
        )

    async def sor_order_place(
        self,
        symbol: Union[str, None],
        side: Union[SorOrderPlaceSideEnum, None],
        type: Union[SorOrderPlaceTypeEnum, None],
        quantity: Union[float, None],
        id: Optional[str] = None,
        time_in_force: Optional[SorOrderPlaceTimeInForceEnum] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[SorOrderPlaceNewOrderRespTypeEnum] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            SorOrderPlaceSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[SorOrderPlaceResponse]:
        """
                WebSocket Place new order using SOR

                Places an order using smart order routing (SOR).

        This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.

        Read [SOR FAQ](../faqs/sor_faq.md) to learn more.
        Weight: 1

        Unfilled Order Count: 1

                Args:
                    symbol (Union[str, None]):
                    side (Union[SorOrderPlaceSideEnum, None]):
                    type (Union[SorOrderPlaceTypeEnum, None]):
                    quantity (Union[float, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    time_in_force (Optional[SorOrderPlaceTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[SorOrderPlaceNewOrderRespTypeEnum] = None):
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[SorOrderPlaceSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[SorOrderPlaceResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.sor_order_place(
            symbol,
            side,
            type,
            quantity,
            id,
            time_in_force,
            price,
            new_client_order_id,
            new_order_resp_type,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            recv_window,
        )

    async def sor_order_test(
        self,
        symbol: Union[str, None],
        side: Union[SorOrderTestSideEnum, None],
        type: Union[SorOrderTestTypeEnum, None],
        quantity: Union[float, None],
        id: Optional[str] = None,
        compute_commission_rates: Optional[bool] = None,
        time_in_force: Optional[SorOrderTestTimeInForceEnum] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[SorOrderTestNewOrderRespTypeEnum] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            SorOrderTestSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[SorOrderTestResponse]:
        """
                WebSocket Test new order using SOR

                Test new order creation and signature/recvWindow using smart order routing (SOR).
        Creates and validates a new order but does not send it into the matching engine.
        Weight: |Condition                       | Request Weight|
        |------------                    | ------------ |
        |Without `computeCommissionRates`| 1            |
        |With `computeCommissionRates`   |20            |

                Args:
                    symbol (Union[str, None]):
                    side (Union[SorOrderTestSideEnum, None]):
                    type (Union[SorOrderTestTypeEnum, None]):
                    quantity (Union[float, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    compute_commission_rates (Optional[bool] = None): Default: `false` <br> See [Commissions FAQ](faqs/commission_faq.md#test-order-diferences) to learn more.
                    time_in_force (Optional[SorOrderTestTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[SorOrderTestNewOrderRespTypeEnum] = None):
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[SorOrderTestSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

                Returns:
                    WebsocketApiResponse[SorOrderTestResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._tradeApi.sor_order_test(
            symbol,
            side,
            type,
            quantity,
            id,
            compute_commission_rates,
            time_in_force,
            price,
            new_client_order_id,
            new_order_resp_type,
            iceberg_qty,
            strategy_id,
            strategy_type,
            self_trade_prevention_mode,
            recv_window,
        )

    async def session_subscriptions(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[SessionSubscriptionsResponse]:
        """
                WebSocket Listing all subscriptions


        Weight: 2

        **Data Source**:
        Memory

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[SessionSubscriptionsResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._userDataStreamApi.session_subscriptions(id)

    async def user_data_stream_ping(
        self,
        listen_key: Union[str, None],
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[UserDataStreamPingResponse]:
        """
                WebSocket Ping user data stream

                Ping a user data stream to keep it alive.

        User data streams close automatically after 60 minutes,
        even if you're listening to them on WebSocket Streams.
        In order to keep the stream open, you have to regularly send pings using the `userDataStream.ping` request.

        It is recommended to send a ping once every 30 minutes.

        This request does not require `signature`.
        Weight: 2

                Args:
                    listen_key (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[UserDataStreamPingResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._userDataStreamApi.user_data_stream_ping(listen_key, id)

    async def user_data_stream_start(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[UserDataStreamStartResponse]:
        """
                WebSocket Start user data stream

                Start a new user data stream.
        Note the stream will close in 60 minutes unless `userDataStream.ping` requests are sent regularly.
        This request does not require `signature`.
        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[UserDataStreamStartResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._userDataStreamApi.user_data_stream_start(id)

    async def user_data_stream_stop(
        self,
        listen_key: Union[str, None],
        id: Optional[str] = None,
    ) -> WebsocketApiResponse[UserDataStreamStopResponse]:
        """
                WebSocket Stop user data stream

                Explicitly stop and close the user data stream.
        This request does not require `signature`.
        Weight: 2

                Args:
                    listen_key (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiResponse[UserDataStreamStopResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._userDataStreamApi.user_data_stream_stop(listen_key, id)

    async def user_data_stream_subscribe(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiUserDataStreamResponse[
        WebsocketApiResponse[UserDataStreamSubscribeResponse], RequestStreamHandle
    ]:
        """
                WebSocket Subscribe to User Data Stream

                Subscribe to the User Data Stream in the current WebSocket connection.
        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiUserDataStreamResponse[WebsocketApiResponse[UserDataStreamSubscribeResponse], RequestStreamHandle]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        response = await self._userDataStreamApi.user_data_stream_subscribe(id)
        data = response.data()
        stream = await RequestStream(
            self,
            data.result.subscriptionId,
            response_model=UserDataStreamEventsResponse,
        )
        return WebsocketApiUserDataStreamResponse(response=response, stream=stream)

    async def user_data_stream_subscribe_signature(
        self,
        id: Optional[str] = None,
    ) -> WebsocketApiUserDataStreamResponse[
        WebsocketApiResponse[UserDataStreamSubscribeSignatureResponse],
        RequestStreamHandle,
    ]:
        """
                WebSocket Subscribe to User Data Stream through signature subscription


        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.

                Returns:
                    WebsocketApiUserDataStreamResponse[WebsocketApiResponse[UserDataStreamSubscribeSignatureResponse], RequestStreamHandle]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        response = await self._userDataStreamApi.user_data_stream_subscribe_signature(
            id
        )
        data = response.data()
        stream = await RequestStream(
            self,
            data.result.subscriptionId,
            response_model=UserDataStreamEventsResponse,
        )
        return WebsocketApiUserDataStreamResponse(response=response, stream=stream)

    async def user_data_stream_unsubscribe(
        self,
        id: Optional[str] = None,
        subscription_id: Optional[int] = None,
    ) -> WebsocketApiResponse[UserDataStreamUnsubscribeResponse]:
        """
                WebSocket Unsubscribe from User Data Stream

                Stop listening to the User Data Stream in the current WebSocket connection.

        Note that `session.logout` will only close the subscription created with `userdataStream.subscribe` but not subscriptions opened with `userDataStream.subscribe.signature`.
        Weight: 2

                Args:
                    id (Optional[str] = None): Unique WebSocket request ID.
                    subscription_id (Optional[int] = None): When called with no parameter, this will close all subscriptions. <br>When called with the `subscriptionId` parameter, this will attempt to close the subscription with that subscription id, if it exists.

                Returns:
                    WebsocketApiResponse[UserDataStreamUnsubscribeResponse]

                Raises:
                    RequiredError: If a required parameter is missing.

        """

        return await self._userDataStreamApi.user_data_stream_unsubscribe(
            id, subscription_id
        )
