"""
Binance Spot WebSocket API

OpenAPI Specifications for the Binance Spot WebSocket API

API documents:
  - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)
  - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from binance_common.errors import RequiredError
from binance_common.models import WebsocketApiResponse
from binance_common.signature import Signers
from binance_common.websocket import WebSocketAPIBase

from ..models import OpenOrdersCancelAllResponse
from ..models import OrderAmendKeepPriorityResponse
from ..models import OrderCancelResponse
from ..models import OrderCancelReplaceResponse
from ..models import OrderListCancelResponse
from ..models import OrderListPlaceResponse
from ..models import OrderListPlaceOcoResponse
from ..models import OrderListPlaceOtoResponse
from ..models import OrderListPlaceOtocoResponse
from ..models import OrderPlaceResponse
from ..models import OrderTestResponse
from ..models import SorOrderPlaceResponse
from ..models import SorOrderTestResponse


from ..models import OrderCancelCancelRestrictionsEnum
from ..models import OrderCancelReplaceCancelReplaceModeEnum
from ..models import OrderCancelReplaceSideEnum
from ..models import OrderCancelReplaceTypeEnum
from ..models import OrderCancelReplaceTimeInForceEnum
from ..models import OrderCancelReplaceNewOrderRespTypeEnum
from ..models import OrderCancelReplaceSelfTradePreventionModeEnum
from ..models import OrderCancelReplaceCancelRestrictionsEnum
from ..models import OrderCancelReplaceOrderRateLimitExceededModeEnum
from ..models import OrderCancelReplacePegPriceTypeEnum
from ..models import OrderCancelReplacePegOffsetTypeEnum
from ..models import OrderListPlaceSideEnum
from ..models import OrderListPlaceStopLimitTimeInForceEnum
from ..models import OrderListPlaceNewOrderRespTypeEnum
from ..models import OrderListPlaceSelfTradePreventionModeEnum
from ..models import OrderListPlaceOcoSideEnum
from ..models import OrderListPlaceOcoAboveTypeEnum
from ..models import OrderListPlaceOcoBelowTypeEnum
from ..models import OrderListPlaceOcoAbovePegPriceTypeEnum
from ..models import OrderListPlaceOcoAbovePegOffsetTypeEnum
from ..models import OrderListPlaceOcoBelowTimeInForceEnum
from ..models import OrderListPlaceOcoBelowPegPriceTypeEnum
from ..models import OrderListPlaceOcoBelowPegOffsetTypeEnum
from ..models import OrderListPlaceOcoNewOrderRespTypeEnum
from ..models import OrderListPlaceOcoSelfTradePreventionModeEnum
from ..models import OrderListPlaceOtoWorkingTypeEnum
from ..models import OrderListPlaceOtoWorkingSideEnum
from ..models import OrderListPlaceOtoPendingTypeEnum
from ..models import OrderListPlaceOtoPendingSideEnum
from ..models import OrderListPlaceOtoNewOrderRespTypeEnum
from ..models import OrderListPlaceOtoSelfTradePreventionModeEnum
from ..models import OrderListPlaceOtoWorkingTimeInForceEnum
from ..models import OrderListPlaceOtoWorkingPegPriceTypeEnum
from ..models import OrderListPlaceOtoWorkingPegOffsetTypeEnum
from ..models import OrderListPlaceOtoPendingTimeInForceEnum
from ..models import OrderListPlaceOtoPendingPegOffsetTypeEnum
from ..models import OrderListPlaceOtoPendingPegPriceTypeEnum
from ..models import OrderListPlaceOtocoWorkingTypeEnum
from ..models import OrderListPlaceOtocoWorkingSideEnum
from ..models import OrderListPlaceOtocoPendingSideEnum
from ..models import OrderListPlaceOtocoPendingAboveTypeEnum
from ..models import OrderListPlaceOtocoNewOrderRespTypeEnum
from ..models import OrderListPlaceOtocoSelfTradePreventionModeEnum
from ..models import OrderListPlaceOtocoWorkingTimeInForceEnum
from ..models import OrderListPlaceOtocoWorkingPegPriceTypeEnum
from ..models import OrderListPlaceOtocoWorkingPegOffsetTypeEnum
from ..models import OrderListPlaceOtocoPendingAboveTimeInForceEnum
from ..models import OrderListPlaceOtocoPendingAbovePegPriceTypeEnum
from ..models import OrderListPlaceOtocoPendingAbovePegOffsetTypeEnum
from ..models import OrderListPlaceOtocoPendingBelowTypeEnum
from ..models import OrderListPlaceOtocoPendingBelowTimeInForceEnum
from ..models import OrderListPlaceOtocoPendingBelowPegPriceTypeEnum
from ..models import OrderListPlaceOtocoPendingBelowPegOffsetTypeEnum
from ..models import OrderPlaceSideEnum
from ..models import OrderPlaceTypeEnum
from ..models import OrderPlaceTimeInForceEnum
from ..models import OrderPlaceNewOrderRespTypeEnum
from ..models import OrderPlaceSelfTradePreventionModeEnum
from ..models import OrderPlacePegPriceTypeEnum
from ..models import OrderPlacePegOffsetTypeEnum
from ..models import OrderTestSideEnum
from ..models import OrderTestTypeEnum
from ..models import OrderTestTimeInForceEnum
from ..models import OrderTestNewOrderRespTypeEnum
from ..models import OrderTestSelfTradePreventionModeEnum
from ..models import OrderTestPegPriceTypeEnum
from ..models import OrderTestPegOffsetTypeEnum
from ..models import SorOrderPlaceSideEnum
from ..models import SorOrderPlaceTypeEnum
from ..models import SorOrderPlaceTimeInForceEnum
from ..models import SorOrderPlaceNewOrderRespTypeEnum
from ..models import SorOrderPlaceSelfTradePreventionModeEnum
from ..models import SorOrderTestSideEnum
from ..models import SorOrderTestTypeEnum
from ..models import SorOrderTestTimeInForceEnum
from ..models import SorOrderTestNewOrderRespTypeEnum
from ..models import SorOrderTestSelfTradePreventionModeEnum

from typing import Optional, Union


class TradeApi:
    """API Client for TradeApi endpoints."""

    def __init__(
        self,
        websocket_api: WebSocketAPIBase,
        signer: Signers = None,
    ) -> None:
        self.websocket_api = websocket_api
        self.signer = signer

    async def open_orders_cancel_all(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OpenOrdersCancelAllResponse]:
        """
            WebSocket Cancel open orders
            /openOrders.cancelAll
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-open-orders-trade

            Cancel all open orders on a symbol.
        This includes orders that are part of an order list.
        Weight: 1

            Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OpenOrdersCancelAllResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )

        params = {
            "symbol": symbol,
            **({"id": id} if id is not None else {}),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/openOrders.cancelAll".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload,
            response_model=OpenOrdersCancelAllResponse,
            signer=self.signer,
        )

    async def order_amend_keep_priority(
        self,
        symbol: Union[str, None],
        new_qty: Union[float, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderAmendKeepPriorityResponse]:
        """
            WebSocket Order Amend Keep Priority
            /order.amend.keepPriority
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-amend-keep-priority-trade

            Reduce the quantity of an existing open order.

        This adds 0 orders to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.

        Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more.
        Weight: 4

            Args:
                    symbol (Union[str, None]):
                    new_qty (Union[float, None]): `newQty` must be greater than 0 and less than the order's quantity.
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    orig_client_order_id (Optional[str] = None): `orderId`or`origClientOrderId`mustbesent
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderAmendKeepPriorityResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if new_qty is None:
            raise RequiredError(
                field="new_qty", error_message="Missing required parameter 'new_qty'"
            )

        params = {
            "symbol": symbol,
            "new_qty": new_qty,
            **({"id": id} if id is not None else {}),
            **({"order_id": order_id} if order_id is not None else {}),
            **(
                {"orig_client_order_id": orig_client_order_id}
                if orig_client_order_id is not None
                else {}
            ),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/order.amend.keepPriority".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload,
            response_model=OrderAmendKeepPriorityResponse,
            signer=self.signer,
        )

    async def order_cancel(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_id: Optional[int] = None,
        orig_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        cancel_restrictions: Optional[OrderCancelCancelRestrictionsEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderCancelResponse]:
        """
            WebSocket Cancel order
            /order.cancel
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-trade

            Cancel an active order.
        Weight: 1

            Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_id (Optional[int] = None): `orderId`or`origClientOrderId`mustbesent
                    orig_client_order_id (Optional[str] = None): `orderId`or`origClientOrderId`mustbesent
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    cancel_restrictions (Optional[OrderCancelCancelRestrictionsEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderCancelResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )

        params = {
            "symbol": symbol,
            **({"id": id} if id is not None else {}),
            **({"order_id": order_id} if order_id is not None else {}),
            **(
                {"orig_client_order_id": orig_client_order_id}
                if orig_client_order_id is not None
                else {}
            ),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **(
                {"cancel_restrictions": cancel_restrictions}
                if cancel_restrictions is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/order.cancel".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=OrderCancelResponse, signer=self.signer
        )

    async def order_cancel_replace(
        self,
        symbol: Union[str, None],
        cancel_replace_mode: Union[OrderCancelReplaceCancelReplaceModeEnum, None],
        side: Union[OrderCancelReplaceSideEnum, None],
        type: Union[OrderCancelReplaceTypeEnum, None],
        id: Optional[str] = None,
        cancel_order_id: Optional[int] = None,
        cancel_orig_client_order_id: Optional[str] = None,
        cancel_new_client_order_id: Optional[str] = None,
        time_in_force: Optional[OrderCancelReplaceTimeInForceEnum] = None,
        price: Optional[float] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderCancelReplaceNewOrderRespTypeEnum] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[float] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            OrderCancelReplaceSelfTradePreventionModeEnum
        ] = None,
        cancel_restrictions: Optional[OrderCancelReplaceCancelRestrictionsEnum] = None,
        order_rate_limit_exceeded_mode: Optional[
            OrderCancelReplaceOrderRateLimitExceededModeEnum
        ] = None,
        peg_price_type: Optional[OrderCancelReplacePegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderCancelReplacePegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderCancelReplaceResponse]:
        """
            WebSocket Cancel and replace order
            /order.cancelReplace
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-and-replace-order-trade

            Cancel an existing order and immediately place a new order instead of the canceled one.

        A new order that was not attempted (i.e. when `newOrderResult: NOT_ATTEMPTED`), will still increase the unfilled order count by 1.
        Weight: 1

            Args:
                    symbol (Union[str, None]):
                    cancel_replace_mode (Union[OrderCancelReplaceCancelReplaceModeEnum, None]):
                    side (Union[OrderCancelReplaceSideEnum, None]):
                    type (Union[OrderCancelReplaceTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    cancel_order_id (Optional[int] = None): Cancel order by orderId
                    cancel_orig_client_order_id (Optional[str] = None):
                    cancel_new_client_order_id (Optional[str] = None): New ID for the canceled order. Automatically generated if not sent
                    time_in_force (Optional[OrderCancelReplaceTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[OrderCancelReplaceNewOrderRespTypeEnum] = None):
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[float] = None): See Trailing Stop order FAQ
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[OrderCancelReplaceSelfTradePreventionModeEnum] = None):
                    cancel_restrictions (Optional[OrderCancelReplaceCancelRestrictionsEnum] = None):
                    order_rate_limit_exceeded_mode (Optional[OrderCancelReplaceOrderRateLimitExceededModeEnum] = None):
                    peg_price_type (Optional[OrderCancelReplacePegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Price level to peg the price to (max: 100)
             See Pegged Orders
                    peg_offset_type (Optional[OrderCancelReplacePegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderCancelReplaceResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if cancel_replace_mode is None:
            raise RequiredError(
                field="cancel_replace_mode",
                error_message="Missing required parameter 'cancel_replace_mode'",
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if type is None:
            raise RequiredError(
                field="type", error_message="Missing required parameter 'type'"
            )

        params = {
            "symbol": symbol,
            "cancel_replace_mode": cancel_replace_mode,
            "side": side,
            "type": type,
            **({"id": id} if id is not None else {}),
            **(
                {"cancel_order_id": cancel_order_id}
                if cancel_order_id is not None
                else {}
            ),
            **(
                {"cancel_orig_client_order_id": cancel_orig_client_order_id}
                if cancel_orig_client_order_id is not None
                else {}
            ),
            **(
                {"cancel_new_client_order_id": cancel_new_client_order_id}
                if cancel_new_client_order_id is not None
                else {}
            ),
            **({"time_in_force": time_in_force} if time_in_force is not None else {}),
            **({"price": price} if price is not None else {}),
            **({"quantity": quantity} if quantity is not None else {}),
            **(
                {"quote_order_qty": quote_order_qty}
                if quote_order_qty is not None
                else {}
            ),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **({"stop_price": stop_price} if stop_price is not None else {}),
            **(
                {"trailing_delta": trailing_delta} if trailing_delta is not None else {}
            ),
            **({"iceberg_qty": iceberg_qty} if iceberg_qty is not None else {}),
            **({"strategy_id": strategy_id} if strategy_id is not None else {}),
            **({"strategy_type": strategy_type} if strategy_type is not None else {}),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **(
                {"cancel_restrictions": cancel_restrictions}
                if cancel_restrictions is not None
                else {}
            ),
            **(
                {"order_rate_limit_exceeded_mode": order_rate_limit_exceeded_mode}
                if order_rate_limit_exceeded_mode is not None
                else {}
            ),
            **(
                {"peg_price_type": peg_price_type} if peg_price_type is not None else {}
            ),
            **(
                {"peg_offset_value": peg_offset_value}
                if peg_offset_value is not None
                else {}
            ),
            **(
                {"peg_offset_type": peg_offset_type}
                if peg_offset_type is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/order.cancelReplace".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload,
            response_model=OrderCancelReplaceResponse,
            signer=self.signer,
        )

    async def order_list_cancel(
        self,
        symbol: Union[str, None],
        id: Optional[str] = None,
        order_list_id: Optional[int] = None,
        list_client_order_id: Optional[str] = None,
        new_client_order_id: Optional[str] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListCancelResponse]:
        """
            WebSocket Cancel Order list
            /orderList.cancel
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-list-trade

            Cancel an active order list.
        Weight: 1

            Args:
                    symbol (Union[str, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    order_list_id (Optional[int] = None): Cancel order list by orderListId
                    list_client_order_id (Optional[str] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderListCancelResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )

        params = {
            "symbol": symbol,
            **({"id": id} if id is not None else {}),
            **({"order_list_id": order_list_id} if order_list_id is not None else {}),
            **(
                {"list_client_order_id": list_client_order_id}
                if list_client_order_id is not None
                else {}
            ),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/orderList.cancel".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=OrderListCancelResponse, signer=self.signer
        )

    async def order_list_place(
        self,
        symbol: Union[str, None],
        side: Union[OrderListPlaceSideEnum, None],
        price: Union[float, None],
        quantity: Union[float, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        limit_client_order_id: Optional[str] = None,
        limit_iceberg_qty: Optional[float] = None,
        limit_strategy_id: Optional[int] = None,
        limit_strategy_type: Optional[int] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        stop_client_order_id: Optional[str] = None,
        stop_limit_price: Optional[float] = None,
        stop_limit_time_in_force: Optional[
            OrderListPlaceStopLimitTimeInForceEnum
        ] = None,
        stop_iceberg_qty: Optional[float] = None,
        stop_strategy_id: Optional[int] = None,
        stop_strategy_type: Optional[int] = None,
        new_order_resp_type: Optional[OrderListPlaceNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceResponse]:
        """
            WebSocket Place new OCO - Deprecated
            /orderList.place
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-oco---deprecated-trade

            Send in a new one-cancels-the-other (OCO) pair:
        `LIMIT_MAKER` + `STOP_LOSS`/`STOP_LOSS_LIMIT` orders (called *legs*),
        where activation of one order immediately cancels the other.

        This adds 1 order to `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter
        Weight: 1

        Unfilled Order Count: 1

            Args:
                    symbol (Union[str, None]):
                    side (Union[OrderListPlaceSideEnum, None]):
                    price (Union[float, None]): Price for the limit order
                    quantity (Union[float, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    limit_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the limit order. Automatically generated if not sent
                    limit_iceberg_qty (Optional[float] = None):
                    limit_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the limit order within an order strategy.
                    limit_strategy_type (Optional[int] = None): <p>Arbitrary numeric value identifying the limit order strategy.</p><p>Values smaller than `1000000` are reserved and cannot be used.</p>
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
                    stop_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the stop order. Automatically generated if not sent
                    stop_limit_price (Optional[float] = None):
                    stop_limit_time_in_force (Optional[OrderListPlaceStopLimitTimeInForceEnum] = None):
                    stop_iceberg_qty (Optional[float] = None):
                    stop_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the stop order within an order strategy.
                    stop_strategy_type (Optional[int] = None): <p>Arbitrary numeric value identifying the stop order strategy.</p><p>Values smaller than `1000000` are reserved and cannot be used.</p>
                    new_order_resp_type (Optional[OrderListPlaceNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderListPlaceResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if price is None:
            raise RequiredError(
                field="price", error_message="Missing required parameter 'price'"
            )
        if quantity is None:
            raise RequiredError(
                field="quantity", error_message="Missing required parameter 'quantity'"
            )

        params = {
            "symbol": symbol,
            "side": side,
            "price": price,
            "quantity": quantity,
            **({"id": id} if id is not None else {}),
            **(
                {"list_client_order_id": list_client_order_id}
                if list_client_order_id is not None
                else {}
            ),
            **(
                {"limit_client_order_id": limit_client_order_id}
                if limit_client_order_id is not None
                else {}
            ),
            **(
                {"limit_iceberg_qty": limit_iceberg_qty}
                if limit_iceberg_qty is not None
                else {}
            ),
            **(
                {"limit_strategy_id": limit_strategy_id}
                if limit_strategy_id is not None
                else {}
            ),
            **(
                {"limit_strategy_type": limit_strategy_type}
                if limit_strategy_type is not None
                else {}
            ),
            **({"stop_price": stop_price} if stop_price is not None else {}),
            **(
                {"trailing_delta": trailing_delta} if trailing_delta is not None else {}
            ),
            **(
                {"stop_client_order_id": stop_client_order_id}
                if stop_client_order_id is not None
                else {}
            ),
            **(
                {"stop_limit_price": stop_limit_price}
                if stop_limit_price is not None
                else {}
            ),
            **(
                {"stop_limit_time_in_force": stop_limit_time_in_force}
                if stop_limit_time_in_force is not None
                else {}
            ),
            **(
                {"stop_iceberg_qty": stop_iceberg_qty}
                if stop_iceberg_qty is not None
                else {}
            ),
            **(
                {"stop_strategy_id": stop_strategy_id}
                if stop_strategy_id is not None
                else {}
            ),
            **(
                {"stop_strategy_type": stop_strategy_type}
                if stop_strategy_type is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/orderList.place".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=OrderListPlaceResponse, signer=self.signer
        )

    async def order_list_place_oco(
        self,
        symbol: Union[str, None],
        side: Union[OrderListPlaceOcoSideEnum, None],
        quantity: Union[float, None],
        above_type: Union[OrderListPlaceOcoAboveTypeEnum, None],
        below_type: Union[OrderListPlaceOcoBelowTypeEnum, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        above_client_order_id: Optional[str] = None,
        above_iceberg_qty: Optional[int] = None,
        above_price: Optional[float] = None,
        above_stop_price: Optional[float] = None,
        above_trailing_delta: Optional[int] = None,
        above_time_in_force: Optional[float] = None,
        above_strategy_id: Optional[int] = None,
        above_strategy_type: Optional[int] = None,
        above_peg_price_type: Optional[OrderListPlaceOcoAbovePegPriceTypeEnum] = None,
        above_peg_offset_type: Optional[OrderListPlaceOcoAbovePegOffsetTypeEnum] = None,
        above_peg_offset_value: Optional[int] = None,
        below_client_order_id: Optional[str] = None,
        below_iceberg_qty: Optional[int] = None,
        below_price: Optional[float] = None,
        below_stop_price: Optional[float] = None,
        below_trailing_delta: Optional[int] = None,
        below_time_in_force: Optional[OrderListPlaceOcoBelowTimeInForceEnum] = None,
        below_strategy_id: Optional[int] = None,
        below_strategy_type: Optional[int] = None,
        below_peg_price_type: Optional[OrderListPlaceOcoBelowPegPriceTypeEnum] = None,
        below_peg_offset_type: Optional[OrderListPlaceOcoBelowPegOffsetTypeEnum] = None,
        below_peg_offset_value: Optional[int] = None,
        new_order_resp_type: Optional[OrderListPlaceOcoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceOcoSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceOcoResponse]:
        """
            WebSocket Place new Order list - OCO
            /orderList.place.oco
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-list---oco-trade

            Send in an one-cancels-the-other (OCO) pair, where activation of one order immediately cancels the other.

        * An OCO has 2 orders called the **above order** and **below order**.
        * One of the orders must be a `LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT` order and the other must be `STOP_LOSS` or `STOP_LOSS_LIMIT` order.
        * Price restrictions:
          * If the OCO is on the `SELL` side:
            * `LIMIT_MAKER/TAKE_PROFIT_LIMIT` `price` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
            * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
          * If the OCO is on the `BUY` side:
            * `LIMIT_MAKER` `price` < Last Traded Price < `STOP_LOSS/STOP_LOSS_LIMIT` `stopPrice`
            * `TAKE_PROFIT stopPrice` > Last Traded Price > `STOP_LOSS/STOP_LOSS_LIMIT stopPrice`
        * OCOs add **2 orders** to the `EXCHANGE_MAX_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

            Args:
                    symbol (Union[str, None]):
                    side (Union[OrderListPlaceOcoSideEnum, None]):
                    quantity (Union[float, None]):
                    above_type (Union[OrderListPlaceOcoAboveTypeEnum, None]):
                    below_type (Union[OrderListPlaceOcoBelowTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the above order. Automatically generated if not sent
                    above_iceberg_qty (Optional[int] = None): Note that this can only be used if `aboveTimeInForce` is `GTC`.
                    above_price (Optional[float] = None): Can be used if `aboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    above_stop_price (Optional[float] = None): Can be used if `aboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`. <br>Either `aboveStopPrice` or `aboveTrailingDelta` or both, must be specified.
                    above_trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    above_time_in_force (Optional[float] = None): Required if `aboveType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT`.
                    above_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the above order within an order strategy.
                    above_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the above order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
                    above_peg_price_type (Optional[OrderListPlaceOcoAbovePegPriceTypeEnum] = None):
                    above_peg_offset_type (Optional[OrderListPlaceOcoAbovePegOffsetTypeEnum] = None):
                    above_peg_offset_value (Optional[int] = None):
                    below_client_order_id (Optional[str] = None):
                    below_iceberg_qty (Optional[int] = None): Note that this can only be used if `belowTimeInForce` is `GTC`.
                    below_price (Optional[float] = None): Can be used if `belowType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    below_stop_price (Optional[float] = None): Can be used if `belowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT` or `TAKE_PROFIT_LIMIT`. <br>Either `belowStopPrice` or `belowTrailingDelta` or both, must be specified.
                    below_trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md).
                    below_time_in_force (Optional[OrderListPlaceOcoBelowTimeInForceEnum] = None):
                    below_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the below order within an order strategy.
                    below_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the below order strategy. <br>Values smaller than 1000000 are reserved and cannot be used.
                    below_peg_price_type (Optional[OrderListPlaceOcoBelowPegPriceTypeEnum] = None):
                    below_peg_offset_type (Optional[OrderListPlaceOcoBelowPegOffsetTypeEnum] = None):
                    below_peg_offset_value (Optional[int] = None):
                    new_order_resp_type (Optional[OrderListPlaceOcoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceOcoSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderListPlaceOcoResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if quantity is None:
            raise RequiredError(
                field="quantity", error_message="Missing required parameter 'quantity'"
            )
        if above_type is None:
            raise RequiredError(
                field="above_type",
                error_message="Missing required parameter 'above_type'",
            )
        if below_type is None:
            raise RequiredError(
                field="below_type",
                error_message="Missing required parameter 'below_type'",
            )

        params = {
            "symbol": symbol,
            "side": side,
            "quantity": quantity,
            "above_type": above_type,
            "below_type": below_type,
            **({"id": id} if id is not None else {}),
            **(
                {"list_client_order_id": list_client_order_id}
                if list_client_order_id is not None
                else {}
            ),
            **(
                {"above_client_order_id": above_client_order_id}
                if above_client_order_id is not None
                else {}
            ),
            **(
                {"above_iceberg_qty": above_iceberg_qty}
                if above_iceberg_qty is not None
                else {}
            ),
            **({"above_price": above_price} if above_price is not None else {}),
            **(
                {"above_stop_price": above_stop_price}
                if above_stop_price is not None
                else {}
            ),
            **(
                {"above_trailing_delta": above_trailing_delta}
                if above_trailing_delta is not None
                else {}
            ),
            **(
                {"above_time_in_force": above_time_in_force}
                if above_time_in_force is not None
                else {}
            ),
            **(
                {"above_strategy_id": above_strategy_id}
                if above_strategy_id is not None
                else {}
            ),
            **(
                {"above_strategy_type": above_strategy_type}
                if above_strategy_type is not None
                else {}
            ),
            **(
                {"above_peg_price_type": above_peg_price_type}
                if above_peg_price_type is not None
                else {}
            ),
            **(
                {"above_peg_offset_type": above_peg_offset_type}
                if above_peg_offset_type is not None
                else {}
            ),
            **(
                {"above_peg_offset_value": above_peg_offset_value}
                if above_peg_offset_value is not None
                else {}
            ),
            **(
                {"below_client_order_id": below_client_order_id}
                if below_client_order_id is not None
                else {}
            ),
            **(
                {"below_iceberg_qty": below_iceberg_qty}
                if below_iceberg_qty is not None
                else {}
            ),
            **({"below_price": below_price} if below_price is not None else {}),
            **(
                {"below_stop_price": below_stop_price}
                if below_stop_price is not None
                else {}
            ),
            **(
                {"below_trailing_delta": below_trailing_delta}
                if below_trailing_delta is not None
                else {}
            ),
            **(
                {"below_time_in_force": below_time_in_force}
                if below_time_in_force is not None
                else {}
            ),
            **(
                {"below_strategy_id": below_strategy_id}
                if below_strategy_id is not None
                else {}
            ),
            **(
                {"below_strategy_type": below_strategy_type}
                if below_strategy_type is not None
                else {}
            ),
            **(
                {"below_peg_price_type": below_peg_price_type}
                if below_peg_price_type is not None
                else {}
            ),
            **(
                {"below_peg_offset_type": below_peg_offset_type}
                if below_peg_offset_type is not None
                else {}
            ),
            **(
                {"below_peg_offset_value": below_peg_offset_value}
                if below_peg_offset_value is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/orderList.place.oco".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload,
            response_model=OrderListPlaceOcoResponse,
            signer=self.signer,
        )

    async def order_list_place_oto(
        self,
        symbol: Union[str, None],
        working_type: Union[OrderListPlaceOtoWorkingTypeEnum, None],
        working_side: Union[OrderListPlaceOtoWorkingSideEnum, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_type: Union[OrderListPlaceOtoPendingTypeEnum, None],
        pending_side: Union[OrderListPlaceOtoPendingSideEnum, None],
        pending_quantity: Union[float, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderListPlaceOtoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceOtoSelfTradePreventionModeEnum
        ] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[OrderListPlaceOtoWorkingTimeInForceEnum] = None,
        working_strategy_id: Optional[int] = None,
        working_strategy_type: Optional[int] = None,
        working_peg_price_type: Optional[
            OrderListPlaceOtoWorkingPegPriceTypeEnum
        ] = None,
        working_peg_offset_type: Optional[
            OrderListPlaceOtoWorkingPegOffsetTypeEnum
        ] = None,
        working_peg_offset_value: Optional[int] = None,
        pending_client_order_id: Optional[str] = None,
        pending_price: Optional[float] = None,
        pending_stop_price: Optional[float] = None,
        pending_trailing_delta: Optional[float] = None,
        pending_iceberg_qty: Optional[float] = None,
        pending_time_in_force: Optional[OrderListPlaceOtoPendingTimeInForceEnum] = None,
        pending_strategy_id: Optional[int] = None,
        pending_strategy_type: Optional[int] = None,
        pending_peg_offset_type: Optional[
            OrderListPlaceOtoPendingPegOffsetTypeEnum
        ] = None,
        pending_peg_price_type: Optional[
            OrderListPlaceOtoPendingPegPriceTypeEnum
        ] = None,
        pending_peg_offset_value: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceOtoResponse]:
        """
            WebSocket Place new Order list - OTO
            /orderList.place.oto
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-list---oto-trade

            Places an OTO.

        * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders.
        * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
        * The second order is called the **pending order**. It can be any order type except for `MARKET` orders using parameter `quoteOrderQty`. The pending order is only placed on the order book when the working order gets **fully filled**.
        * If either the working order or the pending order is cancelled individually, the other order in the order list will also be canceled or expired.
        * When the order list is placed, if the working order gets **immediately fully filled**, the placement response will show the working order as `FILLED` but the pending order will still appear as `PENDING_NEW`. You need to query the status of the pending order again to see its updated status.
        * OTOs add **2 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 2

            Args:
                    symbol (Union[str, None]):
                    working_type (Union[OrderListPlaceOtoWorkingTypeEnum, None]):
                    working_side (Union[OrderListPlaceOtoWorkingSideEnum, None]):
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]): Sets the quantity for the working order.
                    pending_type (Union[OrderListPlaceOtoPendingTypeEnum, None]):
                    pending_side (Union[OrderListPlaceOtoPendingSideEnum, None]):
                    pending_quantity (Union[float, None]): Sets the quantity for the pending order.
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    new_order_resp_type (Optional[OrderListPlaceOtoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceOtoSelfTradePreventionModeEnum] = None):
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
                    working_time_in_force (Optional[OrderListPlaceOtoWorkingTimeInForceEnum] = None):
                    working_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the working order within an order strategy.
                    working_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    working_peg_price_type (Optional[OrderListPlaceOtoWorkingPegPriceTypeEnum] = None):
                    working_peg_offset_type (Optional[OrderListPlaceOtoWorkingPegOffsetTypeEnum] = None):
                    working_peg_offset_value (Optional[int] = None):
                    pending_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending order.<br> Automatically generated if not sent.
                    pending_price (Optional[float] = None):
                    pending_stop_price (Optional[float] = None):
                    pending_trailing_delta (Optional[float] = None):
                    pending_iceberg_qty (Optional[float] = None): This can only be used if `pendingTimeInForce` is `GTC`, or if `pendingType` is `LIMIT_MAKER`.
                    pending_time_in_force (Optional[OrderListPlaceOtoPendingTimeInForceEnum] = None):
                    pending_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending order within an order strategy.
                    pending_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_peg_offset_type (Optional[OrderListPlaceOtoPendingPegOffsetTypeEnum] = None):
                    pending_peg_price_type (Optional[OrderListPlaceOtoPendingPegPriceTypeEnum] = None):
                    pending_peg_offset_value (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderListPlaceOtoResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if working_type is None:
            raise RequiredError(
                field="working_type",
                error_message="Missing required parameter 'working_type'",
            )
        if working_side is None:
            raise RequiredError(
                field="working_side",
                error_message="Missing required parameter 'working_side'",
            )
        if working_price is None:
            raise RequiredError(
                field="working_price",
                error_message="Missing required parameter 'working_price'",
            )
        if working_quantity is None:
            raise RequiredError(
                field="working_quantity",
                error_message="Missing required parameter 'working_quantity'",
            )
        if pending_type is None:
            raise RequiredError(
                field="pending_type",
                error_message="Missing required parameter 'pending_type'",
            )
        if pending_side is None:
            raise RequiredError(
                field="pending_side",
                error_message="Missing required parameter 'pending_side'",
            )
        if pending_quantity is None:
            raise RequiredError(
                field="pending_quantity",
                error_message="Missing required parameter 'pending_quantity'",
            )

        params = {
            "symbol": symbol,
            "working_type": working_type,
            "working_side": working_side,
            "working_price": working_price,
            "working_quantity": working_quantity,
            "pending_type": pending_type,
            "pending_side": pending_side,
            "pending_quantity": pending_quantity,
            **({"id": id} if id is not None else {}),
            **(
                {"list_client_order_id": list_client_order_id}
                if list_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **(
                {"working_client_order_id": working_client_order_id}
                if working_client_order_id is not None
                else {}
            ),
            **(
                {"working_iceberg_qty": working_iceberg_qty}
                if working_iceberg_qty is not None
                else {}
            ),
            **(
                {"working_time_in_force": working_time_in_force}
                if working_time_in_force is not None
                else {}
            ),
            **(
                {"working_strategy_id": working_strategy_id}
                if working_strategy_id is not None
                else {}
            ),
            **(
                {"working_strategy_type": working_strategy_type}
                if working_strategy_type is not None
                else {}
            ),
            **(
                {"working_peg_price_type": working_peg_price_type}
                if working_peg_price_type is not None
                else {}
            ),
            **(
                {"working_peg_offset_type": working_peg_offset_type}
                if working_peg_offset_type is not None
                else {}
            ),
            **(
                {"working_peg_offset_value": working_peg_offset_value}
                if working_peg_offset_value is not None
                else {}
            ),
            **(
                {"pending_client_order_id": pending_client_order_id}
                if pending_client_order_id is not None
                else {}
            ),
            **({"pending_price": pending_price} if pending_price is not None else {}),
            **(
                {"pending_stop_price": pending_stop_price}
                if pending_stop_price is not None
                else {}
            ),
            **(
                {"pending_trailing_delta": pending_trailing_delta}
                if pending_trailing_delta is not None
                else {}
            ),
            **(
                {"pending_iceberg_qty": pending_iceberg_qty}
                if pending_iceberg_qty is not None
                else {}
            ),
            **(
                {"pending_time_in_force": pending_time_in_force}
                if pending_time_in_force is not None
                else {}
            ),
            **(
                {"pending_strategy_id": pending_strategy_id}
                if pending_strategy_id is not None
                else {}
            ),
            **(
                {"pending_strategy_type": pending_strategy_type}
                if pending_strategy_type is not None
                else {}
            ),
            **(
                {"pending_peg_offset_type": pending_peg_offset_type}
                if pending_peg_offset_type is not None
                else {}
            ),
            **(
                {"pending_peg_price_type": pending_peg_price_type}
                if pending_peg_price_type is not None
                else {}
            ),
            **(
                {"pending_peg_offset_value": pending_peg_offset_value}
                if pending_peg_offset_value is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/orderList.place.oto".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload,
            response_model=OrderListPlaceOtoResponse,
            signer=self.signer,
        )

    async def order_list_place_otoco(
        self,
        symbol: Union[str, None],
        working_type: Union[OrderListPlaceOtocoWorkingTypeEnum, None],
        working_side: Union[OrderListPlaceOtocoWorkingSideEnum, None],
        working_price: Union[float, None],
        working_quantity: Union[float, None],
        pending_side: Union[OrderListPlaceOtocoPendingSideEnum, None],
        pending_quantity: Union[float, None],
        pending_above_type: Union[OrderListPlaceOtocoPendingAboveTypeEnum, None],
        id: Optional[str] = None,
        list_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderListPlaceOtocoNewOrderRespTypeEnum] = None,
        self_trade_prevention_mode: Optional[
            OrderListPlaceOtocoSelfTradePreventionModeEnum
        ] = None,
        working_client_order_id: Optional[str] = None,
        working_iceberg_qty: Optional[float] = None,
        working_time_in_force: Optional[
            OrderListPlaceOtocoWorkingTimeInForceEnum
        ] = None,
        working_strategy_id: Optional[int] = None,
        working_strategy_type: Optional[int] = None,
        working_peg_price_type: Optional[
            OrderListPlaceOtocoWorkingPegPriceTypeEnum
        ] = None,
        working_peg_offset_type: Optional[
            OrderListPlaceOtocoWorkingPegOffsetTypeEnum
        ] = None,
        working_peg_offset_value: Optional[int] = None,
        pending_above_client_order_id: Optional[str] = None,
        pending_above_price: Optional[float] = None,
        pending_above_stop_price: Optional[float] = None,
        pending_above_trailing_delta: Optional[float] = None,
        pending_above_iceberg_qty: Optional[float] = None,
        pending_above_time_in_force: Optional[
            OrderListPlaceOtocoPendingAboveTimeInForceEnum
        ] = None,
        pending_above_strategy_id: Optional[int] = None,
        pending_above_strategy_type: Optional[int] = None,
        pending_above_peg_price_type: Optional[
            OrderListPlaceOtocoPendingAbovePegPriceTypeEnum
        ] = None,
        pending_above_peg_offset_type: Optional[
            OrderListPlaceOtocoPendingAbovePegOffsetTypeEnum
        ] = None,
        pending_above_peg_offset_value: Optional[int] = None,
        pending_below_type: Optional[OrderListPlaceOtocoPendingBelowTypeEnum] = None,
        pending_below_client_order_id: Optional[str] = None,
        pending_below_price: Optional[float] = None,
        pending_below_stop_price: Optional[float] = None,
        pending_below_trailing_delta: Optional[float] = None,
        pending_below_iceberg_qty: Optional[float] = None,
        pending_below_time_in_force: Optional[
            OrderListPlaceOtocoPendingBelowTimeInForceEnum
        ] = None,
        pending_below_strategy_id: Optional[int] = None,
        pending_below_strategy_type: Optional[int] = None,
        pending_below_peg_price_type: Optional[
            OrderListPlaceOtocoPendingBelowPegPriceTypeEnum
        ] = None,
        pending_below_peg_offset_type: Optional[
            OrderListPlaceOtocoPendingBelowPegOffsetTypeEnum
        ] = None,
        pending_below_peg_offset_value: Optional[int] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderListPlaceOtocoResponse]:
        """
            WebSocket Place new Order list - OTOCO
            /orderList.place.otoco
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-list---otoco-trade

            Place an OTOCO.

        * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders.
        * The first order is called the **working order** and must be `LIMIT` or `LIMIT_MAKER`. Initially, only the working order goes on the order book.
          * The behavior of the working order is the same as the [OTO](#place-new-order-list---oto-trade).
        * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The pending orders are only placed on the order book when the working order gets **fully filled**.
            * The rules of the pending above and pending below follow the same rules as the [Order list OCO](#new-order-list---oco-trade).
        * OTOCOs add **3 orders** to the `EXCHANGE_MAX_NUM_ORDERS` filter and `MAX_NUM_ORDERS` filter.
        Weight: 1

        Unfilled Order Count: 3

            Args:
                    symbol (Union[str, None]):
                    working_type (Union[OrderListPlaceOtocoWorkingTypeEnum, None]):
                    working_side (Union[OrderListPlaceOtocoWorkingSideEnum, None]):
                    working_price (Union[float, None]):
                    working_quantity (Union[float, None]): Sets the quantity for the working order.
                    pending_side (Union[OrderListPlaceOtocoPendingSideEnum, None]):
                    pending_quantity (Union[float, None]): Sets the quantity for the pending order.
                    pending_above_type (Union[OrderListPlaceOtocoPendingAboveTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    list_client_order_id (Optional[str] = None):
                    new_order_resp_type (Optional[OrderListPlaceOtocoNewOrderRespTypeEnum] = None):
                    self_trade_prevention_mode (Optional[OrderListPlaceOtocoSelfTradePreventionModeEnum] = None):
                    working_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the working order.<br> Automatically generated if not sent.
                    working_iceberg_qty (Optional[float] = None): This can only be used if `workingTimeInForce` is `GTC`, or if `workingType` is `LIMIT_MAKER`.
                    working_time_in_force (Optional[OrderListPlaceOtocoWorkingTimeInForceEnum] = None):
                    working_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the working order within an order strategy.
                    working_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the working order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    working_peg_price_type (Optional[OrderListPlaceOtocoWorkingPegPriceTypeEnum] = None):
                    working_peg_offset_type (Optional[OrderListPlaceOtocoWorkingPegOffsetTypeEnum] = None):
                    working_peg_offset_value (Optional[int] = None):
                    pending_above_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending above order.<br> Automatically generated if not sent.
                    pending_above_price (Optional[float] = None): Can be used if `pendingAboveType` is `STOP_LOSS_LIMIT` , `LIMIT_MAKER`, or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    pending_above_stop_price (Optional[float] = None): Can be used if `pendingAboveType` is `STOP_LOSS`, `STOP_LOSS_LIMIT`, `TAKE_PROFIT`, `TAKE_PROFIT_LIMIT`
                    pending_above_trailing_delta (Optional[float] = None): See [Trailing Stop FAQ](faqs/trailing-stop-faq.md)
                    pending_above_iceberg_qty (Optional[float] = None): This can only be used if `pendingAboveTimeInForce` is `GTC` or if `pendingAboveType` is `LIMIT_MAKER`.
                    pending_above_time_in_force (Optional[OrderListPlaceOtocoPendingAboveTimeInForceEnum] = None):
                    pending_above_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending above order within an order strategy.
                    pending_above_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending above order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_above_peg_price_type (Optional[OrderListPlaceOtocoPendingAbovePegPriceTypeEnum] = None):
                    pending_above_peg_offset_type (Optional[OrderListPlaceOtocoPendingAbovePegOffsetTypeEnum] = None):
                    pending_above_peg_offset_value (Optional[int] = None):
                    pending_below_type (Optional[OrderListPlaceOtocoPendingBelowTypeEnum] = None):
                    pending_below_client_order_id (Optional[str] = None): Arbitrary unique ID among open orders for the pending below order.<br> Automatically generated if not sent.
                    pending_below_price (Optional[float] = None): Can be used if `pendingBelowType` is `STOP_LOSS_LIMIT` or `TAKE_PROFIT_LIMIT` to specify the limit price.
                    pending_below_stop_price (Optional[float] = None): Can be used if `pendingBelowType` is `STOP_LOSS`, `STOP_LOSS_LIMIT, TAKE_PROFIT or TAKE_PROFIT_LIMIT`. <br>Either `pendingBelowStopPrice` or `pendingBelowTrailingDelta` or both, must be specified.
                    pending_below_trailing_delta (Optional[float] = None):
                    pending_below_iceberg_qty (Optional[float] = None): This can only be used if `pendingBelowTimeInForce` is `GTC`, or if `pendingBelowType` is `LIMIT_MAKER`.
                    pending_below_time_in_force (Optional[OrderListPlaceOtocoPendingBelowTimeInForceEnum] = None):
                    pending_below_strategy_id (Optional[int] = None): Arbitrary numeric value identifying the pending below order within an order strategy.
                    pending_below_strategy_type (Optional[int] = None): Arbitrary numeric value identifying the pending below order strategy. <br> Values smaller than 1000000 are reserved and cannot be used.
                    pending_below_peg_price_type (Optional[OrderListPlaceOtocoPendingBelowPegPriceTypeEnum] = None):
                    pending_below_peg_offset_type (Optional[OrderListPlaceOtocoPendingBelowPegOffsetTypeEnum] = None):
                    pending_below_peg_offset_value (Optional[int] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderListPlaceOtocoResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if working_type is None:
            raise RequiredError(
                field="working_type",
                error_message="Missing required parameter 'working_type'",
            )
        if working_side is None:
            raise RequiredError(
                field="working_side",
                error_message="Missing required parameter 'working_side'",
            )
        if working_price is None:
            raise RequiredError(
                field="working_price",
                error_message="Missing required parameter 'working_price'",
            )
        if working_quantity is None:
            raise RequiredError(
                field="working_quantity",
                error_message="Missing required parameter 'working_quantity'",
            )
        if pending_side is None:
            raise RequiredError(
                field="pending_side",
                error_message="Missing required parameter 'pending_side'",
            )
        if pending_quantity is None:
            raise RequiredError(
                field="pending_quantity",
                error_message="Missing required parameter 'pending_quantity'",
            )
        if pending_above_type is None:
            raise RequiredError(
                field="pending_above_type",
                error_message="Missing required parameter 'pending_above_type'",
            )

        params = {
            "symbol": symbol,
            "working_type": working_type,
            "working_side": working_side,
            "working_price": working_price,
            "working_quantity": working_quantity,
            "pending_side": pending_side,
            "pending_quantity": pending_quantity,
            "pending_above_type": pending_above_type,
            **({"id": id} if id is not None else {}),
            **(
                {"list_client_order_id": list_client_order_id}
                if list_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **(
                {"working_client_order_id": working_client_order_id}
                if working_client_order_id is not None
                else {}
            ),
            **(
                {"working_iceberg_qty": working_iceberg_qty}
                if working_iceberg_qty is not None
                else {}
            ),
            **(
                {"working_time_in_force": working_time_in_force}
                if working_time_in_force is not None
                else {}
            ),
            **(
                {"working_strategy_id": working_strategy_id}
                if working_strategy_id is not None
                else {}
            ),
            **(
                {"working_strategy_type": working_strategy_type}
                if working_strategy_type is not None
                else {}
            ),
            **(
                {"working_peg_price_type": working_peg_price_type}
                if working_peg_price_type is not None
                else {}
            ),
            **(
                {"working_peg_offset_type": working_peg_offset_type}
                if working_peg_offset_type is not None
                else {}
            ),
            **(
                {"working_peg_offset_value": working_peg_offset_value}
                if working_peg_offset_value is not None
                else {}
            ),
            **(
                {"pending_above_client_order_id": pending_above_client_order_id}
                if pending_above_client_order_id is not None
                else {}
            ),
            **(
                {"pending_above_price": pending_above_price}
                if pending_above_price is not None
                else {}
            ),
            **(
                {"pending_above_stop_price": pending_above_stop_price}
                if pending_above_stop_price is not None
                else {}
            ),
            **(
                {"pending_above_trailing_delta": pending_above_trailing_delta}
                if pending_above_trailing_delta is not None
                else {}
            ),
            **(
                {"pending_above_iceberg_qty": pending_above_iceberg_qty}
                if pending_above_iceberg_qty is not None
                else {}
            ),
            **(
                {"pending_above_time_in_force": pending_above_time_in_force}
                if pending_above_time_in_force is not None
                else {}
            ),
            **(
                {"pending_above_strategy_id": pending_above_strategy_id}
                if pending_above_strategy_id is not None
                else {}
            ),
            **(
                {"pending_above_strategy_type": pending_above_strategy_type}
                if pending_above_strategy_type is not None
                else {}
            ),
            **(
                {"pending_above_peg_price_type": pending_above_peg_price_type}
                if pending_above_peg_price_type is not None
                else {}
            ),
            **(
                {"pending_above_peg_offset_type": pending_above_peg_offset_type}
                if pending_above_peg_offset_type is not None
                else {}
            ),
            **(
                {"pending_above_peg_offset_value": pending_above_peg_offset_value}
                if pending_above_peg_offset_value is not None
                else {}
            ),
            **(
                {"pending_below_type": pending_below_type}
                if pending_below_type is not None
                else {}
            ),
            **(
                {"pending_below_client_order_id": pending_below_client_order_id}
                if pending_below_client_order_id is not None
                else {}
            ),
            **(
                {"pending_below_price": pending_below_price}
                if pending_below_price is not None
                else {}
            ),
            **(
                {"pending_below_stop_price": pending_below_stop_price}
                if pending_below_stop_price is not None
                else {}
            ),
            **(
                {"pending_below_trailing_delta": pending_below_trailing_delta}
                if pending_below_trailing_delta is not None
                else {}
            ),
            **(
                {"pending_below_iceberg_qty": pending_below_iceberg_qty}
                if pending_below_iceberg_qty is not None
                else {}
            ),
            **(
                {"pending_below_time_in_force": pending_below_time_in_force}
                if pending_below_time_in_force is not None
                else {}
            ),
            **(
                {"pending_below_strategy_id": pending_below_strategy_id}
                if pending_below_strategy_id is not None
                else {}
            ),
            **(
                {"pending_below_strategy_type": pending_below_strategy_type}
                if pending_below_strategy_type is not None
                else {}
            ),
            **(
                {"pending_below_peg_price_type": pending_below_peg_price_type}
                if pending_below_peg_price_type is not None
                else {}
            ),
            **(
                {"pending_below_peg_offset_type": pending_below_peg_offset_type}
                if pending_below_peg_offset_type is not None
                else {}
            ),
            **(
                {"pending_below_peg_offset_value": pending_below_peg_offset_value}
                if pending_below_peg_offset_value is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/orderList.place.otoco".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload,
            response_model=OrderListPlaceOtocoResponse,
            signer=self.signer,
        )

    async def order_place(
        self,
        symbol: Union[str, None],
        side: Union[OrderPlaceSideEnum, None],
        type: Union[OrderPlaceTypeEnum, None],
        id: Optional[str] = None,
        time_in_force: Optional[OrderPlaceTimeInForceEnum] = None,
        price: Optional[float] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderPlaceNewOrderRespTypeEnum] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            OrderPlaceSelfTradePreventionModeEnum
        ] = None,
        peg_price_type: Optional[OrderPlacePegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderPlacePegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderPlaceResponse]:
        """
            WebSocket Place new order
            /order.place
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-trade

            Send in a new order.

        This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.
        Weight: 1

            Args:
                    symbol (Union[str, None]):
                    side (Union[OrderPlaceSideEnum, None]):
                    type (Union[OrderPlaceTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    time_in_force (Optional[OrderPlaceTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[OrderPlaceNewOrderRespTypeEnum] = None):
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[OrderPlaceSelfTradePreventionModeEnum] = None):
                    peg_price_type (Optional[OrderPlacePegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Price level to peg the price to (max: 100)
             See Pegged Orders
                    peg_offset_type (Optional[OrderPlacePegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderPlaceResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if type is None:
            raise RequiredError(
                field="type", error_message="Missing required parameter 'type'"
            )

        params = {
            "symbol": symbol,
            "side": side,
            "type": type,
            **({"id": id} if id is not None else {}),
            **({"time_in_force": time_in_force} if time_in_force is not None else {}),
            **({"price": price} if price is not None else {}),
            **({"quantity": quantity} if quantity is not None else {}),
            **(
                {"quote_order_qty": quote_order_qty}
                if quote_order_qty is not None
                else {}
            ),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **({"stop_price": stop_price} if stop_price is not None else {}),
            **(
                {"trailing_delta": trailing_delta} if trailing_delta is not None else {}
            ),
            **({"iceberg_qty": iceberg_qty} if iceberg_qty is not None else {}),
            **({"strategy_id": strategy_id} if strategy_id is not None else {}),
            **({"strategy_type": strategy_type} if strategy_type is not None else {}),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **(
                {"peg_price_type": peg_price_type} if peg_price_type is not None else {}
            ),
            **(
                {"peg_offset_value": peg_offset_value}
                if peg_offset_value is not None
                else {}
            ),
            **(
                {"peg_offset_type": peg_offset_type}
                if peg_offset_type is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/order.place".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=OrderPlaceResponse, signer=self.signer
        )

    async def order_test(
        self,
        symbol: Union[str, None],
        side: Union[OrderTestSideEnum, None],
        type: Union[OrderTestTypeEnum, None],
        id: Optional[str] = None,
        compute_commission_rates: Optional[bool] = None,
        time_in_force: Optional[OrderTestTimeInForceEnum] = None,
        price: Optional[float] = None,
        quantity: Optional[float] = None,
        quote_order_qty: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[OrderTestNewOrderRespTypeEnum] = None,
        stop_price: Optional[float] = None,
        trailing_delta: Optional[int] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            OrderTestSelfTradePreventionModeEnum
        ] = None,
        peg_price_type: Optional[OrderTestPegPriceTypeEnum] = None,
        peg_offset_value: Optional[int] = None,
        peg_offset_type: Optional[OrderTestPegOffsetTypeEnum] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[OrderTestResponse]:
        """
            WebSocket Test new order
            /order.test
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#test-new-order-trade

            Test order placement.

        Validates new order parameters and verifies your signature
        but does not send the order into the matching engine.
        Weight: |Condition| Request Weight|
        |------------           | ------------ |
        |Without `computeCommissionRates`| 1|
        |With `computeCommissionRates`|20|

            Args:
                    symbol (Union[str, None]):
                    side (Union[OrderTestSideEnum, None]):
                    type (Union[OrderTestTypeEnum, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    compute_commission_rates (Optional[bool] = None): Default: `false` <br> See [Commissions FAQ](faqs/commission_faq.md#test-order-diferences) to learn more.
                    time_in_force (Optional[OrderTestTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    quantity (Optional[float] = None):
                    quote_order_qty (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[OrderTestNewOrderRespTypeEnum] = None):
                    stop_price (Optional[float] = None):
                    trailing_delta (Optional[int] = None): See [Trailing Stop order FAQ](faqs/trailing-stop-faq.md)
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[OrderTestSelfTradePreventionModeEnum] = None):
                    peg_price_type (Optional[OrderTestPegPriceTypeEnum] = None):
                    peg_offset_value (Optional[int] = None): Price level to peg the price to (max: 100)
             See Pegged Orders
                    peg_offset_type (Optional[OrderTestPegOffsetTypeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[OrderTestResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if type is None:
            raise RequiredError(
                field="type", error_message="Missing required parameter 'type'"
            )

        params = {
            "symbol": symbol,
            "side": side,
            "type": type,
            **({"id": id} if id is not None else {}),
            **(
                {"compute_commission_rates": compute_commission_rates}
                if compute_commission_rates is not None
                else {}
            ),
            **({"time_in_force": time_in_force} if time_in_force is not None else {}),
            **({"price": price} if price is not None else {}),
            **({"quantity": quantity} if quantity is not None else {}),
            **(
                {"quote_order_qty": quote_order_qty}
                if quote_order_qty is not None
                else {}
            ),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **({"stop_price": stop_price} if stop_price is not None else {}),
            **(
                {"trailing_delta": trailing_delta} if trailing_delta is not None else {}
            ),
            **({"iceberg_qty": iceberg_qty} if iceberg_qty is not None else {}),
            **({"strategy_id": strategy_id} if strategy_id is not None else {}),
            **({"strategy_type": strategy_type} if strategy_type is not None else {}),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **(
                {"peg_price_type": peg_price_type} if peg_price_type is not None else {}
            ),
            **(
                {"peg_offset_value": peg_offset_value}
                if peg_offset_value is not None
                else {}
            ),
            **(
                {"peg_offset_type": peg_offset_type}
                if peg_offset_type is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/order.test".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=OrderTestResponse, signer=self.signer
        )

    async def sor_order_place(
        self,
        symbol: Union[str, None],
        side: Union[SorOrderPlaceSideEnum, None],
        type: Union[SorOrderPlaceTypeEnum, None],
        quantity: Union[float, None],
        id: Optional[str] = None,
        time_in_force: Optional[SorOrderPlaceTimeInForceEnum] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[SorOrderPlaceNewOrderRespTypeEnum] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            SorOrderPlaceSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[SorOrderPlaceResponse]:
        """
            WebSocket Place new order using SOR
            /sor.order.place
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-using-sor-trade

            Places an order using smart order routing (SOR).

        This adds 1 order to the `EXCHANGE_MAX_ORDERS` filter and the `MAX_NUM_ORDERS` filter.

        Read [SOR FAQ](../faqs/sor_faq.md) to learn more.
        Weight: 1

        Unfilled Order Count: 1

            Args:
                    symbol (Union[str, None]):
                    side (Union[SorOrderPlaceSideEnum, None]):
                    type (Union[SorOrderPlaceTypeEnum, None]):
                    quantity (Union[float, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    time_in_force (Optional[SorOrderPlaceTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[SorOrderPlaceNewOrderRespTypeEnum] = None):
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[SorOrderPlaceSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[SorOrderPlaceResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if type is None:
            raise RequiredError(
                field="type", error_message="Missing required parameter 'type'"
            )
        if quantity is None:
            raise RequiredError(
                field="quantity", error_message="Missing required parameter 'quantity'"
            )

        params = {
            "symbol": symbol,
            "side": side,
            "type": type,
            "quantity": quantity,
            **({"id": id} if id is not None else {}),
            **({"time_in_force": time_in_force} if time_in_force is not None else {}),
            **({"price": price} if price is not None else {}),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **({"iceberg_qty": iceberg_qty} if iceberg_qty is not None else {}),
            **({"strategy_id": strategy_id} if strategy_id is not None else {}),
            **({"strategy_type": strategy_type} if strategy_type is not None else {}),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/sor.order.place".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=SorOrderPlaceResponse, signer=self.signer
        )

    async def sor_order_test(
        self,
        symbol: Union[str, None],
        side: Union[SorOrderTestSideEnum, None],
        type: Union[SorOrderTestTypeEnum, None],
        quantity: Union[float, None],
        id: Optional[str] = None,
        compute_commission_rates: Optional[bool] = None,
        time_in_force: Optional[SorOrderTestTimeInForceEnum] = None,
        price: Optional[float] = None,
        new_client_order_id: Optional[str] = None,
        new_order_resp_type: Optional[SorOrderTestNewOrderRespTypeEnum] = None,
        iceberg_qty: Optional[float] = None,
        strategy_id: Optional[int] = None,
        strategy_type: Optional[int] = None,
        self_trade_prevention_mode: Optional[
            SorOrderTestSelfTradePreventionModeEnum
        ] = None,
        recv_window: Optional[int] = None,
    ) -> WebsocketApiResponse[SorOrderTestResponse]:
        """
            WebSocket Test new order using SOR
            /sor.order.test
            https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#test-new-order-using-sor-trade

            Test new order creation and signature/recvWindow using smart order routing (SOR).
        Creates and validates a new order but does not send it into the matching engine.
        Weight: |Condition                       | Request Weight|
        |------------                    | ------------ |
        |Without `computeCommissionRates`| 1            |
        |With `computeCommissionRates`   |20            |

            Args:
                    symbol (Union[str, None]):
                    side (Union[SorOrderTestSideEnum, None]):
                    type (Union[SorOrderTestTypeEnum, None]):
                    quantity (Union[float, None]):
                    id (Optional[str] = None): Unique WebSocket request ID.
                    compute_commission_rates (Optional[bool] = None): Default: `false` <br> See [Commissions FAQ](faqs/commission_faq.md#test-order-diferences) to learn more.
                    time_in_force (Optional[SorOrderTestTimeInForceEnum] = None):
                    price (Optional[float] = None):
                    new_client_order_id (Optional[str] = None): The new client order ID for the order after being amended. <br> If not sent, one will be randomly generated. <br> It is possible to reuse the current clientOrderId by sending it as the `newClientOrderId`.
                    new_order_resp_type (Optional[SorOrderTestNewOrderRespTypeEnum] = None):
                    iceberg_qty (Optional[float] = None):
                    strategy_id (Optional[int] = None): Arbitrary numeric value identifying the order within an order strategy.
                    strategy_type (Optional[int] = None): Arbitrary numeric value identifying the order strategy.
                        Values smaller than 1000000 are reserved and cannot be used.
                    self_trade_prevention_mode (Optional[SorOrderTestSelfTradePreventionModeEnum] = None):
                    recv_window (Optional[int] = None): The value cannot be greater than `60000`

            Returns:
                WebsocketApiResponse[SorOrderTestResponse]

            Raises:
                RequiredError: If a required parameter is missing.

        """

        if symbol is None:
            raise RequiredError(
                field="symbol", error_message="Missing required parameter 'symbol'"
            )
        if side is None:
            raise RequiredError(
                field="side", error_message="Missing required parameter 'side'"
            )
        if type is None:
            raise RequiredError(
                field="type", error_message="Missing required parameter 'type'"
            )
        if quantity is None:
            raise RequiredError(
                field="quantity", error_message="Missing required parameter 'quantity'"
            )

        params = {
            "symbol": symbol,
            "side": side,
            "type": type,
            "quantity": quantity,
            **({"id": id} if id is not None else {}),
            **(
                {"compute_commission_rates": compute_commission_rates}
                if compute_commission_rates is not None
                else {}
            ),
            **({"time_in_force": time_in_force} if time_in_force is not None else {}),
            **({"price": price} if price is not None else {}),
            **(
                {"new_client_order_id": new_client_order_id}
                if new_client_order_id is not None
                else {}
            ),
            **(
                {"new_order_resp_type": new_order_resp_type}
                if new_order_resp_type is not None
                else {}
            ),
            **({"iceberg_qty": iceberg_qty} if iceberg_qty is not None else {}),
            **({"strategy_id": strategy_id} if strategy_id is not None else {}),
            **({"strategy_type": strategy_type} if strategy_type is not None else {}),
            **(
                {"self_trade_prevention_mode": self_trade_prevention_mode}
                if self_trade_prevention_mode is not None
                else {}
            ),
            **({"recv_window": recv_window} if recv_window is not None else {}),
        }

        payload = {
            "method": "/sor.order.test".replace("/", "", 1),
            "params": params,
        }

        return await self.websocket_api.send_signed_message(
            payload=payload, response_model=SorOrderTestResponse, signer=self.signer
        )
