"""
Binance Derivatives Trading USDS Futures REST API

OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_derivatives_trading_usds_futures.rest_api.api import TradeApi
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    AccountTradeListResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    AllOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    AutoCancelAllOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CancelAlgoOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CancelAllAlgoOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CancelAllOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CancelMultipleOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CancelOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ChangeInitialLeverageResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ChangeMarginTypeResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ChangeMultiAssetsModeResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ChangePositionModeResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CurrentAllAlgoOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CurrentAllOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    FuturesTradfiPerpsContractResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    GetOrderModifyHistoryResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    GetPositionMarginChangeHistoryResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyIsolatedPositionMarginResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyMultipleOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PlaceMultipleOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PositionAdlQuantileEstimationResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PositionInformationV2Response,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PositionInformationV3Response,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QueryAlgoOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QueryAllAlgoOrdersResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QueryCurrentOpenOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QueryOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    UsersForceOrdersResponse,
)


from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ChangeMarginTypeMarginTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyIsolatedPositionMarginPositionSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyOrderSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderWorkingTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewAlgoOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    NewOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderWorkingTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TestOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    UsersForceOrdersAutoCloseTypeEnum,
)

from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ModifyMultipleOrdersBatchOrdersParameterInner,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PlaceMultipleOrdersBatchOrdersParameterInner,
)


class TestTradeApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = TradeApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_account_trade_list_success(self, mock_get_signature):
        """Test account_trade_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "buyer": False,
                "commission": "-0.07819010",
                "commissionAsset": "USDT",
                "id": 698759,
                "maker": False,
                "orderId": 25851813,
                "price": "7819.01",
                "qty": "0.002",
                "quoteQty": "15.63802",
                "realizedPnl": "-0.91539999",
                "side": "SELL",
                "positionSide": "SHORT",
                "symbol": "BTCUSDT",
                "time": 1569514978020,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AccountTradeListResponse, "from_dict"):
            expected = AccountTradeListResponse.from_dict(expected_response)
        else:
            expected = AccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_account_trade_list_success_with_optional_params(self, mock_get_signature):
        """Test account_trade_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "buyer": False,
                "commission": "-0.07819010",
                "commissionAsset": "USDT",
                "id": 698759,
                "maker": False,
                "orderId": 25851813,
                "price": "7819.01",
                "qty": "0.002",
                "quoteQty": "15.63802",
                "realizedPnl": "-0.91539999",
                "side": "SELL",
                "positionSide": "SHORT",
                "symbol": "BTCUSDT",
                "time": 1569514978020,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AccountTradeListResponse, "from_dict"):
            expected = AccountTradeListResponse.from_dict(expected_response)
        else:
            expected = AccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_account_trade_list_missing_required_param_symbol(self):
        """Test that account_trade_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.account_trade_list(**params)

    def test_account_trade_list_server_error(self):
        """Test that account_trade_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.account_trade_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.account_trade_list(**params)

    @patch("binance_common.utils.get_signature")
    def test_all_orders_success(self, mock_get_signature):
        """Test all_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrdersResponse, "from_dict"):
            expected = AllOrdersResponse.from_dict(expected_response)
        else:
            expected = AllOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_all_orders_success_with_optional_params(self, mock_get_signature):
        """Test all_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrdersResponse, "from_dict"):
            expected = AllOrdersResponse.from_dict(expected_response)
        else:
            expected = AllOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_all_orders_missing_required_param_symbol(self):
        """Test that all_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.all_orders(**params)

    def test_all_orders_server_error(self):
        """Test that all_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.all_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.all_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_auto_cancel_all_open_orders_success(self, mock_get_signature):
        """Test auto_cancel_all_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }

        expected_response = {"symbol": "BTCUSDT", "countdownTime": "100000"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.auto_cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/countdownCancelAll" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["countdownTime"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AutoCancelAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(AutoCancelAllOpenOrdersResponse, "from_dict")
        ):
            expected = AutoCancelAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = AutoCancelAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_auto_cancel_all_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test auto_cancel_all_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "countdown_time": 56, "recv_window": 5000}

        expected_response = {"symbol": "BTCUSDT", "countdownTime": "100000"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.auto_cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/countdownCancelAll" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AutoCancelAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(AutoCancelAllOpenOrdersResponse, "from_dict")
        ):
            expected = AutoCancelAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = AutoCancelAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_auto_cancel_all_open_orders_missing_required_param_symbol(self):
        """Test that auto_cancel_all_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.auto_cancel_all_open_orders(**params)

    def test_auto_cancel_all_open_orders_missing_required_param_countdown_time(self):
        """Test that auto_cancel_all_open_orders() raises RequiredError when 'countdown_time' is missing."""
        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }
        params["countdown_time"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'countdown_time'"
        ):
            self.client.auto_cancel_all_open_orders(**params)

    def test_auto_cancel_all_open_orders_server_error(self):
        """Test that auto_cancel_all_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.auto_cancel_all_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.auto_cancel_all_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_algo_order_success(self, mock_get_signature):
        """Test cancel_algo_order() successfully with required parameters only."""

        expected_response = {
            "algoId": 2146760,
            "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
            "code": "200",
            "msg": "success",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_algo_order()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAlgoOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAlgoOrderResponse, "from_dict"):
            expected = CancelAlgoOrderResponse.from_dict(expected_response)
        else:
            expected = CancelAlgoOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_algo_order_success_with_optional_params(self, mock_get_signature):
        """Test cancel_algo_order() successfully with optional parameters."""

        params = {
            "algoid": 56,
            "clientalgoid": "clientalgoid_example",
            "recv_window": 5000,
        }

        expected_response = {
            "algoId": 2146760,
            "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
            "code": "200",
            "msg": "success",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_algo_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAlgoOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAlgoOrderResponse, "from_dict"):
            expected = CancelAlgoOrderResponse.from_dict(expected_response)
        else:
            expected = CancelAlgoOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_algo_order_server_error(self):
        """Test that cancel_algo_order() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.cancel_algo_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_algo_order()

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_algo_open_orders_success(self, mock_get_signature):
        """Test cancel_all_algo_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_algo_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllAlgoOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(CancelAllAlgoOpenOrdersResponse, "from_dict")
        ):
            expected = CancelAllAlgoOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllAlgoOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_algo_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_algo_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_algo_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllAlgoOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(CancelAllAlgoOpenOrdersResponse, "from_dict")
        ):
            expected = CancelAllAlgoOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllAlgoOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_algo_open_orders_missing_required_param_symbol(self):
        """Test that cancel_all_algo_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_algo_open_orders(**params)

    def test_cancel_all_algo_open_orders_server_error(self):
        """Test that cancel_all_algo_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_algo_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_algo_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_open_orders_success(self, mock_get_signature):
        """Test cancel_all_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllOpenOrdersResponse, "from_dict"):
            expected = CancelAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllOpenOrdersResponse, "from_dict"):
            expected = CancelAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_open_orders_missing_required_param_symbol(self):
        """Test that cancel_all_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_open_orders(**params)

    def test_cancel_all_open_orders_server_error(self):
        """Test that cancel_all_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_multiple_orders_success(self, mock_get_signature):
        """Test cancel_multiple_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "clientOrderId": "myOrder1",
                "cumQty": "0",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 283194212,
                "origQty": "11",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "CANCELED",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSDT",
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1571110484038,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 1693207680000,
            },
            {"code": -2011, "msg": "Unknown order sent."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelMultipleOrdersResponse, "from_dict"):
            expected = CancelMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_multiple_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_multiple_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id_list": [1234567],
            "orig_client_order_id_list": ["my_id_1"],
            "recv_window": 5000,
        }

        expected_response = [
            {
                "clientOrderId": "myOrder1",
                "cumQty": "0",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 283194212,
                "origQty": "11",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "CANCELED",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSDT",
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1571110484038,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 1693207680000,
            },
            {"code": -2011, "msg": "Unknown order sent."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelMultipleOrdersResponse, "from_dict"):
            expected = CancelMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_multiple_orders_missing_required_param_symbol(self):
        """Test that cancel_multiple_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_multiple_orders(**params)

    def test_cancel_multiple_orders_server_error(self):
        """Test that cancel_multiple_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_multiple_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_multiple_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_order_success(self, mock_get_signature):
        """Test cancel_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 283194212,
            "origQty": "11",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1571110484038,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelOrderResponse, "from_dict"):
            expected = CancelOrderResponse.from_dict(expected_response)
        else:
            expected = CancelOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_order_success_with_optional_params(self, mock_get_signature):
        """Test cancel_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 283194212,
            "origQty": "11",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1571110484038,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelOrderResponse, "from_dict"):
            expected = CancelOrderResponse.from_dict(expected_response)
        else:
            expected = CancelOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_order_missing_required_param_symbol(self):
        """Test that cancel_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_order(**params)

    def test_cancel_order_server_error(self):
        """Test that cancel_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_initial_leverage_success(self, mock_get_signature):
        """Test change_initial_leverage() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }

        expected_response = {
            "leverage": 21,
            "maxNotionalValue": "1000000",
            "symbol": "BTCUSDT",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_initial_leverage(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/leverage" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["leverage"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeInitialLeverageResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeInitialLeverageResponse, "from_dict"):
            expected = ChangeInitialLeverageResponse.from_dict(expected_response)
        else:
            expected = ChangeInitialLeverageResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_initial_leverage_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test change_initial_leverage() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "leverage": 56, "recv_window": 5000}

        expected_response = {
            "leverage": 21,
            "maxNotionalValue": "1000000",
            "symbol": "BTCUSDT",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_initial_leverage(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/leverage" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeInitialLeverageResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeInitialLeverageResponse, "from_dict"):
            expected = ChangeInitialLeverageResponse.from_dict(expected_response)
        else:
            expected = ChangeInitialLeverageResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_initial_leverage_missing_required_param_symbol(self):
        """Test that change_initial_leverage() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.change_initial_leverage(**params)

    def test_change_initial_leverage_missing_required_param_leverage(self):
        """Test that change_initial_leverage() raises RequiredError when 'leverage' is missing."""
        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }
        params["leverage"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'leverage'"
        ):
            self.client.change_initial_leverage(**params)

    def test_change_initial_leverage_server_error(self):
        """Test that change_initial_leverage() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.change_initial_leverage = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_initial_leverage(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_margin_type_success(self, mock_get_signature):
        """Test change_margin_type() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_margin_type(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/marginType" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["marginType"] == ChangeMarginTypeMarginTypeEnum["ISOLATED"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeMarginTypeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeMarginTypeResponse, "from_dict"):
            expected = ChangeMarginTypeResponse.from_dict(expected_response)
        else:
            expected = ChangeMarginTypeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_margin_type_success_with_optional_params(self, mock_get_signature):
        """Test change_margin_type() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
            "recv_window": 5000,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_margin_type(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/marginType" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeMarginTypeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeMarginTypeResponse, "from_dict"):
            expected = ChangeMarginTypeResponse.from_dict(expected_response)
        else:
            expected = ChangeMarginTypeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_margin_type_missing_required_param_symbol(self):
        """Test that change_margin_type() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.change_margin_type(**params)

    def test_change_margin_type_missing_required_param_margin_type(self):
        """Test that change_margin_type() raises RequiredError when 'margin_type' is missing."""
        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }
        params["margin_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'margin_type'"
        ):
            self.client.change_margin_type(**params)

    def test_change_margin_type_server_error(self):
        """Test that change_margin_type() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.change_margin_type = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_margin_type(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_multi_assets_mode_success(self, mock_get_signature):
        """Test change_multi_assets_mode() successfully with required parameters only."""

        params = {
            "multi_assets_margin": "multi_assets_margin_example",
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_multi_assets_mode(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/multiAssetsMargin" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["multiAssetsMargin"] == "multi_assets_margin_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeMultiAssetsModeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeMultiAssetsModeResponse, "from_dict"):
            expected = ChangeMultiAssetsModeResponse.from_dict(expected_response)
        else:
            expected = ChangeMultiAssetsModeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_multi_assets_mode_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test change_multi_assets_mode() successfully with optional parameters."""

        params = {
            "multi_assets_margin": "multi_assets_margin_example",
            "recv_window": 5000,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_multi_assets_mode(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/multiAssetsMargin" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeMultiAssetsModeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeMultiAssetsModeResponse, "from_dict"):
            expected = ChangeMultiAssetsModeResponse.from_dict(expected_response)
        else:
            expected = ChangeMultiAssetsModeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_multi_assets_mode_missing_required_param_multi_assets_margin(self):
        """Test that change_multi_assets_mode() raises RequiredError when 'multi_assets_margin' is missing."""
        params = {
            "multi_assets_margin": "multi_assets_margin_example",
        }
        params["multi_assets_margin"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'multi_assets_margin'"
        ):
            self.client.change_multi_assets_mode(**params)

    def test_change_multi_assets_mode_server_error(self):
        """Test that change_multi_assets_mode() raises an error when the server returns an error."""

        params = {
            "multi_assets_margin": "multi_assets_margin_example",
        }

        mock_error = Exception("ResponseError")
        self.client.change_multi_assets_mode = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_multi_assets_mode(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_position_mode_success(self, mock_get_signature):
        """Test change_position_mode() successfully with required parameters only."""

        params = {
            "dual_side_position": "dual_side_position_example",
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_position_mode(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/positionSide/dual" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["dualSidePosition"] == "dual_side_position_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangePositionModeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangePositionModeResponse, "from_dict"):
            expected = ChangePositionModeResponse.from_dict(expected_response)
        else:
            expected = ChangePositionModeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_position_mode_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test change_position_mode() successfully with optional parameters."""

        params = {
            "dual_side_position": "dual_side_position_example",
            "recv_window": 5000,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_position_mode(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/positionSide/dual" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangePositionModeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangePositionModeResponse, "from_dict"):
            expected = ChangePositionModeResponse.from_dict(expected_response)
        else:
            expected = ChangePositionModeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_position_mode_missing_required_param_dual_side_position(self):
        """Test that change_position_mode() raises RequiredError when 'dual_side_position' is missing."""
        params = {
            "dual_side_position": "dual_side_position_example",
        }
        params["dual_side_position"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'dual_side_position'"
        ):
            self.client.change_position_mode(**params)

    def test_change_position_mode_server_error(self):
        """Test that change_position_mode() raises an error when the server returns an error."""

        params = {
            "dual_side_position": "dual_side_position_example",
        }

        mock_error = Exception("ResponseError")
        self.client.change_position_mode = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_position_mode(**params)

    @patch("binance_common.utils.get_signature")
    def test_current_all_algo_open_orders_success(self, mock_get_signature):
        """Test current_all_algo_open_orders() successfully with required parameters only."""

        expected_response = [
            {
                "algoId": 2148627,
                "clientAlgoId": "MRumok0dkhrP4kCm12AHaB",
                "algoType": "CONDITIONAL",
                "orderType": "TAKE_PROFIT",
                "symbol": "BNBUSDT",
                "side": "SELL",
                "positionSide": "BOTH",
                "timeInForce": "GTC",
                "quantity": "0.01",
                "algoStatus": "NEW",
                "actualOrderId": "",
                "actualPrice": "0.00000",
                "triggerPrice": "750.000",
                "price": "750.000",
                "icebergQuantity": None,
                "tpTriggerPrice": "0.000",
                "tpPrice": "0.000",
                "slTriggerPrice": "0.000",
                "slPrice": "0.000",
                "tpOrderType": "",
                "selfTradePreventionMode": "EXPIRE_MAKER",
                "workingType": "CONTRACT_PRICE",
                "priceMatch": "NONE",
                "closePosition": False,
                "priceProtect": False,
                "reduceOnly": False,
                "createTime": 1750514941540,
                "updateTime": 1750514941540,
                "triggerTime": 0,
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.current_all_algo_open_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/openAlgoOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CurrentAllAlgoOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CurrentAllAlgoOpenOrdersResponse, "from_dict")
        ):
            expected = CurrentAllAlgoOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CurrentAllAlgoOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_current_all_algo_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test current_all_algo_open_orders() successfully with optional parameters."""

        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "algo_id": 1,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "algoId": 2148627,
                "clientAlgoId": "MRumok0dkhrP4kCm12AHaB",
                "algoType": "CONDITIONAL",
                "orderType": "TAKE_PROFIT",
                "symbol": "BNBUSDT",
                "side": "SELL",
                "positionSide": "BOTH",
                "timeInForce": "GTC",
                "quantity": "0.01",
                "algoStatus": "NEW",
                "actualOrderId": "",
                "actualPrice": "0.00000",
                "triggerPrice": "750.000",
                "price": "750.000",
                "icebergQuantity": None,
                "tpTriggerPrice": "0.000",
                "tpPrice": "0.000",
                "slTriggerPrice": "0.000",
                "slPrice": "0.000",
                "tpOrderType": "",
                "selfTradePreventionMode": "EXPIRE_MAKER",
                "workingType": "CONTRACT_PRICE",
                "priceMatch": "NONE",
                "closePosition": False,
                "priceProtect": False,
                "reduceOnly": False,
                "createTime": 1750514941540,
                "updateTime": 1750514941540,
                "triggerTime": 0,
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.current_all_algo_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/openAlgoOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CurrentAllAlgoOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CurrentAllAlgoOpenOrdersResponse, "from_dict")
        ):
            expected = CurrentAllAlgoOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CurrentAllAlgoOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_current_all_algo_open_orders_server_error(self):
        """Test that current_all_algo_open_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.current_all_algo_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.current_all_algo_open_orders()

    @patch("binance_common.utils.get_signature")
    def test_current_all_open_orders_success(self, mock_get_signature):
        """Test current_all_open_orders() successfully with required parameters only."""

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.current_all_open_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CurrentAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CurrentAllOpenOrdersResponse, "from_dict"):
            expected = CurrentAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CurrentAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_current_all_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test current_all_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "avgPrice": "0.00000",
                "clientOrderId": "abc",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSDT",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.current_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CurrentAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CurrentAllOpenOrdersResponse, "from_dict"):
            expected = CurrentAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CurrentAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_current_all_open_orders_server_error(self):
        """Test that current_all_open_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.current_all_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.current_all_open_orders()

    @patch("binance_common.utils.get_signature")
    def test_futures_tradfi_perps_contract_success(self, mock_get_signature):
        """Test futures_tradfi_perps_contract() successfully with required parameters only."""

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.futures_tradfi_perps_contract()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/stock/contract" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(FuturesTradfiPerpsContractResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(FuturesTradfiPerpsContractResponse, "from_dict")
        ):
            expected = FuturesTradfiPerpsContractResponse.from_dict(expected_response)
        else:
            expected = FuturesTradfiPerpsContractResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_futures_tradfi_perps_contract_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test futures_tradfi_perps_contract() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.futures_tradfi_perps_contract(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/stock/contract" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(FuturesTradfiPerpsContractResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(FuturesTradfiPerpsContractResponse, "from_dict")
        ):
            expected = FuturesTradfiPerpsContractResponse.from_dict(expected_response)
        else:
            expected = FuturesTradfiPerpsContractResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_futures_tradfi_perps_contract_server_error(self):
        """Test that futures_tradfi_perps_contract() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.futures_tradfi_perps_contract = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.futures_tradfi_perps_contract()

    @patch("binance_common.utils.get_signature")
    def test_get_order_modify_history_success(self, mock_get_signature):
        """Test get_order_modify_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order_modify_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderModifyHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderModifyHistoryResponse, "from_dict"):
            expected = GetOrderModifyHistoryResponse.from_dict(expected_response)
        else:
            expected = GetOrderModifyHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_order_modify_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_order_modify_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order_modify_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderModifyHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderModifyHistoryResponse, "from_dict"):
            expected = GetOrderModifyHistoryResponse.from_dict(expected_response)
        else:
            expected = GetOrderModifyHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_order_modify_history_missing_required_param_symbol(self):
        """Test that get_order_modify_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_order_modify_history(**params)

    def test_get_order_modify_history_server_error(self):
        """Test that get_order_modify_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.get_order_modify_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_order_modify_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_position_margin_change_history_success(self, mock_get_signature):
        """Test get_position_margin_change_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "type": 1,
                "deltaType": "USER_ADJUST",
                "amount": "23.36332311",
                "asset": "USDT",
                "time": 1578047897183,
                "positionSide": "BOTH",
            },
            {
                "symbol": "BTCUSDT",
                "type": 1,
                "deltaType": "USER_ADJUST",
                "amount": "100",
                "asset": "USDT",
                "time": 1578047900425,
                "positionSide": "LONG",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_position_margin_change_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/positionMargin/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetPositionMarginChangeHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetPositionMarginChangeHistoryResponse, "from_dict")
        ):
            expected = GetPositionMarginChangeHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = GetPositionMarginChangeHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_position_margin_change_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_position_margin_change_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "type": 56,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "type": 1,
                "deltaType": "USER_ADJUST",
                "amount": "23.36332311",
                "asset": "USDT",
                "time": 1578047897183,
                "positionSide": "BOTH",
            },
            {
                "symbol": "BTCUSDT",
                "type": 1,
                "deltaType": "USER_ADJUST",
                "amount": "100",
                "asset": "USDT",
                "time": 1578047900425,
                "positionSide": "LONG",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_position_margin_change_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/positionMargin/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetPositionMarginChangeHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetPositionMarginChangeHistoryResponse, "from_dict")
        ):
            expected = GetPositionMarginChangeHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = GetPositionMarginChangeHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_position_margin_change_history_missing_required_param_symbol(self):
        """Test that get_position_margin_change_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_position_margin_change_history(**params)

    def test_get_position_margin_change_history_server_error(self):
        """Test that get_position_margin_change_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.get_position_margin_change_history = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_position_margin_change_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_isolated_position_margin_success(self, mock_get_signature):
        """Test modify_isolated_position_margin() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": "type_example",
        }

        expected_response = {
            "amount": 100,
            "code": 200,
            "msg": "Successfully modify position margin.",
            "type": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_isolated_position_margin(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/positionMargin" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["amount"] == 1.0
        assert normalized["type"] == "type_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyIsolatedPositionMarginResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ModifyIsolatedPositionMarginResponse, "from_dict")
        ):
            expected = ModifyIsolatedPositionMarginResponse.from_dict(expected_response)
        else:
            expected = ModifyIsolatedPositionMarginResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_isolated_position_margin_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test modify_isolated_position_margin() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": "type_example",
            "position_side": ModifyIsolatedPositionMarginPositionSideEnum["BOTH"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "amount": 100,
            "code": 200,
            "msg": "Successfully modify position margin.",
            "type": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_isolated_position_margin(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/positionMargin" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyIsolatedPositionMarginResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ModifyIsolatedPositionMarginResponse, "from_dict")
        ):
            expected = ModifyIsolatedPositionMarginResponse.from_dict(expected_response)
        else:
            expected = ModifyIsolatedPositionMarginResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_isolated_position_margin_missing_required_param_symbol(self):
        """Test that modify_isolated_position_margin() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": "type_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.modify_isolated_position_margin(**params)

    def test_modify_isolated_position_margin_missing_required_param_amount(self):
        """Test that modify_isolated_position_margin() raises RequiredError when 'amount' is missing."""
        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": "type_example",
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.modify_isolated_position_margin(**params)

    def test_modify_isolated_position_margin_missing_required_param_type(self):
        """Test that modify_isolated_position_margin() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": "type_example",
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.modify_isolated_position_margin(**params)

    def test_modify_isolated_position_margin_server_error(self):
        """Test that modify_isolated_position_margin() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": "type_example",
        }

        mock_error = Exception("ResponseError")
        self.client.modify_isolated_position_margin = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_isolated_position_margin(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_multiple_orders_success(self, mock_get_signature):
        """Test modify_multiple_orders() successfully with required parameters only."""

        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id="1",
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity="1.0",
                    price="1.0",
                    price_match="NONE",
                    recv_window="5000",
                )
            ],
        }

        expected_response = [
            {
                "orderId": 20072994037,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "status": "NEW",
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "price": "30005",
                "avgPrice": "0.0",
                "origQty": "1",
                "executedQty": "0",
                "cumQty": "0",
                "cumBase": "0",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "BUY",
                "positionSide": "LONG",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "updateTime": 1629182711600,
            },
            {"code": -2022, "msg": "ReduceOnly Order is rejected."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert "batchOrders" in normalized

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyMultipleOrdersResponse, "from_dict"):
            expected = ModifyMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = ModifyMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_multiple_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test modify_multiple_orders() successfully with optional parameters."""

        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id="1",
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity="1.0",
                    price="1.0",
                    price_match="NONE",
                    recv_window="5000",
                )
            ],
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderId": 20072994037,
                "symbol": "BTCUSDT",
                "pair": "BTCUSDT",
                "status": "NEW",
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "price": "30005",
                "avgPrice": "0.0",
                "origQty": "1",
                "executedQty": "0",
                "cumQty": "0",
                "cumBase": "0",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "BUY",
                "positionSide": "LONG",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 0,
                "updateTime": 1629182711600,
            },
            {"code": -2022, "msg": "ReduceOnly Order is rejected."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyMultipleOrdersResponse, "from_dict"):
            expected = ModifyMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = ModifyMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_multiple_orders_missing_required_param_batch_orders(self):
        """Test that modify_multiple_orders() raises RequiredError when 'batch_orders' is missing."""
        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id="1",
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity="1.0",
                    price="1.0",
                    price_match="NONE",
                    recv_window="5000",
                )
            ],
        }
        params["batch_orders"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'batch_orders'"
        ):
            self.client.modify_multiple_orders(**params)

    def test_modify_multiple_orders_server_error(self):
        """Test that modify_multiple_orders() raises an error when the server returns an error."""

        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id="1",
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity="1.0",
                    price="1.0",
                    price_match="NONE",
                    recv_window="5000",
                )
            ],
        }

        mock_error = Exception("ResponseError")
        self.client.modify_multiple_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_multiple_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_order_success(self, mock_get_signature):
        """Test modify_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSDT",
            "pair": "BTCUSDT",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumBase": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "closePosition": False,
            "side": "BUY",
            "positionSide": "LONG",
            "stopPrice": "0",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "origType": "LIMIT",
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "updateTime": 1629182711600,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == ModifyOrderSideEnum["BUY"].value
        assert normalized["quantity"] == 1.0
        assert normalized["price"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyOrderResponse, "from_dict"):
            expected = ModifyOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_order_success_with_optional_params(self, mock_get_signature):
        """Test modify_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
            "order_id": 1,
            "orig_client_order_id": "1",
            "price_match": ModifyOrderPriceMatchEnum["NONE"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSDT",
            "pair": "BTCUSDT",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumBase": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "closePosition": False,
            "side": "BUY",
            "positionSide": "LONG",
            "stopPrice": "0",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "origType": "LIMIT",
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
            "updateTime": 1629182711600,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyOrderResponse, "from_dict"):
            expected = ModifyOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_order_missing_required_param_symbol(self):
        """Test that modify_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.modify_order(**params)

    def test_modify_order_missing_required_param_side(self):
        """Test that modify_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.modify_order(**params)

    def test_modify_order_missing_required_param_quantity(self):
        """Test that modify_order() raises RequiredError when 'quantity' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["quantity"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'quantity'"
        ):
            self.client.modify_order(**params)

    def test_modify_order_missing_required_param_price(self):
        """Test that modify_order() raises RequiredError when 'price' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }
        params["price"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'price'"):
            self.client.modify_order(**params)

    def test_modify_order_server_error(self):
        """Test that modify_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "quantity": 1.0,
            "price": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.modify_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_algo_order_success(self, mock_get_signature):
        """Test new_algo_order() successfully with required parameters only."""

        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
        }

        expected_response = {
            "algoId": 2146760,
            "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
            "algoType": "CONDITIONAL",
            "orderType": "TAKE_PROFIT",
            "symbol": "BNBUSDT",
            "side": "SELL",
            "positionSide": "BOTH",
            "timeInForce": "GTC",
            "quantity": "0.01",
            "algoStatus": "NEW",
            "triggerPrice": "750.000",
            "price": "750.000",
            "icebergQuantity": None,
            "selfTradePreventionMode": "EXPIRE_MAKER",
            "workingType": "CONTRACT_PRICE",
            "priceMatch": "NONE",
            "closePosition": False,
            "priceProtect": False,
            "reduceOnly": False,
            "activatePrice": "",
            "callbackRate": "",
            "createTime": 1750485492076,
            "updateTime": 1750485492076,
            "triggerTime": 0,
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_algo_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["algoType"] == "algo_type_example"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewAlgoOrderSideEnum["BUY"].value
        assert normalized["type"] == "type_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewAlgoOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewAlgoOrderResponse, "from_dict"):
            expected = NewAlgoOrderResponse.from_dict(expected_response)
        else:
            expected = NewAlgoOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_algo_order_success_with_optional_params(self, mock_get_signature):
        """Test new_algo_order() successfully with optional parameters."""

        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
            "position_side": NewAlgoOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewAlgoOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "price": 1.0,
            "trigger_price": 1.0,
            "working_type": NewAlgoOrderWorkingTypeEnum["MARK_PRICE"].value,
            "price_match": NewAlgoOrderPriceMatchEnum["NONE"].value,
            "close_position": "close_position_example",
            "price_protect": "False",
            "reduce_only": "False",
            "activate_price": 1.0,
            "callback_rate": 1.0,
            "client_algo_id": "1",
            "self_trade_prevention_mode": NewAlgoOrderSelfTradePreventionModeEnum[
                "EXPIRE_TAKER"
            ].value,
            "good_till_date": 56,
            "recv_window": 5000,
        }

        expected_response = {
            "algoId": 2146760,
            "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
            "algoType": "CONDITIONAL",
            "orderType": "TAKE_PROFIT",
            "symbol": "BNBUSDT",
            "side": "SELL",
            "positionSide": "BOTH",
            "timeInForce": "GTC",
            "quantity": "0.01",
            "algoStatus": "NEW",
            "triggerPrice": "750.000",
            "price": "750.000",
            "icebergQuantity": None,
            "selfTradePreventionMode": "EXPIRE_MAKER",
            "workingType": "CONTRACT_PRICE",
            "priceMatch": "NONE",
            "closePosition": False,
            "priceProtect": False,
            "reduceOnly": False,
            "activatePrice": "",
            "callbackRate": "",
            "createTime": 1750485492076,
            "updateTime": 1750485492076,
            "triggerTime": 0,
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_algo_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewAlgoOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewAlgoOrderResponse, "from_dict"):
            expected = NewAlgoOrderResponse.from_dict(expected_response)
        else:
            expected = NewAlgoOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_algo_order_missing_required_param_algo_type(self):
        """Test that new_algo_order() raises RequiredError when 'algo_type' is missing."""
        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["algo_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'algo_type'"
        ):
            self.client.new_algo_order(**params)

    def test_new_algo_order_missing_required_param_symbol(self):
        """Test that new_algo_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_algo_order(**params)

    def test_new_algo_order_missing_required_param_side(self):
        """Test that new_algo_order() raises RequiredError when 'side' is missing."""
        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_algo_order(**params)

    def test_new_algo_order_missing_required_param_type(self):
        """Test that new_algo_order() raises RequiredError when 'type' is missing."""
        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_algo_order(**params)

    def test_new_algo_order_server_error(self):
        """Test that new_algo_order() raises an error when the server returns an error."""

        params = {
            "algo_type": "algo_type_example",
            "symbol": "symbol_example",
            "side": NewAlgoOrderSideEnum["BUY"].value,
            "type": "type_example",
        }

        mock_error = Exception("ResponseError")
        self.client.new_algo_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_algo_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_order_success(self, mock_get_signature):
        """Test new_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": "type_example",
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.00000",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "type": "TRAILING_STOP_MARKET",
            "origType": "TRAILING_STOP_MARKET",
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewOrderSideEnum["BUY"].value
        assert normalized["type"] == "type_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewOrderResponse, "from_dict"):
            expected = NewOrderResponse.from_dict(expected_response)
        else:
            expected = NewOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_order_success_with_optional_params(self, mock_get_signature):
        """Test new_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": "type_example",
            "position_side": NewOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "new_client_order_id": "1",
            "new_order_resp_type": NewOrderNewOrderRespTypeEnum["ACK"].value,
            "price_match": NewOrderPriceMatchEnum["NONE"].value,
            "self_trade_prevention_mode": NewOrderSelfTradePreventionModeEnum[
                "EXPIRE_TAKER"
            ].value,
            "good_till_date": 56,
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.00000",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "type": "TRAILING_STOP_MARKET",
            "origType": "TRAILING_STOP_MARKET",
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewOrderResponse, "from_dict"):
            expected = NewOrderResponse.from_dict(expected_response)
        else:
            expected = NewOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_order_missing_required_param_symbol(self):
        """Test that new_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_order(**params)

    def test_new_order_missing_required_param_side(self):
        """Test that new_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_order(**params)

    def test_new_order_missing_required_param_type(self):
        """Test that new_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_order(**params)

    def test_new_order_server_error(self):
        """Test that new_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": "type_example",
        }

        mock_error = Exception("ResponseError")
        self.client.new_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_place_multiple_orders_success(self, mock_get_signature):
        """Test place_multiple_orders() successfully with required parameters only."""

        params = {
            "batch_orders": [
                PlaceMultipleOrdersBatchOrdersParameterInner(
                    symbol="",
                    side="BUY",
                    position_side="BOTH",
                    type="",
                    time_in_force="GTC",
                    quantity="1.0",
                    reduce_only="False",
                    price="1.0",
                    new_client_order_id="1",
                    new_order_resp_type="ACK",
                    price_match="NONE",
                    self_trade_prevention_mode="EXPIRE_TAKER",
                    good_till_date="",
                )
            ],
        }

        expected_response = [
            {
                "clientOrderId": "testOrder",
                "cumQty": "0",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 22542179,
                "avgPrice": "0.00000",
                "origQty": "10",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "0",
                "symbol": "BTCUSDT",
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "origType": "TRAILING_STOP_MARKET",
                "updateTime": 1566818724722,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 1693207680000,
            },
            {"code": -2022, "msg": "ReduceOnly Order is rejected."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.place_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert "batchOrders" in normalized

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PlaceMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PlaceMultipleOrdersResponse, "from_dict"):
            expected = PlaceMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = PlaceMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_place_multiple_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test place_multiple_orders() successfully with optional parameters."""

        params = {
            "batch_orders": [
                PlaceMultipleOrdersBatchOrdersParameterInner(
                    symbol="",
                    side="BUY",
                    position_side="BOTH",
                    type="",
                    time_in_force="GTC",
                    quantity="1.0",
                    reduce_only="False",
                    price="1.0",
                    new_client_order_id="1",
                    new_order_resp_type="ACK",
                    price_match="NONE",
                    self_trade_prevention_mode="EXPIRE_TAKER",
                    good_till_date="",
                )
            ],
            "recv_window": 5000,
        }

        expected_response = [
            {
                "clientOrderId": "testOrder",
                "cumQty": "0",
                "cumQuote": "0",
                "executedQty": "0",
                "orderId": 22542179,
                "avgPrice": "0.00000",
                "origQty": "10",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "0",
                "symbol": "BTCUSDT",
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "origType": "TRAILING_STOP_MARKET",
                "updateTime": 1566818724722,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "goodTillDate": 1693207680000,
            },
            {"code": -2022, "msg": "ReduceOnly Order is rejected."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.place_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PlaceMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PlaceMultipleOrdersResponse, "from_dict"):
            expected = PlaceMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = PlaceMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_place_multiple_orders_missing_required_param_batch_orders(self):
        """Test that place_multiple_orders() raises RequiredError when 'batch_orders' is missing."""
        params = {
            "batch_orders": [
                PlaceMultipleOrdersBatchOrdersParameterInner(
                    symbol="",
                    side="BUY",
                    position_side="BOTH",
                    type="",
                    time_in_force="GTC",
                    quantity="1.0",
                    reduce_only="False",
                    price="1.0",
                    new_client_order_id="1",
                    new_order_resp_type="ACK",
                    price_match="NONE",
                    self_trade_prevention_mode="EXPIRE_TAKER",
                    good_till_date="",
                )
            ],
        }
        params["batch_orders"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'batch_orders'"
        ):
            self.client.place_multiple_orders(**params)

    def test_place_multiple_orders_server_error(self):
        """Test that place_multiple_orders() raises an error when the server returns an error."""

        params = {
            "batch_orders": [
                PlaceMultipleOrdersBatchOrdersParameterInner(
                    symbol="",
                    side="BUY",
                    position_side="BOTH",
                    type="",
                    time_in_force="GTC",
                    quantity="1.0",
                    reduce_only="False",
                    price="1.0",
                    new_client_order_id="1",
                    new_order_resp_type="ACK",
                    price_match="NONE",
                    self_trade_prevention_mode="EXPIRE_TAKER",
                    good_till_date="",
                )
            ],
        }

        mock_error = Exception("ResponseError")
        self.client.place_multiple_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.place_multiple_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_position_adl_quantile_estimation_success(self, mock_get_signature):
        """Test position_adl_quantile_estimation() successfully with required parameters only."""

        expected_response = [
            {"symbol": "ETHUSDT", "adlQuantile": {"LONG": 3, "SHORT": 3, "HEDGE": 0}},
            {"symbol": "BTCUSDT", "adlQuantile": {"LONG": 1, "SHORT": 2, "BOTH": 0}},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_adl_quantile_estimation()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(PositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = PositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = PositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_position_adl_quantile_estimation_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test position_adl_quantile_estimation() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {"symbol": "ETHUSDT", "adlQuantile": {"LONG": 3, "SHORT": 3, "HEDGE": 0}},
            {"symbol": "BTCUSDT", "adlQuantile": {"LONG": 1, "SHORT": 2, "BOTH": 0}},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_adl_quantile_estimation(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(PositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = PositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = PositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_position_adl_quantile_estimation_server_error(self):
        """Test that position_adl_quantile_estimation() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.position_adl_quantile_estimation = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.position_adl_quantile_estimation()

    @patch("binance_common.utils.get_signature")
    def test_position_information_v2_success(self, mock_get_signature):
        """Test position_information_v2() successfully with required parameters only."""

        expected_response = [
            {
                "entryPrice": "0.00000",
                "breakEvenPrice": "0.0",
                "marginType": "isolated",
                "isAutoAddMargin": "False",
                "isolatedMargin": "0.00000000",
                "leverage": "10",
                "liquidationPrice": "0",
                "markPrice": "6679.50671178",
                "maxNotionalValue": "20000000",
                "positionAmt": "0.000",
                "notional": "0",
                "isolatedWallet": "0",
                "symbol": "BTCUSDT",
                "unRealizedProfit": "0.00000000",
                "positionSide": "BOTH",
                "updateTime": 0,
            },
            {
                "symbol": "BTCUSDT",
                "positionAmt": "0.001",
                "entryPrice": "22185.2",
                "breakEvenPrice": "0.0",
                "markPrice": "21123.05052574",
                "unRealizedProfit": "-1.06214947",
                "liquidationPrice": "19731.45529116",
                "leverage": "4",
                "maxNotionalValue": "100000000",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "LONG",
                "notional": "21.12305052",
                "isolatedWallet": "0",
                "updateTime": 1655217461579,
            },
            {
                "symbol": "BTCUSDT",
                "positionAmt": "0.000",
                "entryPrice": "0.0",
                "breakEvenPrice": "0.0",
                "markPrice": "21123.05052574",
                "unRealizedProfit": "0.00000000",
                "liquidationPrice": "0",
                "leverage": "4",
                "maxNotionalValue": "100000000",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "SHORT",
                "notional": "0",
                "isolatedWallet": "0",
                "updateTime": 0,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_information_v2()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v2/positionRisk" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionInformationV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PositionInformationV2Response, "from_dict"):
            expected = PositionInformationV2Response.from_dict(expected_response)
        else:
            expected = PositionInformationV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_position_information_v2_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test position_information_v2() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "entryPrice": "0.00000",
                "breakEvenPrice": "0.0",
                "marginType": "isolated",
                "isAutoAddMargin": "False",
                "isolatedMargin": "0.00000000",
                "leverage": "10",
                "liquidationPrice": "0",
                "markPrice": "6679.50671178",
                "maxNotionalValue": "20000000",
                "positionAmt": "0.000",
                "notional": "0",
                "isolatedWallet": "0",
                "symbol": "BTCUSDT",
                "unRealizedProfit": "0.00000000",
                "positionSide": "BOTH",
                "updateTime": 0,
            },
            {
                "symbol": "BTCUSDT",
                "positionAmt": "0.001",
                "entryPrice": "22185.2",
                "breakEvenPrice": "0.0",
                "markPrice": "21123.05052574",
                "unRealizedProfit": "-1.06214947",
                "liquidationPrice": "19731.45529116",
                "leverage": "4",
                "maxNotionalValue": "100000000",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "LONG",
                "notional": "21.12305052",
                "isolatedWallet": "0",
                "updateTime": 1655217461579,
            },
            {
                "symbol": "BTCUSDT",
                "positionAmt": "0.000",
                "entryPrice": "0.0",
                "breakEvenPrice": "0.0",
                "markPrice": "21123.05052574",
                "unRealizedProfit": "0.00000000",
                "liquidationPrice": "0",
                "leverage": "4",
                "maxNotionalValue": "100000000",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "SHORT",
                "notional": "0",
                "isolatedWallet": "0",
                "updateTime": 0,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_information_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v2/positionRisk" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionInformationV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PositionInformationV2Response, "from_dict"):
            expected = PositionInformationV2Response.from_dict(expected_response)
        else:
            expected = PositionInformationV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_position_information_v2_server_error(self):
        """Test that position_information_v2() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.position_information_v2 = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.position_information_v2()

    @patch("binance_common.utils.get_signature")
    def test_position_information_v3_success(self, mock_get_signature):
        """Test position_information_v3() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "ADAUSDT",
                "positionSide": "BOTH",
                "positionAmt": "30",
                "entryPrice": "0.385",
                "breakEvenPrice": "0.385077",
                "markPrice": "0.41047590",
                "unRealizedProfit": "0.76427700",
                "liquidationPrice": "0",
                "isolatedMargin": "0",
                "notional": "12.31427700",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "0.61571385",
                "maintMargin": "0.08004280",
                "positionInitialMargin": "0.61571385",
                "openOrderInitialMargin": "0",
                "adl": 2,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1720736417660,
            },
            {
                "symbol": "ADAUSDT",
                "positionSide": "LONG",
                "positionAmt": "30",
                "entryPrice": "0.385",
                "breakEvenPrice": "0.385077",
                "markPrice": "0.41047590",
                "unRealizedProfit": "0.76427700",
                "liquidationPrice": "0",
                "isolatedMargin": "0",
                "notional": "12.31427700",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "0.61571385",
                "maintMargin": "0.08004280",
                "positionInitialMargin": "0.61571385",
                "openOrderInitialMargin": "0",
                "adl": 2,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1720736417660,
            },
            {
                "symbol": "COMPUSDT",
                "positionSide": "SHORT",
                "positionAmt": "-1.000",
                "entryPrice": "70.92841",
                "breakEvenPrice": "70.900038636",
                "markPrice": "49.72023376",
                "unRealizedProfit": "21.20817624",
                "liquidationPrice": "2260.56757210",
                "isolatedMargin": "0",
                "notional": "-49.72023376",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "2.48601168",
                "maintMargin": "0.49720233",
                "positionInitialMargin": "2.48601168",
                "openOrderInitialMargin": "0",
                "adl": 2,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1708943511656,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_information_v3()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v3/positionRisk" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionInformationV3Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PositionInformationV3Response, "from_dict"):
            expected = PositionInformationV3Response.from_dict(expected_response)
        else:
            expected = PositionInformationV3Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_position_information_v3_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test position_information_v3() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "symbol": "ADAUSDT",
                "positionSide": "BOTH",
                "positionAmt": "30",
                "entryPrice": "0.385",
                "breakEvenPrice": "0.385077",
                "markPrice": "0.41047590",
                "unRealizedProfit": "0.76427700",
                "liquidationPrice": "0",
                "isolatedMargin": "0",
                "notional": "12.31427700",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "0.61571385",
                "maintMargin": "0.08004280",
                "positionInitialMargin": "0.61571385",
                "openOrderInitialMargin": "0",
                "adl": 2,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1720736417660,
            },
            {
                "symbol": "ADAUSDT",
                "positionSide": "LONG",
                "positionAmt": "30",
                "entryPrice": "0.385",
                "breakEvenPrice": "0.385077",
                "markPrice": "0.41047590",
                "unRealizedProfit": "0.76427700",
                "liquidationPrice": "0",
                "isolatedMargin": "0",
                "notional": "12.31427700",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "0.61571385",
                "maintMargin": "0.08004280",
                "positionInitialMargin": "0.61571385",
                "openOrderInitialMargin": "0",
                "adl": 2,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1720736417660,
            },
            {
                "symbol": "COMPUSDT",
                "positionSide": "SHORT",
                "positionAmt": "-1.000",
                "entryPrice": "70.92841",
                "breakEvenPrice": "70.900038636",
                "markPrice": "49.72023376",
                "unRealizedProfit": "21.20817624",
                "liquidationPrice": "2260.56757210",
                "isolatedMargin": "0",
                "notional": "-49.72023376",
                "marginAsset": "USDT",
                "isolatedWallet": "0",
                "initialMargin": "2.48601168",
                "maintMargin": "0.49720233",
                "positionInitialMargin": "2.48601168",
                "openOrderInitialMargin": "0",
                "adl": 2,
                "bidNotional": "0",
                "askNotional": "0",
                "updateTime": 1708943511656,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_information_v3(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v3/positionRisk" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionInformationV3Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PositionInformationV3Response, "from_dict"):
            expected = PositionInformationV3Response.from_dict(expected_response)
        else:
            expected = PositionInformationV3Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_position_information_v3_server_error(self):
        """Test that position_information_v3() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.position_information_v3 = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.position_information_v3()

    @patch("binance_common.utils.get_signature")
    def test_query_algo_order_success(self, mock_get_signature):
        """Test query_algo_order() successfully with required parameters only."""

        expected_response = {
            "algoId": 2146760,
            "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
            "algoType": "CONDITIONAL",
            "orderType": "TAKE_PROFIT",
            "symbol": "BNBUSDT",
            "side": "SELL",
            "positionSide": "BOTH",
            "timeInForce": "GTC",
            "quantity": "0.01",
            "algoStatus": "CANCELED",
            "actualOrderId": "",
            "actualPrice": "0.00000",
            "triggerPrice": "750.000",
            "price": "750.000",
            "icebergQuantity": None,
            "tpTriggerPrice": "0.000",
            "tpPrice": "0.000",
            "slTriggerPrice": "0.000",
            "slPrice": "0.000",
            "tpOrderType": "",
            "selfTradePreventionMode": "EXPIRE_MAKER",
            "workingType": "CONTRACT_PRICE",
            "priceMatch": "NONE",
            "closePosition": False,
            "priceProtect": False,
            "reduceOnly": False,
            "createTime": 1750485492076,
            "updateTime": 1750514545091,
            "triggerTime": 0,
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_algo_order()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAlgoOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAlgoOrderResponse, "from_dict"):
            expected = QueryAlgoOrderResponse.from_dict(expected_response)
        else:
            expected = QueryAlgoOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_algo_order_success_with_optional_params(self, mock_get_signature):
        """Test query_algo_order() successfully with optional parameters."""

        params = {"algo_id": 1, "client_algo_id": "1", "recv_window": 5000}

        expected_response = {
            "algoId": 2146760,
            "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
            "algoType": "CONDITIONAL",
            "orderType": "TAKE_PROFIT",
            "symbol": "BNBUSDT",
            "side": "SELL",
            "positionSide": "BOTH",
            "timeInForce": "GTC",
            "quantity": "0.01",
            "algoStatus": "CANCELED",
            "actualOrderId": "",
            "actualPrice": "0.00000",
            "triggerPrice": "750.000",
            "price": "750.000",
            "icebergQuantity": None,
            "tpTriggerPrice": "0.000",
            "tpPrice": "0.000",
            "slTriggerPrice": "0.000",
            "slPrice": "0.000",
            "tpOrderType": "",
            "selfTradePreventionMode": "EXPIRE_MAKER",
            "workingType": "CONTRACT_PRICE",
            "priceMatch": "NONE",
            "closePosition": False,
            "priceProtect": False,
            "reduceOnly": False,
            "createTime": 1750485492076,
            "updateTime": 1750514545091,
            "triggerTime": 0,
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_algo_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/algoOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAlgoOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAlgoOrderResponse, "from_dict"):
            expected = QueryAlgoOrderResponse.from_dict(expected_response)
        else:
            expected = QueryAlgoOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_algo_order_server_error(self):
        """Test that query_algo_order() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_algo_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_algo_order()

    @patch("binance_common.utils.get_signature")
    def test_query_all_algo_orders_success(self, mock_get_signature):
        """Test query_all_algo_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "algoId": 2146760,
                "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
                "algoType": "CONDITIONAL",
                "orderType": "TAKE_PROFIT",
                "symbol": "BNBUSDT",
                "side": "SELL",
                "positionSide": "BOTH",
                "timeInForce": "GTC",
                "quantity": "0.01",
                "algoStatus": "CANCELED",
                "actualOrderId": "",
                "actualPrice": "0.00000",
                "triggerPrice": "750.000",
                "price": "750.000",
                "icebergQuantity": None,
                "tpTriggerPrice": "0.000",
                "tpPrice": "0.000",
                "slTriggerPrice": "0.000",
                "slPrice": "0.000",
                "tpOrderType": "",
                "selfTradePreventionMode": "EXPIRE_MAKER",
                "workingType": "CONTRACT_PRICE",
                "priceMatch": "NONE",
                "closePosition": False,
                "priceProtect": False,
                "reduceOnly": False,
                "createTime": 1750485492076,
                "updateTime": 1750514545091,
                "triggerTime": 0,
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_algo_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/allAlgoOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllAlgoOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAllAlgoOrdersResponse, "from_dict"):
            expected = QueryAllAlgoOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllAlgoOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_all_algo_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_all_algo_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "algo_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "page": 56,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "algoId": 2146760,
                "clientAlgoId": "6B2I9XVcJpCjqPAJ4YoFX7",
                "algoType": "CONDITIONAL",
                "orderType": "TAKE_PROFIT",
                "symbol": "BNBUSDT",
                "side": "SELL",
                "positionSide": "BOTH",
                "timeInForce": "GTC",
                "quantity": "0.01",
                "algoStatus": "CANCELED",
                "actualOrderId": "",
                "actualPrice": "0.00000",
                "triggerPrice": "750.000",
                "price": "750.000",
                "icebergQuantity": None,
                "tpTriggerPrice": "0.000",
                "tpPrice": "0.000",
                "slTriggerPrice": "0.000",
                "slPrice": "0.000",
                "tpOrderType": "",
                "selfTradePreventionMode": "EXPIRE_MAKER",
                "workingType": "CONTRACT_PRICE",
                "priceMatch": "NONE",
                "closePosition": False,
                "priceProtect": False,
                "reduceOnly": False,
                "createTime": 1750485492076,
                "updateTime": 1750514545091,
                "triggerTime": 0,
                "goodTillDate": 0,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_all_algo_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/allAlgoOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryAllAlgoOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryAllAlgoOrdersResponse, "from_dict"):
            expected = QueryAllAlgoOrdersResponse.from_dict(expected_response)
        else:
            expected = QueryAllAlgoOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_all_algo_orders_missing_required_param_symbol(self):
        """Test that query_all_algo_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_all_algo_orders(**params)

    def test_query_all_algo_orders_server_error(self):
        """Test that query_all_algo_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_all_algo_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_all_algo_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_current_open_order_success(self, mock_get_signature):
        """Test query_current_open_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryCurrentOpenOrderResponse, "from_dict"):
            expected = QueryCurrentOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_open_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_open_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryCurrentOpenOrderResponse, "from_dict"):
            expected = QueryCurrentOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_open_order_missing_required_param_symbol(self):
        """Test that query_current_open_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_open_order(**params)

    def test_query_current_open_order_server_error(self):
        """Test that query_current_open_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_open_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_open_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_order_success(self, mock_get_signature):
        """Test query_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryOrderResponse, "from_dict"):
            expected = QueryOrderResponse.from_dict(expected_response)
        else:
            expected = QueryOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_order_success_with_optional_params(self, mock_get_signature):
        """Test query_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.00000",
            "clientOrderId": "abc",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 0,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryOrderResponse, "from_dict"):
            expected = QueryOrderResponse.from_dict(expected_response)
        else:
            expected = QueryOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_order_missing_required_param_symbol(self):
        """Test that query_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_order(**params)

    def test_query_order_server_error(self):
        """Test that query_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_test_order_success(self, mock_get_signature):
        """Test test_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": TestOrderSideEnum["BUY"].value,
            "type": "type_example",
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.00000",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "type": "TRAILING_STOP_MARKET",
            "origType": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.test_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order/test" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == TestOrderSideEnum["BUY"].value
        assert normalized["type"] == "type_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TestOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(TestOrderResponse, "from_dict"):
            expected = TestOrderResponse.from_dict(expected_response)
        else:
            expected = TestOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_test_order_success_with_optional_params(self, mock_get_signature):
        """Test test_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": TestOrderSideEnum["BUY"].value,
            "type": "type_example",
            "position_side": TestOrderPositionSideEnum["BOTH"].value,
            "time_in_force": TestOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "new_client_order_id": "1",
            "stop_price": 1.0,
            "close_position": "close_position_example",
            "activation_price": 1.0,
            "callback_rate": 1.0,
            "working_type": TestOrderWorkingTypeEnum["MARK_PRICE"].value,
            "price_protect": "False",
            "new_order_resp_type": TestOrderNewOrderRespTypeEnum["ACK"].value,
            "price_match": TestOrderPriceMatchEnum["NONE"].value,
            "self_trade_prevention_mode": TestOrderSelfTradePreventionModeEnum[
                "EXPIRE_TAKER"
            ].value,
            "good_till_date": 56,
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumQuote": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.00000",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSDT",
            "timeInForce": "GTD",
            "type": "TRAILING_STOP_MARKET",
            "origType": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "goodTillDate": 1693207680000,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.test_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/order/test" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TestOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(TestOrderResponse, "from_dict"):
            expected = TestOrderResponse.from_dict(expected_response)
        else:
            expected = TestOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_test_order_missing_required_param_symbol(self):
        """Test that test_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": TestOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.test_order(**params)

    def test_test_order_missing_required_param_side(self):
        """Test that test_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": TestOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.test_order(**params)

    def test_test_order_missing_required_param_type(self):
        """Test that test_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": TestOrderSideEnum["BUY"].value,
            "type": "type_example",
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.test_order(**params)

    def test_test_order_server_error(self):
        """Test that test_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": TestOrderSideEnum["BUY"].value,
            "type": "type_example",
        }

        mock_error = Exception("ResponseError")
        self.client.test_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.test_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_users_force_orders_success(self, mock_get_signature):
        """Test users_force_orders() successfully with required parameters only."""

        expected_response = [
            {
                "orderId": 6071832819,
                "symbol": "BTCUSDT",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596107620040000020",
                "price": "10871.09",
                "avgPrice": "10913.21000",
                "origQty": "0.001",
                "executedQty": "0.001",
                "cumQuote": "10.91321",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "origType": "LIMIT",
                "time": 1596107620044,
                "updateTime": 1596107620087,
            },
            {
                "orderId": 6072734303,
                "symbol": "BTCUSDT",
                "status": "FILLED",
                "clientOrderId": "adl_autoclose",
                "price": "11023.14",
                "avgPrice": "10979.82000",
                "origQty": "0.001",
                "executedQty": "0.001",
                "cumQuote": "10.97982",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "origType": "LIMIT",
                "time": 1596110725059,
                "updateTime": 1596110725071,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.users_force_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UsersForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UsersForceOrdersResponse, "from_dict"):
            expected = UsersForceOrdersResponse.from_dict(expected_response)
        else:
            expected = UsersForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_users_force_orders_success_with_optional_params(self, mock_get_signature):
        """Test users_force_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "auto_close_type": UsersForceOrdersAutoCloseTypeEnum["LIQUIDATION"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderId": 6071832819,
                "symbol": "BTCUSDT",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596107620040000020",
                "price": "10871.09",
                "avgPrice": "10913.21000",
                "origQty": "0.001",
                "executedQty": "0.001",
                "cumQuote": "10.91321",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "origType": "LIMIT",
                "time": 1596107620044,
                "updateTime": 1596107620087,
            },
            {
                "orderId": 6072734303,
                "symbol": "BTCUSDT",
                "status": "FILLED",
                "clientOrderId": "adl_autoclose",
                "price": "11023.14",
                "avgPrice": "10979.82000",
                "origQty": "0.001",
                "executedQty": "0.001",
                "cumQuote": "10.97982",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "origType": "LIMIT",
                "time": 1596110725059,
                "updateTime": 1596110725071,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.users_force_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/fapi/v1/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UsersForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UsersForceOrdersResponse, "from_dict"):
            expected = UsersForceOrdersResponse.from_dict(expected_response)
        else:
            expected = UsersForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_users_force_orders_server_error(self):
        """Test that users_force_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.users_force_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.users_force_orders()
