"""
Binance Derivatives Trading COIN Futures REST API

OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_derivatives_trading_coin_futures.rest_api.api import MarketDataApi
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import BasisResponse
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    CheckServerTimeResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    CompressedAggregateTradesListResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ContinuousContractKlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ExchangeInformationResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    GetFundingRateHistoryOfPerpetualFuturesResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    GetFundingRateInfoResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    IndexPriceAndMarkPriceResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    IndexPriceKlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    KlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    LongShortRatioResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    MarkPriceKlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    OldTradesLookupResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    OpenInterestResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    OpenInterestStatisticsResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    OrderBookResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    PremiumIndexKlineDataResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    QueryIndexPriceConstituentsResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    RecentTradesListResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    SymbolOrderBookTickerResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    SymbolPriceTickerResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TakerBuySellVolumeResponse,
)

from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    Ticker24hrPriceChangeStatisticsResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TopTraderLongShortRatioAccountsResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TopTraderLongShortRatioPositionsResponse,
)


from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    BasisContractTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import BasisPeriodEnum
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ContinuousContractKlineCandlestickDataContractTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ContinuousContractKlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    IndexPriceKlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    KlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    LongShortRatioPeriodEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    MarkPriceKlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    OpenInterestStatisticsContractTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    OpenInterestStatisticsPeriodEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    PremiumIndexKlineDataIntervalEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TakerBuySellVolumeContractTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TakerBuySellVolumePeriodEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TopTraderLongShortRatioAccountsPeriodEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    TopTraderLongShortRatioPositionsPeriodEnum,
)


class TestMarketDataApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = MarketDataApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    def test_basis_success(self):
        """Test basis() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "indexPrice": "29269.93972727",
                "contractType": "CURRENT_QUARTER",
                "basisRate": "0.0024",
                "futuresPrice": "29341.3",
                "annualizedBasisRate": "0.0283",
                "basis": "71.36027273",
                "pair": "BTCUSD",
                "timestamp": 1653381600000,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.basis(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/basis" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert normalized["contractType"] == BasisContractTypeEnum["PERPETUAL"].value
        assert normalized["period"] == BasisPeriodEnum["PERIOD_5m"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(BasisResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = BasisResponse.from_dict(expected_response)
        else:
            expected = BasisResponse.model_validate_json(json.dumps(expected_response))

        assert response.data() == expected

    def test_basis_success_with_optional_params(self):
        """Test basis() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "indexPrice": "29269.93972727",
                "contractType": "CURRENT_QUARTER",
                "basisRate": "0.0024",
                "futuresPrice": "29341.3",
                "annualizedBasisRate": "0.0283",
                "basis": "71.36027273",
                "pair": "BTCUSD",
                "timestamp": 1653381600000,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.basis(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/basis" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(BasisResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = BasisResponse.from_dict(expected_response)
        else:
            expected = BasisResponse.model_validate_json(json.dumps(expected_response))

        assert response.data() == expected

    def test_basis_missing_required_param_pair(self):
        """Test that basis() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.basis(**params)

    def test_basis_missing_required_param_contract_type(self):
        """Test that basis() raises RequiredError when 'contract_type' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
        }
        del params["contract_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'contract_type'"
        ):
            self.client.basis(**params)

    def test_basis_missing_required_param_period(self):
        """Test that basis() raises RequiredError when 'period' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
        }
        del params["period"]

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.basis(**params)

    def test_basis_server_error(self):
        """Test that basis() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.basis = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.basis(**params)

    def test_check_server_time_success(self):
        """Test check_server_time() successfully with required parameters only."""

        expected_response = {"serverTime": 1499827319559}

        self.set_mock_response(expected_response)

        response = self.client.check_server_time()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/time" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CheckServerTimeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = CheckServerTimeResponse.from_dict(expected_response)
        else:
            expected = CheckServerTimeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_check_server_time_server_error(self):
        """Test that check_server_time() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.check_server_time = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.check_server_time()

    def test_compressed_aggregate_trades_list_success(self):
        """Test compressed_aggregate_trades_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "a": 416690,
                "p": "9642.4",
                "q": "3",
                "f": 595259,
                "l": 595259,
                "T": 1591250548649,
                "m": False,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.compressed_aggregate_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/aggTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CompressedAggregateTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = CompressedAggregateTradesListResponse.from_dict(
                expected_response
            )
        else:
            expected = CompressedAggregateTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_compressed_aggregate_trades_list_success_with_optional_params(self):
        """Test compressed_aggregate_trades_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "from_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            {
                "a": 416690,
                "p": "9642.4",
                "q": "3",
                "f": 595259,
                "l": 595259,
                "T": 1591250548649,
                "m": False,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.compressed_aggregate_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/aggTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CompressedAggregateTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = CompressedAggregateTradesListResponse.from_dict(
                expected_response
            )
        else:
            expected = CompressedAggregateTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_compressed_aggregate_trades_list_missing_required_param_symbol(self):
        """Test that compressed_aggregate_trades_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.compressed_aggregate_trades_list(**params)

    def test_compressed_aggregate_trades_list_server_error(self):
        """Test that compressed_aggregate_trades_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.compressed_aggregate_trades_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.compressed_aggregate_trades_list(**params)

    def test_continuous_contract_kline_candlestick_data_success(self):
        """Test continuous_contract_kline_candlestick_data() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }

        expected_response = [
            [
                1591258320000,
                "9640.7",
                "9642.4",
                "9640.6",
                "9642.0",
                "206",
                1591258379999,
                "2.13660389",
                48,
                "119",
                "1.23424865",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.continuous_contract_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/continuousKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["contractType"]
            == ContinuousContractKlineCandlestickDataContractTypeEnum["PERPETUAL"].value
        )
        assert (
            normalized["interval"]
            == ContinuousContractKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ContinuousContractKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = ContinuousContractKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                ContinuousContractKlineCandlestickDataResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_continuous_contract_kline_candlestick_data_success_with_optional_params(
        self,
    ):
        """Test continuous_contract_kline_candlestick_data() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1591258320000,
                "9640.7",
                "9642.4",
                "9640.6",
                "9642.0",
                "206",
                1591258379999,
                "2.13660389",
                48,
                "119",
                "1.23424865",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.continuous_contract_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/continuousKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ContinuousContractKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = ContinuousContractKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                ContinuousContractKlineCandlestickDataResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_continuous_contract_kline_candlestick_data_missing_required_param_pair(
        self,
    ):
        """Test that continuous_contract_kline_candlestick_data() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_continuous_contract_kline_candlestick_data_missing_required_param_contract_type(
        self,
    ):
        """Test that continuous_contract_kline_candlestick_data() raises RequiredError when 'contract_type' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }
        del params["contract_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'contract_type'"
        ):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_continuous_contract_kline_candlestick_data_missing_required_param_interval(
        self,
    ):
        """Test that continuous_contract_kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }
        del params["interval"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_continuous_contract_kline_candlestick_data_server_error(self):
        """Test that continuous_contract_kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }

        mock_error = Exception("ResponseError")
        self.client.continuous_contract_kline_candlestick_data = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_exchange_information_success(self):
        """Test exchange_information() successfully with required parameters only."""

        expected_response = {
            "exchangeFilters": [],
            "rateLimits": [
                {
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "rateLimitType": "REQUEST_WEIGHT",
                },
                {
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                    "rateLimitType": "ORDERS",
                },
            ],
            "serverTime": 1565613908500,
            "symbols": [
                {
                    "filters": [
                        {
                            "filterType": "PRICE_FILTER",
                            "maxPrice": "100000",
                            "minPrice": "0.1",
                            "tickSize": "0.1",
                        },
                        {
                            "filterType": "LOT_SIZE",
                            "maxQty": "100000",
                            "minQty": "1",
                            "stepSize": "1",
                        },
                        {
                            "filterType": "MARKET_LOT_SIZE",
                            "maxQty": "100000",
                            "minQty": "1",
                            "stepSize": "1",
                        },
                        {"filterType": "MAX_NUM_ORDERS", "limit": 200},
                        {
                            "filterType": "PERCENT_PRICE",
                            "multiplierUp": "1.0500",
                            "multiplierDown": "0.9500",
                            "multiplierDecimal": 4,
                        },
                    ],
                    "OrderType": [
                        "LIMIT",
                        "MARKET",
                        "STOP",
                        "TAKE_PROFIT",
                        "TRAILING_STOP_MARKET",
                    ],
                    "timeInForce": ["GTC", "IOC", "FOK", "GTX"],
                    "liquidationFee": "0.010000",
                    "marketTakeBound": "0.30",
                    "symbol": "BTCUSD_200925",
                    "pair": "BTCUSD",
                    "contractType": "CURRENT_QUARTER",
                    "deliveryDate": 1601020800000,
                    "onboardDate": 1590739200000,
                    "contractStatus": "TRADING",
                    "contractSize": 100,
                    "quoteAsset": "USD",
                    "baseAsset": "BTC",
                    "marginAsset": "BTC",
                    "pricePrecision": 1,
                    "quantityPrecision": 0,
                    "baseAssetPrecision": 8,
                    "quotePrecision": 8,
                    "equalQtyPrecision": 4,
                    "triggerProtect": "0.0500",
                    "maintMarginPercent": "2.5000",
                    "requiredMarginPercent": "5.0000",
                    "underlyingType": "COIN",
                    "underlyingSubType": [],
                }
            ],
            "timezone": "UTC",
        }

        self.set_mock_response(expected_response)

        response = self.client.exchange_information()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/exchangeInfo" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ExchangeInformationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = ExchangeInformationResponse.from_dict(expected_response)
        else:
            expected = ExchangeInformationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_exchange_information_server_error(self):
        """Test that exchange_information() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.exchange_information = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.exchange_information()

    def test_get_funding_rate_history_of_perpetual_futures_success(self):
        """Test get_funding_rate_history_of_perpetual_futures() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "symbol": "BTCUSD_PERP",
                "fundingTime": 1596038400000,
                "fundingRate": "-0.00300000",
            },
            {
                "symbol": "BTCUSD_PERP",
                "fundingTime": 1596067200000,
                "fundingRate": "-0.00300000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.get_funding_rate_history_of_perpetual_futures(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/fundingRate" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetFundingRateHistoryOfPerpetualFuturesResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = GetFundingRateHistoryOfPerpetualFuturesResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                GetFundingRateHistoryOfPerpetualFuturesResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_get_funding_rate_history_of_perpetual_futures_success_with_optional_params(
        self,
    ):
        """Test get_funding_rate_history_of_perpetual_futures() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            {
                "symbol": "BTCUSD_PERP",
                "fundingTime": 1596038400000,
                "fundingRate": "-0.00300000",
            },
            {
                "symbol": "BTCUSD_PERP",
                "fundingTime": 1596067200000,
                "fundingRate": "-0.00300000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.get_funding_rate_history_of_perpetual_futures(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/fundingRate" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetFundingRateHistoryOfPerpetualFuturesResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = GetFundingRateHistoryOfPerpetualFuturesResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                GetFundingRateHistoryOfPerpetualFuturesResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_get_funding_rate_history_of_perpetual_futures_missing_required_param_symbol(
        self,
    ):
        """Test that get_funding_rate_history_of_perpetual_futures() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_funding_rate_history_of_perpetual_futures(**params)

    def test_get_funding_rate_history_of_perpetual_futures_server_error(self):
        """Test that get_funding_rate_history_of_perpetual_futures() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.get_funding_rate_history_of_perpetual_futures = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_funding_rate_history_of_perpetual_futures(**params)

    def test_get_funding_rate_info_success(self):
        """Test get_funding_rate_info() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BLZUSDT",
                "adjustedFundingRateCap": "0.02500000",
                "adjustedFundingRateFloor": "-0.02500000",
                "fundingIntervalHours": 8,
                "disclaimer": False,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.get_funding_rate_info()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/fundingInfo" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetFundingRateInfoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = GetFundingRateInfoResponse.from_dict(expected_response)
        else:
            expected = GetFundingRateInfoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_funding_rate_info_server_error(self):
        """Test that get_funding_rate_info() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_funding_rate_info = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_funding_rate_info()

    def test_index_price_and_mark_price_success(self):
        """Test index_price_and_mark_price() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "markPrice": "11029.69574559",
                "indexPrice": "10979.14437500",
                "estimatedSettlePrice": "10981.74168236",
                "lastFundingRate": "0.00071003",
                "interestRate": "0.00010000",
                "nextFundingTime": 1596096000000,
                "time": 1596094042000,
            },
            {
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "markPrice": "12077.01343750",
                "indexPrice": "10979.10312500",
                "estimatedSettlePrice": "10981.74168236",
                "lastFundingRate": "",
                "interestRate": "",
                "nextFundingTime": 0,
                "time": 1596094042000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.index_price_and_mark_price()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/premiumIndex" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(IndexPriceAndMarkPriceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = IndexPriceAndMarkPriceResponse.from_dict(expected_response)
        else:
            expected = IndexPriceAndMarkPriceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_index_price_and_mark_price_success_with_optional_params(self):
        """Test index_price_and_mark_price() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "pair": "pair_example"}

        expected_response = [
            {
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "markPrice": "11029.69574559",
                "indexPrice": "10979.14437500",
                "estimatedSettlePrice": "10981.74168236",
                "lastFundingRate": "0.00071003",
                "interestRate": "0.00010000",
                "nextFundingTime": 1596096000000,
                "time": 1596094042000,
            },
            {
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "markPrice": "12077.01343750",
                "indexPrice": "10979.10312500",
                "estimatedSettlePrice": "10981.74168236",
                "lastFundingRate": "",
                "interestRate": "",
                "nextFundingTime": 0,
                "time": 1596094042000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.index_price_and_mark_price(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/premiumIndex" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(IndexPriceAndMarkPriceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = IndexPriceAndMarkPriceResponse.from_dict(expected_response)
        else:
            expected = IndexPriceAndMarkPriceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_index_price_and_mark_price_server_error(self):
        """Test that index_price_and_mark_price() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.index_price_and_mark_price = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.index_price_and_mark_price()

    def test_index_price_kline_candlestick_data_success(self):
        """Test index_price_kline_candlestick_data() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1591256400000,
                "9653.69440000",
                "9653.69640000",
                "9651.38600000",
                "9651.55200000",
                "0",
                1591256459999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.index_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/indexPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["interval"]
            == IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(IndexPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = IndexPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = IndexPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_index_price_kline_candlestick_data_success_with_optional_params(self):
        """Test index_price_kline_candlestick_data() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1591256400000,
                "9653.69440000",
                "9653.69640000",
                "9651.38600000",
                "9651.55200000",
                "0",
                1591256459999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.index_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/indexPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(IndexPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = IndexPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = IndexPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_index_price_kline_candlestick_data_missing_required_param_pair(self):
        """Test that index_price_kline_candlestick_data() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.index_price_kline_candlestick_data(**params)

    def test_index_price_kline_candlestick_data_missing_required_param_interval(self):
        """Test that index_price_kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["interval"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.index_price_kline_candlestick_data(**params)

    def test_index_price_kline_candlestick_data_server_error(self):
        """Test that index_price_kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.index_price_kline_candlestick_data = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.index_price_kline_candlestick_data(**params)

    def test_kline_candlestick_data_success(self):
        """Test kline_candlestick_data() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1591258320000,
                "9640.7",
                "9642.4",
                "9640.6",
                "9642.0",
                "206",
                1591258379999,
                "2.13660389",
                48,
                "119",
                "1.23424865",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/klines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["interval"]
            == KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(KlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = KlineCandlestickDataResponse.from_dict(expected_response)
        else:
            expected = KlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_kline_candlestick_data_success_with_optional_params(self):
        """Test kline_candlestick_data() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1591258320000,
                "9640.7",
                "9642.4",
                "9640.6",
                "9642.0",
                "206",
                1591258379999,
                "2.13660389",
                48,
                "119",
                "1.23424865",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/klines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(KlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = KlineCandlestickDataResponse.from_dict(expected_response)
        else:
            expected = KlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_kline_candlestick_data_missing_required_param_symbol(self):
        """Test that kline_candlestick_data() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.kline_candlestick_data(**params)

    def test_kline_candlestick_data_missing_required_param_interval(self):
        """Test that kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["interval"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.kline_candlestick_data(**params)

    def test_kline_candlestick_data_server_error(self):
        """Test that kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.kline_candlestick_data = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.kline_candlestick_data(**params)

    def test_long_short_ratio_success(self):
        """Test long_short_ratio() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "longShortRatio": "0.1960",
                "longAccount": "0.6622",
                "shortAccount": "0.3378",
                "timestamp": 1583139600000,
            },
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.9559",
                "longAccount": "0.6617",
                "shortAccount": "0.3382",
                "timestamp": 1583139900000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.long_short_ratio(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/globalLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert normalized["period"] == LongShortRatioPeriodEnum["PERIOD_5m"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(LongShortRatioResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = LongShortRatioResponse.from_dict(expected_response)
        else:
            expected = LongShortRatioResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_long_short_ratio_success_with_optional_params(self):
        """Test long_short_ratio() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "longShortRatio": "0.1960",
                "longAccount": "0.6622",
                "shortAccount": "0.3378",
                "timestamp": 1583139600000,
            },
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.9559",
                "longAccount": "0.6617",
                "shortAccount": "0.3382",
                "timestamp": 1583139900000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.long_short_ratio(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/globalLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(LongShortRatioResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = LongShortRatioResponse.from_dict(expected_response)
        else:
            expected = LongShortRatioResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_long_short_ratio_missing_required_param_pair(self):
        """Test that long_short_ratio() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.long_short_ratio(**params)

    def test_long_short_ratio_missing_required_param_period(self):
        """Test that long_short_ratio() raises RequiredError when 'period' is missing."""
        params = {
            "pair": "pair_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }
        del params["period"]

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.long_short_ratio(**params)

    def test_long_short_ratio_server_error(self):
        """Test that long_short_ratio() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.long_short_ratio = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.long_short_ratio(**params)

    def test_mark_price_kline_candlestick_data_success(self):
        """Test mark_price_kline_candlestick_data() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1591256460000,
                "9653.29201333",
                "9654.56401333",
                "9653.07367333",
                "9653.07367333",
                "0",
                1591256519999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.mark_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/markPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["interval"]
            == MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarkPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = MarkPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = MarkPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_mark_price_kline_candlestick_data_success_with_optional_params(self):
        """Test mark_price_kline_candlestick_data() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1591256460000,
                "9653.29201333",
                "9654.56401333",
                "9653.07367333",
                "9653.07367333",
                "0",
                1591256519999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.mark_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/markPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarkPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = MarkPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = MarkPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_mark_price_kline_candlestick_data_missing_required_param_symbol(self):
        """Test that mark_price_kline_candlestick_data() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.mark_price_kline_candlestick_data(**params)

    def test_mark_price_kline_candlestick_data_missing_required_param_interval(self):
        """Test that mark_price_kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["interval"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.mark_price_kline_candlestick_data(**params)

    def test_mark_price_kline_candlestick_data_server_error(self):
        """Test that mark_price_kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.mark_price_kline_candlestick_data = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.mark_price_kline_candlestick_data(**params)

    def test_old_trades_lookup_success(self):
        """Test old_trades_lookup() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "id": 595103,
                "price": "9642.2",
                "qty": "1",
                "baseQty": "0.01037108",
                "time": 1499865549590,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.old_trades_lookup(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/historicalTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OldTradesLookupResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OldTradesLookupResponse.from_dict(expected_response)
        else:
            expected = OldTradesLookupResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_old_trades_lookup_success_with_optional_params(self):
        """Test old_trades_lookup() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "limit": 100, "from_id": 1}

        expected_response = [
            {
                "id": 595103,
                "price": "9642.2",
                "qty": "1",
                "baseQty": "0.01037108",
                "time": 1499865549590,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.old_trades_lookup(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/historicalTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OldTradesLookupResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OldTradesLookupResponse.from_dict(expected_response)
        else:
            expected = OldTradesLookupResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_old_trades_lookup_missing_required_param_symbol(self):
        """Test that old_trades_lookup() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.old_trades_lookup(**params)

    def test_old_trades_lookup_server_error(self):
        """Test that old_trades_lookup() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.old_trades_lookup = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.old_trades_lookup(**params)

    def test_open_interest_success(self):
        """Test open_interest() successfully with required parameters only."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSD_200626",
            "pair": "BTCUSD",
            "openInterest": "15004",
            "contractType": "CURRENT_QUARTER",
            "time": 1591261042378,
        }

        self.set_mock_response(expected_response)

        response = self.client.open_interest(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/openInterest" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OpenInterestResponse.from_dict(expected_response)
        else:
            expected = OpenInterestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_success_with_optional_params(self):
        """Test open_interest() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSD_200626",
            "pair": "BTCUSD",
            "openInterest": "15004",
            "contractType": "CURRENT_QUARTER",
            "time": 1591261042378,
        }

        self.set_mock_response(expected_response)

        response = self.client.open_interest(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/openInterest" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OpenInterestResponse.from_dict(expected_response)
        else:
            expected = OpenInterestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_missing_required_param_symbol(self):
        """Test that open_interest() raises RequiredError when 'symbol' is missing."""
        params = {"symbol": "symbol_example"}
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.open_interest(**params)

    def test_open_interest_server_error(self):
        """Test that open_interest() raises an error when the server returns an error."""

        params = {"symbol": "symbol_example"}

        mock_error = Exception("ResponseError")
        self.client.open_interest = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.open_interest(**params)

    def test_open_interest_statistics_success(self):
        """Test open_interest_statistics() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "contract_type": OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value,
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "sumOpenInterest": "20403",
                "sumOpenInterestValue": "176196512.23400000",
                "timestamp": 1591261042378,
            },
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "sumOpenInterest": "20401",
                "sumOpenInterestValue": "176178704.98700000",
                "timestamp": 1583128200000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.open_interest_statistics(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/openInterestHist" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["contractType"]
            == OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value
        )
        assert (
            normalized["period"] == OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OpenInterestStatisticsResponse.from_dict(expected_response)
        else:
            expected = OpenInterestStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_statistics_success_with_optional_params(self):
        """Test open_interest_statistics() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "contract_type": OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value,
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "sumOpenInterest": "20403",
                "sumOpenInterestValue": "176196512.23400000",
                "timestamp": 1591261042378,
            },
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "sumOpenInterest": "20401",
                "sumOpenInterestValue": "176178704.98700000",
                "timestamp": 1583128200000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.open_interest_statistics(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/openInterestHist" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OpenInterestStatisticsResponse.from_dict(expected_response)
        else:
            expected = OpenInterestStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_statistics_missing_required_param_pair(self):
        """Test that open_interest_statistics() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value,
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.open_interest_statistics(**params)

    def test_open_interest_statistics_missing_required_param_contract_type(self):
        """Test that open_interest_statistics() raises RequiredError when 'contract_type' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value,
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }
        del params["contract_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'contract_type'"
        ):
            self.client.open_interest_statistics(**params)

    def test_open_interest_statistics_missing_required_param_period(self):
        """Test that open_interest_statistics() raises RequiredError when 'period' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value,
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }
        del params["period"]

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.open_interest_statistics(**params)

    def test_open_interest_statistics_server_error(self):
        """Test that open_interest_statistics() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "contract_type": OpenInterestStatisticsContractTypeEnum["PERPETUAL"].value,
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.open_interest_statistics = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.open_interest_statistics(**params)

    def test_order_book_success(self):
        """Test order_book() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "lastUpdateId": 16769853,
            "symbol": "BTCUSD_PERP",
            "pair": "BTCUSD",
            "E": 1591250106370,
            "T": 1591250106368,
            "bids": [["9638.0", "431"]],
            "asks": [["9638.2", "12"]],
        }

        self.set_mock_response(expected_response)

        response = self.client.order_book(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/depth" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderBookResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderBookResponse.from_dict(expected_response)
        else:
            expected = OrderBookResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_book_success_with_optional_params(self):
        """Test order_book() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "limit": 100}

        expected_response = {
            "lastUpdateId": 16769853,
            "symbol": "BTCUSD_PERP",
            "pair": "BTCUSD",
            "E": 1591250106370,
            "T": 1591250106368,
            "bids": [["9638.0", "431"]],
            "asks": [["9638.2", "12"]],
        }

        self.set_mock_response(expected_response)

        response = self.client.order_book(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/depth" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderBookResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = OrderBookResponse.from_dict(expected_response)
        else:
            expected = OrderBookResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_book_missing_required_param_symbol(self):
        """Test that order_book() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_book(**params)

    def test_order_book_server_error(self):
        """Test that order_book() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.order_book = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_book(**params)

    def test_premium_index_kline_data_success(self):
        """Test premium_index_kline_data() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1691603820000,
                "-0.00042931",
                "-0.00023641",
                "-0.00059406",
                "-0.00043659",
                "0",
                1691603879999,
                "0",
                12,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.premium_index_kline_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/premiumIndexKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["interval"]
            == PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PremiumIndexKlineDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = PremiumIndexKlineDataResponse.from_dict(expected_response)
        else:
            expected = PremiumIndexKlineDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_premium_index_kline_data_success_with_optional_params(self):
        """Test premium_index_kline_data() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1691603820000,
                "-0.00042931",
                "-0.00023641",
                "-0.00059406",
                "-0.00043659",
                "0",
                1691603879999,
                "0",
                12,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.premium_index_kline_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/premiumIndexKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PremiumIndexKlineDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = PremiumIndexKlineDataResponse.from_dict(expected_response)
        else:
            expected = PremiumIndexKlineDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_premium_index_kline_data_missing_required_param_symbol(self):
        """Test that premium_index_kline_data() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.premium_index_kline_data(**params)

    def test_premium_index_kline_data_missing_required_param_interval(self):
        """Test that premium_index_kline_data() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }
        del params["interval"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.premium_index_kline_data(**params)

    def test_premium_index_kline_data_server_error(self):
        """Test that premium_index_kline_data() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.premium_index_kline_data = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.premium_index_kline_data(**params)

    def test_query_index_price_constituents_success(self):
        """Test query_index_price_constituents() successfully with required parameters only."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSD",
            "time": 1697422647853,
            "constituents": [
                {"exchange": "bitstamp", "symbol": "btcusd"},
                {"exchange": "coinbase", "symbol": "BTC-USD"},
                {"exchange": "kraken", "symbol": "XBT/USD"},
                {"exchange": "binance_cross", "symbol": "BTCUSDC*index(USDCUSD)"},
            ],
        }

        self.set_mock_response(expected_response)

        response = self.client.query_index_price_constituents(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/constituents" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryIndexPriceConstituentsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = QueryIndexPriceConstituentsResponse.from_dict(expected_response)
        else:
            expected = QueryIndexPriceConstituentsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_index_price_constituents_success_with_optional_params(self):
        """Test query_index_price_constituents() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSD",
            "time": 1697422647853,
            "constituents": [
                {"exchange": "bitstamp", "symbol": "btcusd"},
                {"exchange": "coinbase", "symbol": "BTC-USD"},
                {"exchange": "kraken", "symbol": "XBT/USD"},
                {"exchange": "binance_cross", "symbol": "BTCUSDC*index(USDCUSD)"},
            ],
        }

        self.set_mock_response(expected_response)

        response = self.client.query_index_price_constituents(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/constituents" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryIndexPriceConstituentsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = QueryIndexPriceConstituentsResponse.from_dict(expected_response)
        else:
            expected = QueryIndexPriceConstituentsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_index_price_constituents_missing_required_param_symbol(self):
        """Test that query_index_price_constituents() raises RequiredError when 'symbol' is missing."""
        params = {"symbol": "symbol_example"}
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_index_price_constituents(**params)

    def test_query_index_price_constituents_server_error(self):
        """Test that query_index_price_constituents() raises an error when the server returns an error."""

        params = {"symbol": "symbol_example"}

        mock_error = Exception("ResponseError")
        self.client.query_index_price_constituents = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_index_price_constituents(**params)

    def test_recent_trades_list_success(self):
        """Test recent_trades_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "id": 28457,
                "price": "9635.0",
                "qty": "1",
                "baseQty": "0.01037883",
                "time": 1591250192508,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.recent_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/trades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(RecentTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = RecentTradesListResponse.from_dict(expected_response)
        else:
            expected = RecentTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_recent_trades_list_success_with_optional_params(self):
        """Test recent_trades_list() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "limit": 100}

        expected_response = [
            {
                "id": 28457,
                "price": "9635.0",
                "qty": "1",
                "baseQty": "0.01037883",
                "time": 1591250192508,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.recent_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/trades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(RecentTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = RecentTradesListResponse.from_dict(expected_response)
        else:
            expected = RecentTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_recent_trades_list_missing_required_param_symbol(self):
        """Test that recent_trades_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.recent_trades_list(**params)

    def test_recent_trades_list_server_error(self):
        """Test that recent_trades_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.recent_trades_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.recent_trades_list(**params)

    def test_symbol_order_book_ticker_success(self):
        """Test symbol_order_book_ticker() successfully with required parameters only."""

        expected_response = [
            {
                "lastUpdateId": 1027024,
                "symbol": "BTCUSD_200626",
                "pair": "BTCUSD",
                "bidPrice": "9650.1",
                "bidQty": "16",
                "askPrice": "9650.3",
                "askQty": "7",
                "time": 1591257300345,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.symbol_order_book_ticker()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/ticker/bookTicker" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolOrderBookTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SymbolOrderBookTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolOrderBookTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_order_book_ticker_success_with_optional_params(self):
        """Test symbol_order_book_ticker() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "pair": "pair_example"}

        expected_response = [
            {
                "lastUpdateId": 1027024,
                "symbol": "BTCUSD_200626",
                "pair": "BTCUSD",
                "bidPrice": "9650.1",
                "bidQty": "16",
                "askPrice": "9650.3",
                "askQty": "7",
                "time": 1591257300345,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.symbol_order_book_ticker(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/ticker/bookTicker" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolOrderBookTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SymbolOrderBookTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolOrderBookTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_order_book_ticker_server_error(self):
        """Test that symbol_order_book_ticker() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.symbol_order_book_ticker = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.symbol_order_book_ticker()

    def test_symbol_price_ticker_success(self):
        """Test symbol_price_ticker() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_200626",
                "ps": "9647.8",
                "price": "9647.8",
                "time": 1591257246176,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.symbol_price_ticker()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/ticker/price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolPriceTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SymbolPriceTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolPriceTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_price_ticker_success_with_optional_params(self):
        """Test symbol_price_ticker() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "pair": "pair_example"}

        expected_response = [
            {
                "symbol": "BTCUSD_200626",
                "ps": "9647.8",
                "price": "9647.8",
                "time": 1591257246176,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.symbol_price_ticker(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/ticker/price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolPriceTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SymbolPriceTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolPriceTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_price_ticker_server_error(self):
        """Test that symbol_price_ticker() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.symbol_price_ticker = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.symbol_price_ticker()

    def test_taker_buy_sell_volume_success(self):
        """Test taker_buy_sell_volume() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "contract_type": TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value,
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "takerBuyVol": "387",
                "takerSellVol": "248",
                "takerBuyVolValue": "2342.1220",
                "takerSellVolValue": "4213.9800",
                "timestamp": 1591261042378,
            },
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "takerBuyVol": "234",
                "takerSellVol": "121",
                "takerBuyVolValue": "4563.1320",
                "takerSellVolValue": "3313.3940",
                "timestamp": 1585615200000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.taker_buy_sell_volume(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/takerBuySellVol" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["contractType"]
            == TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value
        )
        assert normalized["period"] == TakerBuySellVolumePeriodEnum["PERIOD_5m"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TakerBuySellVolumeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = TakerBuySellVolumeResponse.from_dict(expected_response)
        else:
            expected = TakerBuySellVolumeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_taker_buy_sell_volume_success_with_optional_params(self):
        """Test taker_buy_sell_volume() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "contract_type": TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value,
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "takerBuyVol": "387",
                "takerSellVol": "248",
                "takerBuyVolValue": "2342.1220",
                "takerSellVolValue": "4213.9800",
                "timestamp": 1591261042378,
            },
            {
                "pair": "BTCUSD",
                "contractType": "CURRENT_QUARTER",
                "takerBuyVol": "234",
                "takerSellVol": "121",
                "takerBuyVolValue": "4563.1320",
                "takerSellVolValue": "3313.3940",
                "timestamp": 1585615200000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.taker_buy_sell_volume(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/takerBuySellVol" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TakerBuySellVolumeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = TakerBuySellVolumeResponse.from_dict(expected_response)
        else:
            expected = TakerBuySellVolumeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_taker_buy_sell_volume_missing_required_param_pair(self):
        """Test that taker_buy_sell_volume() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value,
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.taker_buy_sell_volume(**params)

    def test_taker_buy_sell_volume_missing_required_param_contract_type(self):
        """Test that taker_buy_sell_volume() raises RequiredError when 'contract_type' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value,
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }
        del params["contract_type"]

        with pytest.raises(
            RequiredError, match="Missing required parameter 'contract_type'"
        ):
            self.client.taker_buy_sell_volume(**params)

    def test_taker_buy_sell_volume_missing_required_param_period(self):
        """Test that taker_buy_sell_volume() raises RequiredError when 'period' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value,
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }
        del params["period"]

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.taker_buy_sell_volume(**params)

    def test_taker_buy_sell_volume_server_error(self):
        """Test that taker_buy_sell_volume() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "contract_type": TakerBuySellVolumeContractTypeEnum["PERPETUAL"].value,
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.taker_buy_sell_volume = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.taker_buy_sell_volume(**params)

    def test_test_connectivity_success(self):
        """Test test_connectivity() successfully with required parameters only."""

        self.set_mock_response({})

        response = self.client.test_connectivity()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/ping" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None

        assert response.data() == {}

    def test_test_connectivity_server_error(self):
        """Test that test_connectivity() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.test_connectivity = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.test_connectivity()

    def test_ticker24hr_price_change_statistics_success(self):
        """Test ticker24hr_price_change_statistics() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "priceChange": "136.6",
                "priceChangePercent": "1.436",
                "weightedAvgPrice": "9547.3",
                "lastPrice": "9651.6",
                "lastQty": "1",
                "openPrice": "9515.0",
                "highPrice": "9687.0",
                "lowPrice": "9499.5",
                "volume": "494109",
                "baseVolume": "5192.94797687",
                "openTime": 1591170300000,
                "closeTime": 1591256718418,
                "firstId": 600507,
                "lastId": 697803,
                "count": 97297,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.ticker24hr_price_change_statistics()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/dapi/v1/ticker/24hr" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(Ticker24hrPriceChangeStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = Ticker24hrPriceChangeStatisticsResponse.from_dict(
                expected_response
            )
        else:
            expected = Ticker24hrPriceChangeStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_ticker24hr_price_change_statistics_success_with_optional_params(self):
        """Test ticker24hr_price_change_statistics() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "pair": "pair_example"}

        expected_response = [
            {
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "priceChange": "136.6",
                "priceChangePercent": "1.436",
                "weightedAvgPrice": "9547.3",
                "lastPrice": "9651.6",
                "lastQty": "1",
                "openPrice": "9515.0",
                "highPrice": "9687.0",
                "lowPrice": "9499.5",
                "volume": "494109",
                "baseVolume": "5192.94797687",
                "openTime": 1591170300000,
                "closeTime": 1591256718418,
                "firstId": 600507,
                "lastId": 697803,
                "count": 97297,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.ticker24hr_price_change_statistics(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/dapi/v1/ticker/24hr" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(Ticker24hrPriceChangeStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = Ticker24hrPriceChangeStatisticsResponse.from_dict(
                expected_response
            )
        else:
            expected = Ticker24hrPriceChangeStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_ticker24hr_price_change_statistics_server_error(self):
        """Test that ticker24hr_price_change_statistics() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.ticker24hr_price_change_statistics = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.ticker24hr_price_change_statistics()

    def test_top_trader_long_short_ratio_accounts_success(self):
        """Test top_trader_long_short_ratio_accounts() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.8105",
                "longAccount": "0.6442",
                "shortAccount": "0.3558",
                "timestamp": 1591261042378,
            },
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.1110",
                "longAccount": "0.5263",
                "shortAccount": "0.4737",
                "timestamp": 1592870400000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_accounts(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["period"]
            == TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioAccountsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = TopTraderLongShortRatioAccountsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioAccountsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_accounts_success_with_optional_params(self):
        """Test top_trader_long_short_ratio_accounts() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.8105",
                "longAccount": "0.6442",
                "shortAccount": "0.3558",
                "timestamp": 1591261042378,
            },
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.1110",
                "longAccount": "0.5263",
                "shortAccount": "0.4737",
                "timestamp": 1592870400000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_accounts(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioAccountsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = TopTraderLongShortRatioAccountsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioAccountsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_accounts_missing_required_param_symbol(self):
        """Test that top_trader_long_short_ratio_accounts() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }
        del params["symbol"]

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.top_trader_long_short_ratio_accounts(**params)

    def test_top_trader_long_short_ratio_accounts_missing_required_param_period(self):
        """Test that top_trader_long_short_ratio_accounts() raises RequiredError when 'period' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }
        del params["period"]

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.top_trader_long_short_ratio_accounts(**params)

    def test_top_trader_long_short_ratio_accounts_server_error(self):
        """Test that top_trader_long_short_ratio_accounts() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.top_trader_long_short_ratio_accounts = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.top_trader_long_short_ratio_accounts(**params)

    def test_top_trader_long_short_ratio_positions_success(self):
        """Test top_trader_long_short_ratio_positions() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "longShortRatio": "0.7869",
                "longPosition": "0.6442",
                "shortPosition": "0.4404",
                "timestamp": 1592870400000,
            },
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.1231",
                "longPosition": "0.2363",
                "shortPosition": "0.4537",
                "timestamp": 1592956800000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_positions(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortPositionRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["period"]
            == TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioPositionsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = TopTraderLongShortRatioPositionsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioPositionsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_positions_success_with_optional_params(self):
        """Test top_trader_long_short_ratio_positions() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "pair": "BTCUSD",
                "longShortRatio": "0.7869",
                "longPosition": "0.6442",
                "shortPosition": "0.4404",
                "timestamp": 1592870400000,
            },
            {
                "pair": "BTCUSD",
                "longShortRatio": "1.1231",
                "longPosition": "0.2363",
                "shortPosition": "0.4537",
                "timestamp": 1592956800000,
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_positions(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortPositionRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioPositionsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = TopTraderLongShortRatioPositionsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioPositionsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_positions_missing_required_param_pair(self):
        """Test that top_trader_long_short_ratio_positions() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }
        del params["pair"]

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.top_trader_long_short_ratio_positions(**params)

    def test_top_trader_long_short_ratio_positions_missing_required_param_period(self):
        """Test that top_trader_long_short_ratio_positions() raises RequiredError when 'period' is missing."""
        params = {
            "pair": "pair_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }
        del params["period"]

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.top_trader_long_short_ratio_positions(**params)

    def test_top_trader_long_short_ratio_positions_server_error(self):
        """Test that top_trader_long_short_ratio_positions() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.top_trader_long_short_ratio_positions = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.top_trader_long_short_ratio_positions(**params)
