"""
Binance Derivatives Trading Options WebSocket Market Streams

OpenAPI Specification for the Binance Derivatives Trading Options WebSocket Market Streams
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest

from unittest.mock import AsyncMock, MagicMock

from binance_common.configuration import ConfigurationWebSocketStreams
from binance_common.errors import RequiredError
from binance_common.utils import ws_streams_placeholder
from binance_common.websocket import WebSocketStreamBase, RequestStreamHandle
from binance_sdk_derivatives_trading_options.websocket_streams.streams import MarketApi


@pytest.fixture
def mock_websocket_client():
    """Fixture to provide a reusable mocked WebSocketStreamBase instance."""
    config = ConfigurationWebSocketStreams(stream_url="wss://mock-url")
    websocket_stream_client = WebSocketStreamBase(config)
    websocket_stream_client.subscribe = AsyncMock()
    websocket_stream_client.unsubscribe = AsyncMock()
    return websocket_stream_client


class TestWebSocketStreams:
    @pytest.fixture(autouse=True)
    def setup(self, mock_websocket_client):
        self.websocket_client = mock_websocket_client
        self.ws_streams = MarketApi(websocket_base=self.websocket_client)

    @pytest.mark.asyncio
    async def test_index_price_streams_subscription(self):
        """Test that index_price_streams() subscribes to the correct WebSocket stream."""

        expected_response = [
            {
                "e": "indexPrice",
                "E": 1763092572229,
                "s": "ETHUSDT",
                "p": "3224.51976744",
            },
            {
                "e": "indexPrice",
                "E": 1763092572229,
                "s": "BTCUSDT",
                "p": "99102.32326087",
            },
        ]
        stream_endpoint = ws_streams_placeholder(
            "/!index@arr".replace("/", "", 1),
            {},
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.index_price_streams()
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_index_price_streams_success(self):
        """Test index_price_streams() successfully with required parameters only."""

        expected_response = [
            {
                "e": "indexPrice",
                "E": 1763092572229,
                "s": "ETHUSDT",
                "p": "3224.51976744",
            },
            {
                "e": "indexPrice",
                "E": 1763092572229,
                "s": "BTCUSDT",
                "p": "99102.32326087",
            },
        ]
        self.ws_streams.index_price_streams = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.index_price_streams()
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_index_price_streams_success_with_optional_params(self):
        """Test index_price_streams() successfully with optional parameters."""

        params = {"id": 532601580}

        expected_response = [
            {
                "e": "indexPrice",
                "E": 1763092572229,
                "s": "ETHUSDT",
                "p": "3224.51976744",
            },
            {
                "e": "indexPrice",
                "E": 1763092572229,
                "s": "BTCUSDT",
                "p": "99102.32326087",
            },
        ]

        self.ws_streams.index_price_streams = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.index_price_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_index_price_streams_server_error(self):
        """Test that index_price_streams() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.ws_streams.index_price_streams = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.index_price_streams()

    @pytest.mark.asyncio
    async def test_kline_candlestick_streams_subscription(self):
        """Test that kline_candlestick_streams() subscribes to the correct WebSocket stream."""

        params = {
            "symbol": "btcusdt",
            "interval": "1m",
        }

        expected_response = {
            "e": "kline",
            "E": 1638747660000,
            "s": "BTC-200630-9000-P",
            "k": {
                "t": 1638747660000,
                "T": 1638747719999,
                "s": "BTC-200630-9000-P",
                "i": "1m",
                "f": 0,
                "L": 0,
                "o": "1000",
                "c": "1000",
                "h": "1000",
                "l": "1000",
                "v": "0",
                "n": 0,
                "x": False,
                "q": "0",
                "V": "0",
                "Q": "0",
            },
        }
        stream_endpoint = ws_streams_placeholder(
            "/<symbol>@kline_<interval>".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.kline_candlestick_streams(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_kline_candlestick_streams_success(self):
        """Test kline_candlestick_streams() successfully with required parameters only."""

        params = {
            "symbol": "btcusdt",
            "interval": "1m",
        }

        expected_response = {
            "e": "kline",
            "E": 1638747660000,
            "s": "BTC-200630-9000-P",
            "k": {
                "t": 1638747660000,
                "T": 1638747719999,
                "s": "BTC-200630-9000-P",
                "i": "1m",
                "f": 0,
                "L": 0,
                "o": "1000",
                "c": "1000",
                "h": "1000",
                "l": "1000",
                "v": "0",
                "n": 0,
                "x": False,
                "q": "0",
                "V": "0",
                "Q": "0",
            },
        }
        self.ws_streams.kline_candlestick_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.kline_candlestick_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_kline_candlestick_streams_success_with_optional_params(self):
        """Test kline_candlestick_streams() successfully with optional parameters."""

        params = {"symbol": "btcusdt", "interval": "1m", "id": 532601580}

        expected_response = {
            "e": "kline",
            "E": 1638747660000,
            "s": "BTC-200630-9000-P",
            "k": {
                "t": 1638747660000,
                "T": 1638747719999,
                "s": "BTC-200630-9000-P",
                "i": "1m",
                "f": 0,
                "L": 0,
                "o": "1000",
                "c": "1000",
                "h": "1000",
                "l": "1000",
                "v": "0",
                "n": 0,
                "x": False,
                "q": "0",
                "V": "0",
                "Q": "0",
            },
        }

        self.ws_streams.kline_candlestick_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.kline_candlestick_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_kline_candlestick_streams_missing_required_param_symbol(self):
        """Test that kline_candlestick_streams() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "btcusdt",
            "interval": "1m",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.ws_streams.kline_candlestick_streams(**params)

    @pytest.mark.asyncio
    async def test_kline_candlestick_streams_missing_required_param_interval(self):
        """Test that kline_candlestick_streams() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "btcusdt",
            "interval": "1m",
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            await self.ws_streams.kline_candlestick_streams(**params)

    @pytest.mark.asyncio
    async def test_kline_candlestick_streams_server_error(self):
        """Test that kline_candlestick_streams() raises an error when the server returns an error."""

        params = {
            "symbol": "btcusdt",
            "interval": "1m",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.kline_candlestick_streams = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.kline_candlestick_streams(**params)

    @pytest.mark.asyncio
    async def test_mark_price_subscription(self):
        """Test that mark_price() subscribes to the correct WebSocket stream."""

        params = {
            "underlying": "btcusdt",
        }

        expected_response = [
            {
                "s": "BTC-251120-126000-C",
                "mp": "770.543",
                "E": 1762867543321,
                "e": "markPrice",
                "i": "104334.60217391",
                "P": "0.000",
                "bo": "0.000",
                "ao": "900.000",
                "bq": "0.0000",
                "aq": "0.2000",
                "b": "-1.0",
                "a": "0.98161161",
                "hl": "924.652",
                "ll": "616.435",
                "vo": "0.9408058",
                "rf": "0.0",
                "d": "0.11111964",
                "t": "-164.26702615",
                "g": "0.00001245",
                "v": "30.63855919",
            },
            {
                "s": "BTC-251123-126000-C",
                "mp": "1249.61",
                "E": 1762867543321,
                "e": "markPrice",
                "i": "104334.60217391",
                "P": "0.000",
                "bo": "1200.000",
                "ao": "1300.000",
                "bq": "0.3000",
                "aq": "0.6000",
                "b": "0.92159033",
                "a": "0.94461441",
                "hl": "1499.533",
                "ll": "999.688",
                "vo": "0.93310237",
                "rf": "0.0",
                "d": "0.14869196",
                "t": "-172.12148811",
                "g": "0.00001326",
                "v": "43.43627792",
            },
        ]
        stream_endpoint = ws_streams_placeholder(
            "/<underlying>@optionMarkPrice".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.mark_price(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_mark_price_success(self):
        """Test mark_price() successfully with required parameters only."""

        params = {
            "underlying": "btcusdt",
        }

        expected_response = [
            {
                "s": "BTC-251120-126000-C",
                "mp": "770.543",
                "E": 1762867543321,
                "e": "markPrice",
                "i": "104334.60217391",
                "P": "0.000",
                "bo": "0.000",
                "ao": "900.000",
                "bq": "0.0000",
                "aq": "0.2000",
                "b": "-1.0",
                "a": "0.98161161",
                "hl": "924.652",
                "ll": "616.435",
                "vo": "0.9408058",
                "rf": "0.0",
                "d": "0.11111964",
                "t": "-164.26702615",
                "g": "0.00001245",
                "v": "30.63855919",
            },
            {
                "s": "BTC-251123-126000-C",
                "mp": "1249.61",
                "E": 1762867543321,
                "e": "markPrice",
                "i": "104334.60217391",
                "P": "0.000",
                "bo": "1200.000",
                "ao": "1300.000",
                "bq": "0.3000",
                "aq": "0.6000",
                "b": "0.92159033",
                "a": "0.94461441",
                "hl": "1499.533",
                "ll": "999.688",
                "vo": "0.93310237",
                "rf": "0.0",
                "d": "0.14869196",
                "t": "-172.12148811",
                "g": "0.00001326",
                "v": "43.43627792",
            },
        ]
        self.ws_streams.mark_price = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.mark_price(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_mark_price_success_with_optional_params(self):
        """Test mark_price() successfully with optional parameters."""

        params = {"underlying": "btcusdt", "id": 532601580}

        expected_response = [
            {
                "s": "BTC-251120-126000-C",
                "mp": "770.543",
                "E": 1762867543321,
                "e": "markPrice",
                "i": "104334.60217391",
                "P": "0.000",
                "bo": "0.000",
                "ao": "900.000",
                "bq": "0.0000",
                "aq": "0.2000",
                "b": "-1.0",
                "a": "0.98161161",
                "hl": "924.652",
                "ll": "616.435",
                "vo": "0.9408058",
                "rf": "0.0",
                "d": "0.11111964",
                "t": "-164.26702615",
                "g": "0.00001245",
                "v": "30.63855919",
            },
            {
                "s": "BTC-251123-126000-C",
                "mp": "1249.61",
                "E": 1762867543321,
                "e": "markPrice",
                "i": "104334.60217391",
                "P": "0.000",
                "bo": "1200.000",
                "ao": "1300.000",
                "bq": "0.3000",
                "aq": "0.6000",
                "b": "0.92159033",
                "a": "0.94461441",
                "hl": "1499.533",
                "ll": "999.688",
                "vo": "0.93310237",
                "rf": "0.0",
                "d": "0.14869196",
                "t": "-172.12148811",
                "g": "0.00001326",
                "v": "43.43627792",
            },
        ]

        self.ws_streams.mark_price = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.mark_price(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_mark_price_missing_required_param_underlying(self):
        """Test that mark_price() raises RequiredError when 'underlying' is missing."""
        params = {
            "underlying": "btcusdt",
        }
        params["underlying"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'underlying'"
        ):
            await self.ws_streams.mark_price(**params)

    @pytest.mark.asyncio
    async def test_mark_price_server_error(self):
        """Test that mark_price() raises an error when the server returns an error."""

        params = {
            "underlying": "btcusdt",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.mark_price = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.mark_price(**params)

    @pytest.mark.asyncio
    async def test_new_symbol_info_subscription(self):
        """Test that new_symbol_info() subscribes to the correct WebSocket stream."""

        expected_response = {
            "e": "optionSymbol",
            "E": 1669356423908,
            "s": "BTC-250926-140000-C",
            "ps": "BTCUSDT",
            "qa": "USDT",
            "d": "CALL",
            "sp": "21000",
            "dt": 4133404800000,
            "u": 1,
            "ot": 1569398400000,
            "cs": "TRADING",
        }
        stream_endpoint = ws_streams_placeholder(
            "/!optionSymbol".replace("/", "", 1),
            {},
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.new_symbol_info()
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_new_symbol_info_success(self):
        """Test new_symbol_info() successfully with required parameters only."""

        expected_response = {
            "e": "optionSymbol",
            "E": 1669356423908,
            "s": "BTC-250926-140000-C",
            "ps": "BTCUSDT",
            "qa": "USDT",
            "d": "CALL",
            "sp": "21000",
            "dt": 4133404800000,
            "u": 1,
            "ot": 1569398400000,
            "cs": "TRADING",
        }
        self.ws_streams.new_symbol_info = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.new_symbol_info()
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_new_symbol_info_success_with_optional_params(self):
        """Test new_symbol_info() successfully with optional parameters."""

        params = {"id": 532601580}

        expected_response = {
            "e": "optionSymbol",
            "E": 1669356423908,
            "s": "BTC-250926-140000-C",
            "ps": "BTCUSDT",
            "qa": "USDT",
            "d": "CALL",
            "sp": "21000",
            "dt": 4133404800000,
            "u": 1,
            "ot": 1569398400000,
            "cs": "TRADING",
        }

        self.ws_streams.new_symbol_info = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.new_symbol_info(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_new_symbol_info_server_error(self):
        """Test that new_symbol_info() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.ws_streams.new_symbol_info = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.new_symbol_info()

    @pytest.mark.asyncio
    async def test_open_interest_subscription(self):
        """Test that open_interest() subscribes to the correct WebSocket stream."""

        params = {
            "expiration_date": "220930",
        }

        expected_response = [
            {
                "e": "openInterest",
                "E": 1668759300045,
                "s": "ETH-221125-2700-C",
                "o": "1580.87",
                "h": "1912992.178168204",
            }
        ]
        stream_endpoint = ws_streams_placeholder(
            "/underlying@optionOpenInterest@<expirationDate>".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.open_interest(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_open_interest_success(self):
        """Test open_interest() successfully with required parameters only."""

        params = {
            "expiration_date": "220930",
        }

        expected_response = [
            {
                "e": "openInterest",
                "E": 1668759300045,
                "s": "ETH-221125-2700-C",
                "o": "1580.87",
                "h": "1912992.178168204",
            }
        ]
        self.ws_streams.open_interest = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.open_interest(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_open_interest_success_with_optional_params(self):
        """Test open_interest() successfully with optional parameters."""

        params = {"expiration_date": "220930", "id": 532601580}

        expected_response = [
            {
                "e": "openInterest",
                "E": 1668759300045,
                "s": "ETH-221125-2700-C",
                "o": "1580.87",
                "h": "1912992.178168204",
            }
        ]

        self.ws_streams.open_interest = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.open_interest(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_open_interest_missing_required_param_expiration_date(self):
        """Test that open_interest() raises RequiredError when 'expiration_date' is missing."""
        params = {
            "expiration_date": "220930",
        }
        params["expiration_date"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'expiration_date'"
        ):
            await self.ws_streams.open_interest(**params)

    @pytest.mark.asyncio
    async def test_open_interest_server_error(self):
        """Test that open_interest() raises an error when the server returns an error."""

        params = {
            "expiration_date": "220930",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.open_interest = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.open_interest(**params)
