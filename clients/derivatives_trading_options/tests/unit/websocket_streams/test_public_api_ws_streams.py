"""
Binance Derivatives Trading Options WebSocket Market Streams

OpenAPI Specification for the Binance Derivatives Trading Options WebSocket Market Streams
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import pytest

from unittest.mock import AsyncMock, MagicMock

from binance_common.configuration import ConfigurationWebSocketStreams
from binance_common.errors import RequiredError
from binance_common.utils import ws_streams_placeholder
from binance_common.websocket import WebSocketStreamBase, RequestStreamHandle
from binance_sdk_derivatives_trading_options.websocket_streams.streams import PublicApi


@pytest.fixture
def mock_websocket_client():
    """Fixture to provide a reusable mocked WebSocketStreamBase instance."""
    config = ConfigurationWebSocketStreams(stream_url="wss://mock-url")
    websocket_stream_client = WebSocketStreamBase(config)
    websocket_stream_client.subscribe = AsyncMock()
    websocket_stream_client.unsubscribe = AsyncMock()
    return websocket_stream_client


class TestWebSocketStreams:
    @pytest.fixture(autouse=True)
    def setup(self, mock_websocket_client):
        self.websocket_client = mock_websocket_client
        self.ws_streams = PublicApi(websocket_base=self.websocket_client)

    @pytest.mark.asyncio
    async def test_diff_book_depth_streams_subscription(self):
        """Test that diff_book_depth_streams() subscribes to the correct WebSocket stream."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "depthUpdate",
            "E": 1762866729459,
            "T": 1762866729358,
            "s": "BTC-251123-126000-C",
            "U": 465,
            "u": 465,
            "pu": 464,
            "b": [["1100.000", "0.6000"]],
            "a": [["1300.000", "0.6000"]],
        }
        stream_endpoint = ws_streams_placeholder(
            "/<symbol>@depth@<updateSpeed>".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.diff_book_depth_streams(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_diff_book_depth_streams_success(self):
        """Test diff_book_depth_streams() successfully with required parameters only."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "depthUpdate",
            "E": 1762866729459,
            "T": 1762866729358,
            "s": "BTC-251123-126000-C",
            "U": 465,
            "u": 465,
            "pu": 464,
            "b": [["1100.000", "0.6000"]],
            "a": [["1300.000", "0.6000"]],
        }
        self.ws_streams.diff_book_depth_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.diff_book_depth_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_diff_book_depth_streams_success_with_optional_params(self):
        """Test diff_book_depth_streams() successfully with optional parameters."""

        params = {
            "symbol": "btcusdt",
            "id": 532601580,
            "update_speed": "update_speed_example",
        }

        expected_response = {
            "e": "depthUpdate",
            "E": 1762866729459,
            "T": 1762866729358,
            "s": "BTC-251123-126000-C",
            "U": 465,
            "u": 465,
            "pu": 464,
            "b": [["1100.000", "0.6000"]],
            "a": [["1300.000", "0.6000"]],
        }

        self.ws_streams.diff_book_depth_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.diff_book_depth_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_diff_book_depth_streams_missing_required_param_symbol(self):
        """Test that diff_book_depth_streams() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "btcusdt",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.ws_streams.diff_book_depth_streams(**params)

    @pytest.mark.asyncio
    async def test_diff_book_depth_streams_server_error(self):
        """Test that diff_book_depth_streams() raises an error when the server returns an error."""

        params = {
            "symbol": "btcusdt",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.diff_book_depth_streams = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.diff_book_depth_streams(**params)

    @pytest.mark.asyncio
    async def test_individual_symbol_book_ticker_streams_subscription(self):
        """Test that individual_symbol_book_ticker_streams() subscribes to the correct WebSocket stream."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "bookTicker",
            "u": 2472,
            "s": "BTC-251226-110000-C",
            "b": "5000.000",
            "B": "0.2000",
            "a": "5100.000",
            "A": "0.1000",
            "T": 1763041762942,
            "E": 1763041762942,
        }
        stream_endpoint = ws_streams_placeholder(
            "/<symbol>@bookTicker".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.individual_symbol_book_ticker_streams(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_individual_symbol_book_ticker_streams_success(self):
        """Test individual_symbol_book_ticker_streams() successfully with required parameters only."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "bookTicker",
            "u": 2472,
            "s": "BTC-251226-110000-C",
            "b": "5000.000",
            "B": "0.2000",
            "a": "5100.000",
            "A": "0.1000",
            "T": 1763041762942,
            "E": 1763041762942,
        }
        self.ws_streams.individual_symbol_book_ticker_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.individual_symbol_book_ticker_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_individual_symbol_book_ticker_streams_success_with_optional_params(
        self,
    ):
        """Test individual_symbol_book_ticker_streams() successfully with optional parameters."""

        params = {"symbol": "btcusdt", "id": 532601580}

        expected_response = {
            "e": "bookTicker",
            "u": 2472,
            "s": "BTC-251226-110000-C",
            "b": "5000.000",
            "B": "0.2000",
            "a": "5100.000",
            "A": "0.1000",
            "T": 1763041762942,
            "E": 1763041762942,
        }

        self.ws_streams.individual_symbol_book_ticker_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.individual_symbol_book_ticker_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_individual_symbol_book_ticker_streams_missing_required_param_symbol(
        self,
    ):
        """Test that individual_symbol_book_ticker_streams() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "btcusdt",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.ws_streams.individual_symbol_book_ticker_streams(**params)

    @pytest.mark.asyncio
    async def test_individual_symbol_book_ticker_streams_server_error(self):
        """Test that individual_symbol_book_ticker_streams() raises an error when the server returns an error."""

        params = {
            "symbol": "btcusdt",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.individual_symbol_book_ticker_streams = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.individual_symbol_book_ticker_streams(**params)

    @pytest.mark.asyncio
    async def test_partial_book_depth_streams_subscription(self):
        """Test that partial_book_depth_streams() subscribes to the correct WebSocket stream."""

        params = {
            "symbol": "btcusdt",
            "level": "example_value",
        }

        expected_response = {
            "e": "depthUpdate",
            "E": 1762866729459,
            "T": 1762866729358,
            "s": "BTC-251123-126000-C",
            "U": 465,
            "u": 465,
            "pu": 464,
            "b": [["1100.000", "0.6000"]],
            "a": [["1300.000", "0.6000"]],
        }
        stream_endpoint = ws_streams_placeholder(
            "/<symbol>@depth<level>@<updateSpeed>".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.partial_book_depth_streams(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_partial_book_depth_streams_success(self):
        """Test partial_book_depth_streams() successfully with required parameters only."""

        params = {
            "symbol": "btcusdt",
            "level": "example_value",
        }

        expected_response = {
            "e": "depthUpdate",
            "E": 1762866729459,
            "T": 1762866729358,
            "s": "BTC-251123-126000-C",
            "U": 465,
            "u": 465,
            "pu": 464,
            "b": [["1100.000", "0.6000"]],
            "a": [["1300.000", "0.6000"]],
        }
        self.ws_streams.partial_book_depth_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.partial_book_depth_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_partial_book_depth_streams_success_with_optional_params(self):
        """Test partial_book_depth_streams() successfully with optional parameters."""

        params = {
            "symbol": "btcusdt",
            "level": "example_value",
            "id": 532601580,
            "update_speed": "update_speed_example",
        }

        expected_response = {
            "e": "depthUpdate",
            "E": 1762866729459,
            "T": 1762866729358,
            "s": "BTC-251123-126000-C",
            "U": 465,
            "u": 465,
            "pu": 464,
            "b": [["1100.000", "0.6000"]],
            "a": [["1300.000", "0.6000"]],
        }

        self.ws_streams.partial_book_depth_streams = AsyncMock(
            return_value=expected_response
        )

        response = await self.ws_streams.partial_book_depth_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_partial_book_depth_streams_missing_required_param_symbol(self):
        """Test that partial_book_depth_streams() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "btcusdt",
            "level": "example_value",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.ws_streams.partial_book_depth_streams(**params)

    @pytest.mark.asyncio
    async def test_partial_book_depth_streams_missing_required_param_level(self):
        """Test that partial_book_depth_streams() raises RequiredError when 'level' is missing."""
        params = {
            "symbol": "btcusdt",
            "level": "example_value",
        }
        params["level"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'level'"):
            await self.ws_streams.partial_book_depth_streams(**params)

    @pytest.mark.asyncio
    async def test_partial_book_depth_streams_server_error(self):
        """Test that partial_book_depth_streams() raises an error when the server returns an error."""

        params = {
            "symbol": "btcusdt",
            "level": "example_value",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.partial_book_depth_streams = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.partial_book_depth_streams(**params)

    @pytest.mark.asyncio
    async def test_ticker24_hour_subscription(self):
        """Test that ticker24_hour() subscribes to the correct WebSocket stream."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "24hrTicker",
            "E": 1764080707933,
            "s": "ETH-251226-3000-C",
            "p": "0.0000",
            "P": "0.00",
            "w": "200.0000",
            "c": "200.0000",
            "Q": "1.0000",
            "o": "200.0000",
            "h": "200.0000",
            "l": "200.0000",
            "v": "9.0000",
            "q": "1800.0000",
            "O": 1764051060000,
            "C": 1764080707933,
            "F": 1,
            "L": 22,
            "n": 9,
        }
        stream_endpoint = ws_streams_placeholder(
            "/<symbol>@optionTicker".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.ticker24_hour(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_ticker24_hour_success(self):
        """Test ticker24_hour() successfully with required parameters only."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "24hrTicker",
            "E": 1764080707933,
            "s": "ETH-251226-3000-C",
            "p": "0.0000",
            "P": "0.00",
            "w": "200.0000",
            "c": "200.0000",
            "Q": "1.0000",
            "o": "200.0000",
            "h": "200.0000",
            "l": "200.0000",
            "v": "9.0000",
            "q": "1800.0000",
            "O": 1764051060000,
            "C": 1764080707933,
            "F": 1,
            "L": 22,
            "n": 9,
        }
        self.ws_streams.ticker24_hour = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.ticker24_hour(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_ticker24_hour_success_with_optional_params(self):
        """Test ticker24_hour() successfully with optional parameters."""

        params = {"symbol": "btcusdt", "id": 532601580}

        expected_response = {
            "e": "24hrTicker",
            "E": 1764080707933,
            "s": "ETH-251226-3000-C",
            "p": "0.0000",
            "P": "0.00",
            "w": "200.0000",
            "c": "200.0000",
            "Q": "1.0000",
            "o": "200.0000",
            "h": "200.0000",
            "l": "200.0000",
            "v": "9.0000",
            "q": "1800.0000",
            "O": 1764051060000,
            "C": 1764080707933,
            "F": 1,
            "L": 22,
            "n": 9,
        }

        self.ws_streams.ticker24_hour = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.ticker24_hour(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_ticker24_hour_missing_required_param_symbol(self):
        """Test that ticker24_hour() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "btcusdt",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.ws_streams.ticker24_hour(**params)

    @pytest.mark.asyncio
    async def test_ticker24_hour_server_error(self):
        """Test that ticker24_hour() raises an error when the server returns an error."""

        params = {
            "symbol": "btcusdt",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.ticker24_hour = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.ticker24_hour(**params)

    @pytest.mark.asyncio
    async def test_trade_streams_subscription(self):
        """Test that trade_streams() subscribes to the correct WebSocket stream."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "trade",
            "E": 1762856064204,
            "T": 1762856064203,
            "s": "BTC-251123-126000-C",
            "t": 4,
            "p": "1300.000",
            "q": "0.1000",
            "X": "MARKET",
            "S": "BUY",
            "m": False,
        }
        stream_endpoint = ws_streams_placeholder(
            "/<symbol>@optionTrade".replace("/", "", 1),
            params,
        )

        def mock_on(event, callback, stream):
            if event == "message" and stream == stream_endpoint:
                callback(expected_response)

        self.websocket_client.on = MagicMock(side_effect=mock_on)

        mock_callback = MagicMock()

        stream = await self.ws_streams.trade_streams(**params)
        assert isinstance(stream, RequestStreamHandle)
        assert callable(stream.on)
        assert callable(stream.unsubscribe)
        stream.on("message", mock_callback)
        mock_callback.assert_called_once_with(expected_response)

    @pytest.mark.asyncio
    async def test_trade_streams_success(self):
        """Test trade_streams() successfully with required parameters only."""

        params = {
            "symbol": "btcusdt",
        }

        expected_response = {
            "e": "trade",
            "E": 1762856064204,
            "T": 1762856064203,
            "s": "BTC-251123-126000-C",
            "t": 4,
            "p": "1300.000",
            "q": "0.1000",
            "X": "MARKET",
            "S": "BUY",
            "m": False,
        }
        self.ws_streams.trade_streams = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.trade_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_trade_streams_success_with_optional_params(self):
        """Test trade_streams() successfully with optional parameters."""

        params = {"symbol": "btcusdt", "id": 532601580}

        expected_response = {
            "e": "trade",
            "E": 1762856064204,
            "T": 1762856064203,
            "s": "BTC-251123-126000-C",
            "t": 4,
            "p": "1300.000",
            "q": "0.1000",
            "X": "MARKET",
            "S": "BUY",
            "m": False,
        }

        self.ws_streams.trade_streams = AsyncMock(return_value=expected_response)

        response = await self.ws_streams.trade_streams(**params)
        assert response is not None
        assert response == expected_response

    @pytest.mark.asyncio
    async def test_trade_streams_missing_required_param_symbol(self):
        """Test that trade_streams() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "btcusdt",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            await self.ws_streams.trade_streams(**params)

    @pytest.mark.asyncio
    async def test_trade_streams_server_error(self):
        """Test that trade_streams() raises an error when the server returns an error."""

        params = {
            "symbol": "btcusdt",
        }

        mock_error = Exception("ResponseError")
        self.ws_streams.trade_streams = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            await self.ws_streams.trade_streams(**params)
