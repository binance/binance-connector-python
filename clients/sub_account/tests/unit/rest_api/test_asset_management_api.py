"""
Binance Sub Account REST API

OpenAPI Specification for the Binance Sub Account REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_sub_account.rest_api.api import AssetManagementApi
from binance_sdk_sub_account.rest_api.models import FuturesTransferForSubAccountResponse
from binance_sdk_sub_account.rest_api.models import (
    GetDetailOnSubAccountsFuturesAccountResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    GetDetailOnSubAccountsFuturesAccountV2Response,
)
from binance_sdk_sub_account.rest_api.models import (
    GetDetailOnSubAccountsMarginAccountResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    GetMovePositionHistoryForSubAccountResponse,
)
from binance_sdk_sub_account.rest_api.models import GetSubAccountDepositAddressResponse
from binance_sdk_sub_account.rest_api.models import GetSubAccountDepositHistoryResponse
from binance_sdk_sub_account.rest_api.models import (
    GetSummaryOfSubAccountsFuturesAccountResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    GetSummaryOfSubAccountsFuturesAccountV2Response,
)
from binance_sdk_sub_account.rest_api.models import (
    GetSummaryOfSubAccountsMarginAccountResponse,
)
from binance_sdk_sub_account.rest_api.models import MarginTransferForSubAccountResponse
from binance_sdk_sub_account.rest_api.models import MovePositionForSubAccountResponse
from binance_sdk_sub_account.rest_api.models import QuerySubAccountAssetsResponse
from binance_sdk_sub_account.rest_api.models import (
    QuerySubAccountAssetsAssetManagementResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    QuerySubAccountFuturesAssetTransferHistoryResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    QuerySubAccountSpotAssetTransferHistoryResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    QuerySubAccountSpotAssetsSummaryResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    QueryUniversalTransferHistoryResponse,
)
from binance_sdk_sub_account.rest_api.models import (
    SubAccountFuturesAssetTransferResponse,
)
from binance_sdk_sub_account.rest_api.models import SubAccountTransferHistoryResponse
from binance_sdk_sub_account.rest_api.models import TransferToMasterResponse
from binance_sdk_sub_account.rest_api.models import (
    TransferToSubAccountOfSameMasterResponse,
)
from binance_sdk_sub_account.rest_api.models import UniversalTransferResponse


from binance_sdk_sub_account.rest_api.models import (
    MovePositionForSubAccountOrderArgsParameterInner,
)


class TestAssetManagementApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = AssetManagementApi(
            configuration=config, session=self.mock_session
        )

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_futures_transfer_for_sub_account_success(self, mock_get_signature):
        """Test futures_transfer_for_sub_account() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.futures_transfer_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/transfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["email"] == "sub-account-email@email.com"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0
        assert normalized["type"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(FuturesTransferForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(FuturesTransferForSubAccountResponse, "from_dict")
        ):
            expected = FuturesTransferForSubAccountResponse.from_dict(expected_response)
        else:
            expected = FuturesTransferForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_futures_transfer_for_sub_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test futures_transfer_for_sub_account() successfully with optional parameters."""

        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
            "recv_window": 5000,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.futures_transfer_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/transfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(FuturesTransferForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(FuturesTransferForSubAccountResponse, "from_dict")
        ):
            expected = FuturesTransferForSubAccountResponse.from_dict(expected_response)
        else:
            expected = FuturesTransferForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_futures_transfer_for_sub_account_missing_required_param_email(self):
        """Test that futures_transfer_for_sub_account() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.futures_transfer_for_sub_account(**params)

    def test_futures_transfer_for_sub_account_missing_required_param_asset(self):
        """Test that futures_transfer_for_sub_account() raises RequiredError when 'asset' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.futures_transfer_for_sub_account(**params)

    def test_futures_transfer_for_sub_account_missing_required_param_amount(self):
        """Test that futures_transfer_for_sub_account() raises RequiredError when 'amount' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.futures_transfer_for_sub_account(**params)

    def test_futures_transfer_for_sub_account_missing_required_param_type(self):
        """Test that futures_transfer_for_sub_account() raises RequiredError when 'type' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.futures_transfer_for_sub_account(**params)

    def test_futures_transfer_for_sub_account_server_error(self):
        """Test that futures_transfer_for_sub_account() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.futures_transfer_for_sub_account = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.futures_transfer_for_sub_account(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_detail_on_sub_accounts_futures_account_success(
        self, mock_get_signature
    ):
        """Test get_detail_on_sub_accounts_futures_account() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
        }

        expected_response = {
            "email": "abc@test.com",
            "asset": "USDT",
            "assets": [
                {
                    "asset": "USDT",
                    "initialMargin": "0.00000000",
                    "maintenanceMargin": "0.00000000",
                    "marginBalance": "0.88308000",
                    "maxWithdrawAmount": "0.88308000",
                    "openOrderInitialMargin": "0.00000000",
                    "positionInitialMargin": "0.00000000",
                    "unrealizedProfit": "0.00000000",
                    "walletBalance": "0.88308000",
                }
            ],
            "canDeposit": True,
            "canTrade": True,
            "canWithdraw": True,
            "feeTier": 2,
            "maxWithdrawAmount": "0.88308000",
            "totalInitialMargin": "0.00000000",
            "totalMaintenanceMargin": "0.00000000",
            "totalMarginBalance": "0.88308000",
            "totalOpenOrderInitialMargin": "0.00000000",
            "totalPositionInitialMargin": "0.00000000",
            "totalUnrealizedProfit": "0.00000000",
            "totalWalletBalance": "0.88308000",
            "updateTime": 1576756674610,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_detail_on_sub_accounts_futures_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetDetailOnSubAccountsFuturesAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetDetailOnSubAccountsFuturesAccountResponse, "from_dict")
        ):
            expected = GetDetailOnSubAccountsFuturesAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetDetailOnSubAccountsFuturesAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_detail_on_sub_accounts_futures_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_detail_on_sub_accounts_futures_account() successfully with optional parameters."""

        params = {"email": "sub-account-email@email.com", "recv_window": 5000}

        expected_response = {
            "email": "abc@test.com",
            "asset": "USDT",
            "assets": [
                {
                    "asset": "USDT",
                    "initialMargin": "0.00000000",
                    "maintenanceMargin": "0.00000000",
                    "marginBalance": "0.88308000",
                    "maxWithdrawAmount": "0.88308000",
                    "openOrderInitialMargin": "0.00000000",
                    "positionInitialMargin": "0.00000000",
                    "unrealizedProfit": "0.00000000",
                    "walletBalance": "0.88308000",
                }
            ],
            "canDeposit": True,
            "canTrade": True,
            "canWithdraw": True,
            "feeTier": 2,
            "maxWithdrawAmount": "0.88308000",
            "totalInitialMargin": "0.00000000",
            "totalMaintenanceMargin": "0.00000000",
            "totalMarginBalance": "0.88308000",
            "totalOpenOrderInitialMargin": "0.00000000",
            "totalPositionInitialMargin": "0.00000000",
            "totalUnrealizedProfit": "0.00000000",
            "totalWalletBalance": "0.88308000",
            "updateTime": 1576756674610,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_detail_on_sub_accounts_futures_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetDetailOnSubAccountsFuturesAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetDetailOnSubAccountsFuturesAccountResponse, "from_dict")
        ):
            expected = GetDetailOnSubAccountsFuturesAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetDetailOnSubAccountsFuturesAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_detail_on_sub_accounts_futures_account_missing_required_param_email(
        self,
    ):
        """Test that get_detail_on_sub_accounts_futures_account() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.get_detail_on_sub_accounts_futures_account(**params)

    def test_get_detail_on_sub_accounts_futures_account_server_error(self):
        """Test that get_detail_on_sub_accounts_futures_account() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
        }

        mock_error = Exception("ResponseError")
        self.client.get_detail_on_sub_accounts_futures_account = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_detail_on_sub_accounts_futures_account(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_detail_on_sub_accounts_futures_account_v2_success(
        self, mock_get_signature
    ):
        """Test get_detail_on_sub_accounts_futures_account_v2() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }

        expected_response = {
            "futureAccountResp": {
                "email": "abc@test.com",
                "assets": [
                    {
                        "asset": "USDT",
                        "initialMargin": "0.00000000",
                        "maintenanceMargin": "0.00000000",
                        "marginBalance": "0.88308000",
                        "maxWithdrawAmount": "0.88308000",
                        "openOrderInitialMargin": "0.00000000",
                        "positionInitialMargin": "0.00000000",
                        "unrealizedProfit": "0.00000000",
                        "walletBalance": "0.88308000",
                    }
                ],
                "canDeposit": True,
                "canTrade": True,
                "canWithdraw": True,
                "feeTier": 2,
                "maxWithdrawAmount": "0.88308000",
                "totalInitialMargin": "0.00000000",
                "totalMaintenanceMargin": "0.00000000",
                "totalMarginBalance": "0.88308000",
                "totalOpenOrderInitialMargin": "0.00000000",
                "totalPositionInitialMargin": "0.00000000",
                "totalUnrealizedProfit": "0.00000000",
                "totalWalletBalance": "0.88308000",
                "updateTime": 1576756674610,
            },
            "deliveryAccountResp": {
                "email": "abc@test.com",
                "assets": [
                    {
                        "asset": "BTC",
                        "initialMargin": "0.00000000",
                        "maintenanceMargin": "0.00000000",
                        "marginBalance": "0.88308000",
                        "maxWithdrawAmount": "0.88308000",
                        "openOrderInitialMargin": "0.00000000",
                        "positionInitialMargin": "0.00000000",
                        "unrealizedProfit": "0.00000000",
                        "walletBalance": "0.88308000",
                    }
                ],
                "canDeposit": True,
                "canTrade": True,
                "canWithdraw": True,
                "feeTier": 2,
                "updateTime": 1598959682001,
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_detail_on_sub_accounts_futures_account_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/sub-account/futures/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"
        assert normalized["futuresType"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetDetailOnSubAccountsFuturesAccountV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetDetailOnSubAccountsFuturesAccountV2Response, "from_dict")
        ):
            expected = GetDetailOnSubAccountsFuturesAccountV2Response.from_dict(
                expected_response
            )
        else:
            expected = (
                GetDetailOnSubAccountsFuturesAccountV2Response.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_detail_on_sub_accounts_futures_account_v2_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_detail_on_sub_accounts_futures_account_v2() successfully with optional parameters."""

        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
            "recv_window": 5000,
        }

        expected_response = {
            "futureAccountResp": {
                "email": "abc@test.com",
                "assets": [
                    {
                        "asset": "USDT",
                        "initialMargin": "0.00000000",
                        "maintenanceMargin": "0.00000000",
                        "marginBalance": "0.88308000",
                        "maxWithdrawAmount": "0.88308000",
                        "openOrderInitialMargin": "0.00000000",
                        "positionInitialMargin": "0.00000000",
                        "unrealizedProfit": "0.00000000",
                        "walletBalance": "0.88308000",
                    }
                ],
                "canDeposit": True,
                "canTrade": True,
                "canWithdraw": True,
                "feeTier": 2,
                "maxWithdrawAmount": "0.88308000",
                "totalInitialMargin": "0.00000000",
                "totalMaintenanceMargin": "0.00000000",
                "totalMarginBalance": "0.88308000",
                "totalOpenOrderInitialMargin": "0.00000000",
                "totalPositionInitialMargin": "0.00000000",
                "totalUnrealizedProfit": "0.00000000",
                "totalWalletBalance": "0.88308000",
                "updateTime": 1576756674610,
            },
            "deliveryAccountResp": {
                "email": "abc@test.com",
                "assets": [
                    {
                        "asset": "BTC",
                        "initialMargin": "0.00000000",
                        "maintenanceMargin": "0.00000000",
                        "marginBalance": "0.88308000",
                        "maxWithdrawAmount": "0.88308000",
                        "openOrderInitialMargin": "0.00000000",
                        "positionInitialMargin": "0.00000000",
                        "unrealizedProfit": "0.00000000",
                        "walletBalance": "0.88308000",
                    }
                ],
                "canDeposit": True,
                "canTrade": True,
                "canWithdraw": True,
                "feeTier": 2,
                "updateTime": 1598959682001,
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_detail_on_sub_accounts_futures_account_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/sub-account/futures/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetDetailOnSubAccountsFuturesAccountV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetDetailOnSubAccountsFuturesAccountV2Response, "from_dict")
        ):
            expected = GetDetailOnSubAccountsFuturesAccountV2Response.from_dict(
                expected_response
            )
        else:
            expected = (
                GetDetailOnSubAccountsFuturesAccountV2Response.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_get_detail_on_sub_accounts_futures_account_v2_missing_required_param_email(
        self,
    ):
        """Test that get_detail_on_sub_accounts_futures_account_v2() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.get_detail_on_sub_accounts_futures_account_v2(**params)

    def test_get_detail_on_sub_accounts_futures_account_v2_missing_required_param_futures_type(
        self,
    ):
        """Test that get_detail_on_sub_accounts_futures_account_v2() raises RequiredError when 'futures_type' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }
        params["futures_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'futures_type'"
        ):
            self.client.get_detail_on_sub_accounts_futures_account_v2(**params)

    def test_get_detail_on_sub_accounts_futures_account_v2_server_error(self):
        """Test that get_detail_on_sub_accounts_futures_account_v2() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.get_detail_on_sub_accounts_futures_account_v2 = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_detail_on_sub_accounts_futures_account_v2(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_detail_on_sub_accounts_margin_account_success(
        self, mock_get_signature
    ):
        """Test get_detail_on_sub_accounts_margin_account() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
        }

        expected_response = {
            "email": "123@test.com",
            "marginLevel": "11.64405625",
            "totalAssetOfBtc": "6.82728457",
            "totalLiabilityOfBtc": "0.58633215",
            "totalNetAssetOfBtc": "6.24095242",
            "marginTradeCoeffVo": {
                "forceLiquidationBar": "1.10000000",
                "marginCallBar": "1.50000000",
                "normalBar": "2.00000000",
            },
            "marginUserAssetVoList": [
                {
                    "asset": "BTC",
                    "borrowed": "0.00000000",
                    "free": "0.00499500",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "0.00499500",
                },
                {
                    "asset": "BNB",
                    "borrowed": "201.66666672",
                    "free": "2346.50000000",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "2144.83333328",
                },
                {
                    "asset": "ETH",
                    "borrowed": "0.00000000",
                    "free": "0.00000000",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "0.00000000",
                },
                {
                    "asset": "USDT",
                    "borrowed": "0.00000000",
                    "free": "0.00000000",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "0.00000000",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_detail_on_sub_accounts_margin_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/margin/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetDetailOnSubAccountsMarginAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetDetailOnSubAccountsMarginAccountResponse, "from_dict")
        ):
            expected = GetDetailOnSubAccountsMarginAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetDetailOnSubAccountsMarginAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_detail_on_sub_accounts_margin_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_detail_on_sub_accounts_margin_account() successfully with optional parameters."""

        params = {"email": "sub-account-email@email.com", "recv_window": 5000}

        expected_response = {
            "email": "123@test.com",
            "marginLevel": "11.64405625",
            "totalAssetOfBtc": "6.82728457",
            "totalLiabilityOfBtc": "0.58633215",
            "totalNetAssetOfBtc": "6.24095242",
            "marginTradeCoeffVo": {
                "forceLiquidationBar": "1.10000000",
                "marginCallBar": "1.50000000",
                "normalBar": "2.00000000",
            },
            "marginUserAssetVoList": [
                {
                    "asset": "BTC",
                    "borrowed": "0.00000000",
                    "free": "0.00499500",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "0.00499500",
                },
                {
                    "asset": "BNB",
                    "borrowed": "201.66666672",
                    "free": "2346.50000000",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "2144.83333328",
                },
                {
                    "asset": "ETH",
                    "borrowed": "0.00000000",
                    "free": "0.00000000",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "0.00000000",
                },
                {
                    "asset": "USDT",
                    "borrowed": "0.00000000",
                    "free": "0.00000000",
                    "interest": "0.00000000",
                    "locked": "0.00000000",
                    "netAsset": "0.00000000",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_detail_on_sub_accounts_margin_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/margin/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetDetailOnSubAccountsMarginAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetDetailOnSubAccountsMarginAccountResponse, "from_dict")
        ):
            expected = GetDetailOnSubAccountsMarginAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetDetailOnSubAccountsMarginAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_detail_on_sub_accounts_margin_account_missing_required_param_email(
        self,
    ):
        """Test that get_detail_on_sub_accounts_margin_account() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.get_detail_on_sub_accounts_margin_account(**params)

    def test_get_detail_on_sub_accounts_margin_account_server_error(self):
        """Test that get_detail_on_sub_accounts_margin_account() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
        }

        mock_error = Exception("ResponseError")
        self.client.get_detail_on_sub_accounts_margin_account = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_detail_on_sub_accounts_margin_account(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_move_position_history_for_sub_account_success(
        self, mock_get_signature
    ):
        """Test get_move_position_history_for_sub_account() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "page": 56,
            "row": 56,
        }

        expected_response = {
            "total": 3,
            "futureMovePositionOrderVoList": [
                {
                    "fromUserEmail": "testFrom@google.com",
                    "toUserEmail": "testTo@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "price": "105025.50981609",
                    "quantity": "0.00100000",
                    "positionSide": "BOTH",
                    "side": "SELL",
                    "timeStamp": 1737544712000,
                },
                {
                    "fromUserEmail": "testFrom1@google.com",
                    "toUserEmail": "testTo1@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "price": "97100.00000000",
                    "quantity": "0.00100000",
                    "positionSide": "BOTH",
                    "side": "SELL",
                    "timeStamp": 1740041627000,
                },
                {
                    "fromUserEmail": "testFrom2@google.com",
                    "toUserEmail": "testTo2@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "price": "97108.62068889",
                    "quantity": "0.00100000",
                    "positionSide": "BOTH",
                    "side": "SELL",
                    "timeStamp": 1740041959000,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_move_position_history_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/move-position" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["page"] == 56
        assert normalized["row"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetMovePositionHistoryForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetMovePositionHistoryForSubAccountResponse, "from_dict")
        ):
            expected = GetMovePositionHistoryForSubAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetMovePositionHistoryForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_move_position_history_for_sub_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_move_position_history_for_sub_account() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "page": 56,
            "row": 56,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "recv_window": 5000,
        }

        expected_response = {
            "total": 3,
            "futureMovePositionOrderVoList": [
                {
                    "fromUserEmail": "testFrom@google.com",
                    "toUserEmail": "testTo@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "price": "105025.50981609",
                    "quantity": "0.00100000",
                    "positionSide": "BOTH",
                    "side": "SELL",
                    "timeStamp": 1737544712000,
                },
                {
                    "fromUserEmail": "testFrom1@google.com",
                    "toUserEmail": "testTo1@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "price": "97100.00000000",
                    "quantity": "0.00100000",
                    "positionSide": "BOTH",
                    "side": "SELL",
                    "timeStamp": 1740041627000,
                },
                {
                    "fromUserEmail": "testFrom2@google.com",
                    "toUserEmail": "testTo2@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "price": "97108.62068889",
                    "quantity": "0.00100000",
                    "positionSide": "BOTH",
                    "side": "SELL",
                    "timeStamp": 1740041959000,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_move_position_history_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/move-position" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetMovePositionHistoryForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetMovePositionHistoryForSubAccountResponse, "from_dict")
        ):
            expected = GetMovePositionHistoryForSubAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetMovePositionHistoryForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_move_position_history_for_sub_account_missing_required_param_symbol(
        self,
    ):
        """Test that get_move_position_history_for_sub_account() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "page": 56,
            "row": 56,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_move_position_history_for_sub_account(**params)

    def test_get_move_position_history_for_sub_account_missing_required_param_page(
        self,
    ):
        """Test that get_move_position_history_for_sub_account() raises RequiredError when 'page' is missing."""
        params = {
            "symbol": "symbol_example",
            "page": 56,
            "row": 56,
        }
        params["page"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'page'"):
            self.client.get_move_position_history_for_sub_account(**params)

    def test_get_move_position_history_for_sub_account_missing_required_param_row(self):
        """Test that get_move_position_history_for_sub_account() raises RequiredError when 'row' is missing."""
        params = {
            "symbol": "symbol_example",
            "page": 56,
            "row": 56,
        }
        params["row"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'row'"):
            self.client.get_move_position_history_for_sub_account(**params)

    def test_get_move_position_history_for_sub_account_server_error(self):
        """Test that get_move_position_history_for_sub_account() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "page": 56,
            "row": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.get_move_position_history_for_sub_account = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_move_position_history_for_sub_account(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_sub_account_deposit_address_success(self, mock_get_signature):
        """Test get_sub_account_deposit_address() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
            "coin": "coin_example",
        }

        expected_response = {
            "address": "TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV",
            "coin": "USDT",
            "tag": "",
            "url": "https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_sub_account_deposit_address(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/capital/deposit/subAddress" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"
        assert normalized["coin"] == "coin_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSubAccountDepositAddressResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSubAccountDepositAddressResponse, "from_dict")
        ):
            expected = GetSubAccountDepositAddressResponse.from_dict(expected_response)
        else:
            expected = GetSubAccountDepositAddressResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_sub_account_deposit_address_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_sub_account_deposit_address() successfully with optional parameters."""

        params = {
            "email": "sub-account-email@email.com",
            "coin": "coin_example",
            "network": "network_example",
            "amount": 1.0,
            "recv_window": 5000,
        }

        expected_response = {
            "address": "TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV",
            "coin": "USDT",
            "tag": "",
            "url": "https://tronscan.org/#/address/TDunhSa7jkTNuKrusUTU1MUHtqXoBPKETV",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_sub_account_deposit_address(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/capital/deposit/subAddress" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSubAccountDepositAddressResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSubAccountDepositAddressResponse, "from_dict")
        ):
            expected = GetSubAccountDepositAddressResponse.from_dict(expected_response)
        else:
            expected = GetSubAccountDepositAddressResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_sub_account_deposit_address_missing_required_param_email(self):
        """Test that get_sub_account_deposit_address() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "coin": "coin_example",
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.get_sub_account_deposit_address(**params)

    def test_get_sub_account_deposit_address_missing_required_param_coin(self):
        """Test that get_sub_account_deposit_address() raises RequiredError when 'coin' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "coin": "coin_example",
        }
        params["coin"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'coin'"):
            self.client.get_sub_account_deposit_address(**params)

    def test_get_sub_account_deposit_address_server_error(self):
        """Test that get_sub_account_deposit_address() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
            "coin": "coin_example",
        }

        mock_error = Exception("ResponseError")
        self.client.get_sub_account_deposit_address = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_sub_account_deposit_address(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_sub_account_deposit_history_success(self, mock_get_signature):
        """Test get_sub_account_deposit_history() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
        }

        expected_response = [
            {
                "id": "769800519366885376",
                "amount": "0.001",
                "coin": "BNB",
                "network": "BNB",
                "status": 0,
                "address": "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23",
                "addressTag": "101764890",
                "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
                "insertTime": 1661493146000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
            },
            {
                "id": "769754833590042625",
                "amount": "0.50000000",
                "coin": "IOTA",
                "network": "IOTA",
                "status": 1,
                "address": "SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW",
                "addressTag": "",
                "txId": "ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999",
                "insertTime": 1599620082000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_sub_account_deposit_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/capital/deposit/subHisrec" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSubAccountDepositHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSubAccountDepositHistoryResponse, "from_dict")
        ):
            expected = GetSubAccountDepositHistoryResponse.from_dict(expected_response)
        else:
            expected = GetSubAccountDepositHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_sub_account_deposit_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_sub_account_deposit_history() successfully with optional parameters."""

        params = {
            "email": "sub-account-email@email.com",
            "coin": "coin_example",
            "status": 56,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 1,
            "offset": 0,
            "recv_window": 5000,
            "tx_id": "1",
        }

        expected_response = [
            {
                "id": "769800519366885376",
                "amount": "0.001",
                "coin": "BNB",
                "network": "BNB",
                "status": 0,
                "address": "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23",
                "addressTag": "101764890",
                "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
                "insertTime": 1661493146000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
            },
            {
                "id": "769754833590042625",
                "amount": "0.50000000",
                "coin": "IOTA",
                "network": "IOTA",
                "status": 1,
                "address": "SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW",
                "addressTag": "",
                "txId": "ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999",
                "insertTime": 1599620082000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_sub_account_deposit_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/capital/deposit/subHisrec" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSubAccountDepositHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSubAccountDepositHistoryResponse, "from_dict")
        ):
            expected = GetSubAccountDepositHistoryResponse.from_dict(expected_response)
        else:
            expected = GetSubAccountDepositHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_sub_account_deposit_history_missing_required_param_email(self):
        """Test that get_sub_account_deposit_history() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.get_sub_account_deposit_history(**params)

    def test_get_sub_account_deposit_history_server_error(self):
        """Test that get_sub_account_deposit_history() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
        }

        mock_error = Exception("ResponseError")
        self.client.get_sub_account_deposit_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_sub_account_deposit_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_summary_of_sub_accounts_futures_account_success(
        self, mock_get_signature
    ):
        """Test get_summary_of_sub_accounts_futures_account() successfully with required parameters only."""

        expected_response = {
            "totalInitialMargin": "9.83137400",
            "totalMaintenanceMargin": "0.41568700",
            "totalMarginBalance": "23.03235621",
            "totalOpenOrderInitialMargin": "9.00000000",
            "totalPositionInitialMargin": "0.83137400",
            "totalUnrealizedProfit": "0.03219710",
            "totalWalletBalance": "22.15879444",
            "asset": "USD",
            "subAccountList": [
                {
                    "email": "123@test.com",
                    "totalInitialMargin": "9.00000000",
                    "totalMaintenanceMargin": "0.00000000",
                    "totalMarginBalance": "22.12659734",
                    "totalOpenOrderInitialMargin": "9.00000000",
                    "totalPositionInitialMargin": "0.00000000",
                    "totalUnrealizedProfit": "0.00000000",
                    "totalWalletBalance": "22.12659734",
                    "asset": "USD",
                },
                {
                    "email": "345@test.com",
                    "totalInitialMargin": "0.83137400",
                    "totalMaintenanceMargin": "0.41568700",
                    "totalMarginBalance": "0.90575887",
                    "totalOpenOrderInitialMargin": "0.00000000",
                    "totalPositionInitialMargin": "0.83137400",
                    "totalUnrealizedProfit": "0.03219710",
                    "totalWalletBalance": "0.87356177",
                    "asset": "USD",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_summary_of_sub_accounts_futures_account()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/accountSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSummaryOfSubAccountsFuturesAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSummaryOfSubAccountsFuturesAccountResponse, "from_dict")
        ):
            expected = GetSummaryOfSubAccountsFuturesAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                GetSummaryOfSubAccountsFuturesAccountResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_summary_of_sub_accounts_futures_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_summary_of_sub_accounts_futures_account() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = {
            "totalInitialMargin": "9.83137400",
            "totalMaintenanceMargin": "0.41568700",
            "totalMarginBalance": "23.03235621",
            "totalOpenOrderInitialMargin": "9.00000000",
            "totalPositionInitialMargin": "0.83137400",
            "totalUnrealizedProfit": "0.03219710",
            "totalWalletBalance": "22.15879444",
            "asset": "USD",
            "subAccountList": [
                {
                    "email": "123@test.com",
                    "totalInitialMargin": "9.00000000",
                    "totalMaintenanceMargin": "0.00000000",
                    "totalMarginBalance": "22.12659734",
                    "totalOpenOrderInitialMargin": "9.00000000",
                    "totalPositionInitialMargin": "0.00000000",
                    "totalUnrealizedProfit": "0.00000000",
                    "totalWalletBalance": "22.12659734",
                    "asset": "USD",
                },
                {
                    "email": "345@test.com",
                    "totalInitialMargin": "0.83137400",
                    "totalMaintenanceMargin": "0.41568700",
                    "totalMarginBalance": "0.90575887",
                    "totalOpenOrderInitialMargin": "0.00000000",
                    "totalPositionInitialMargin": "0.83137400",
                    "totalUnrealizedProfit": "0.03219710",
                    "totalWalletBalance": "0.87356177",
                    "asset": "USD",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_summary_of_sub_accounts_futures_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/accountSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSummaryOfSubAccountsFuturesAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSummaryOfSubAccountsFuturesAccountResponse, "from_dict")
        ):
            expected = GetSummaryOfSubAccountsFuturesAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                GetSummaryOfSubAccountsFuturesAccountResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_get_summary_of_sub_accounts_futures_account_server_error(self):
        """Test that get_summary_of_sub_accounts_futures_account() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_summary_of_sub_accounts_futures_account = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_summary_of_sub_accounts_futures_account()

    @patch("binance_common.utils.get_signature")
    def test_get_summary_of_sub_accounts_futures_account_v2_success(
        self, mock_get_signature
    ):
        """Test get_summary_of_sub_accounts_futures_account_v2() successfully with required parameters only."""

        params = {
            "futures_type": 56,
        }

        expected_response = {
            "futureAccountSummaryResp": {
                "totalInitialMargin": "9.83137400",
                "totalMaintenanceMargin": "0.41568700",
                "totalMarginBalance": "23.03235621",
                "totalOpenOrderInitialMargin": "9.00000000",
                "totalPositionInitialMargin": "0.83137400",
                "totalUnrealizedProfit": "0.03219710",
                "totalWalletBalance": "22.15879444",
                "asset": "USD",
                "subAccountList": [
                    {
                        "email": "123@test.com",
                        "totalInitialMargin": "9.00000000",
                        "totalMaintenanceMargin": "0.00000000",
                        "totalMarginBalance": "22.12659734",
                        "totalOpenOrderInitialMargin": "9.00000000",
                        "totalPositionInitialMargin": "0.00000000",
                        "totalUnrealizedProfit": "0.00000000",
                        "totalWalletBalance": "22.12659734",
                        "asset": "USD",
                    },
                    {
                        "email": "345@test.com",
                        "totalInitialMargin": "0.83137400",
                        "totalMaintenanceMargin": "0.41568700",
                        "totalMarginBalance": "0.90575887",
                        "totalOpenOrderInitialMargin": "0.00000000",
                        "totalPositionInitialMargin": "0.83137400",
                        "totalUnrealizedProfit": "0.03219710",
                        "totalWalletBalance": "0.87356177",
                        "asset": "USD",
                    },
                ],
            },
            "deliveryAccountSummaryResp": {
                "totalMarginBalanceOfBTC": "25.03221121",
                "totalUnrealizedProfitOfBTC": "0.12233410",
                "totalWalletBalanceOfBTC": "22.15879444",
                "asset": "BTC",
                "subAccountList": [
                    {
                        "email": "123@test.com",
                        "totalMarginBalance": "22.12659734",
                        "totalUnrealizedProfit": "0.00000000",
                        "totalWalletBalance": "22.12659734",
                        "asset": "BTC",
                    },
                    {
                        "email": "345@test.com",
                        "totalMarginBalance": "0.90575887",
                        "totalUnrealizedProfit": "0.03219710",
                        "totalWalletBalance": "0.87356177",
                        "asset": "BTC",
                    },
                ],
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_summary_of_sub_accounts_futures_account_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/sub-account/futures/accountSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["futuresType"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSummaryOfSubAccountsFuturesAccountV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSummaryOfSubAccountsFuturesAccountV2Response, "from_dict")
        ):
            expected = GetSummaryOfSubAccountsFuturesAccountV2Response.from_dict(
                expected_response
            )
        else:
            expected = (
                GetSummaryOfSubAccountsFuturesAccountV2Response.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_summary_of_sub_accounts_futures_account_v2_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_summary_of_sub_accounts_futures_account_v2() successfully with optional parameters."""

        params = {"futures_type": 56, "page": 1, "limit": 1, "recv_window": 5000}

        expected_response = {
            "futureAccountSummaryResp": {
                "totalInitialMargin": "9.83137400",
                "totalMaintenanceMargin": "0.41568700",
                "totalMarginBalance": "23.03235621",
                "totalOpenOrderInitialMargin": "9.00000000",
                "totalPositionInitialMargin": "0.83137400",
                "totalUnrealizedProfit": "0.03219710",
                "totalWalletBalance": "22.15879444",
                "asset": "USD",
                "subAccountList": [
                    {
                        "email": "123@test.com",
                        "totalInitialMargin": "9.00000000",
                        "totalMaintenanceMargin": "0.00000000",
                        "totalMarginBalance": "22.12659734",
                        "totalOpenOrderInitialMargin": "9.00000000",
                        "totalPositionInitialMargin": "0.00000000",
                        "totalUnrealizedProfit": "0.00000000",
                        "totalWalletBalance": "22.12659734",
                        "asset": "USD",
                    },
                    {
                        "email": "345@test.com",
                        "totalInitialMargin": "0.83137400",
                        "totalMaintenanceMargin": "0.41568700",
                        "totalMarginBalance": "0.90575887",
                        "totalOpenOrderInitialMargin": "0.00000000",
                        "totalPositionInitialMargin": "0.83137400",
                        "totalUnrealizedProfit": "0.03219710",
                        "totalWalletBalance": "0.87356177",
                        "asset": "USD",
                    },
                ],
            },
            "deliveryAccountSummaryResp": {
                "totalMarginBalanceOfBTC": "25.03221121",
                "totalUnrealizedProfitOfBTC": "0.12233410",
                "totalWalletBalanceOfBTC": "22.15879444",
                "asset": "BTC",
                "subAccountList": [
                    {
                        "email": "123@test.com",
                        "totalMarginBalance": "22.12659734",
                        "totalUnrealizedProfit": "0.00000000",
                        "totalWalletBalance": "22.12659734",
                        "asset": "BTC",
                    },
                    {
                        "email": "345@test.com",
                        "totalMarginBalance": "0.90575887",
                        "totalUnrealizedProfit": "0.03219710",
                        "totalWalletBalance": "0.87356177",
                        "asset": "BTC",
                    },
                ],
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_summary_of_sub_accounts_futures_account_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/sub-account/futures/accountSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSummaryOfSubAccountsFuturesAccountV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSummaryOfSubAccountsFuturesAccountV2Response, "from_dict")
        ):
            expected = GetSummaryOfSubAccountsFuturesAccountV2Response.from_dict(
                expected_response
            )
        else:
            expected = (
                GetSummaryOfSubAccountsFuturesAccountV2Response.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_get_summary_of_sub_accounts_futures_account_v2_missing_required_param_futures_type(
        self,
    ):
        """Test that get_summary_of_sub_accounts_futures_account_v2() raises RequiredError when 'futures_type' is missing."""
        params = {
            "futures_type": 56,
        }
        params["futures_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'futures_type'"
        ):
            self.client.get_summary_of_sub_accounts_futures_account_v2(**params)

    def test_get_summary_of_sub_accounts_futures_account_v2_server_error(self):
        """Test that get_summary_of_sub_accounts_futures_account_v2() raises an error when the server returns an error."""

        params = {
            "futures_type": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.get_summary_of_sub_accounts_futures_account_v2 = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_summary_of_sub_accounts_futures_account_v2(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_summary_of_sub_accounts_margin_account_success(
        self, mock_get_signature
    ):
        """Test get_summary_of_sub_accounts_margin_account() successfully with required parameters only."""

        expected_response = {
            "totalAssetOfBtc": "4.33333333",
            "totalLiabilityOfBtc": "2.11111112",
            "totalNetAssetOfBtc": "2.22222221",
            "subAccountList": [
                {
                    "email": "123@test.com",
                    "totalAssetOfBtc": "2.11111111",
                    "totalLiabilityOfBtc": "1.11111111",
                    "totalNetAssetOfBtc": "1.00000000",
                },
                {
                    "email": "345@test.com",
                    "totalAssetOfBtc": "2.22222222",
                    "totalLiabilityOfBtc": "1.00000001",
                    "totalNetAssetOfBtc": "1.22222221",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_summary_of_sub_accounts_margin_account()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/margin/accountSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSummaryOfSubAccountsMarginAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSummaryOfSubAccountsMarginAccountResponse, "from_dict")
        ):
            expected = GetSummaryOfSubAccountsMarginAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetSummaryOfSubAccountsMarginAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_summary_of_sub_accounts_margin_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_summary_of_sub_accounts_margin_account() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = {
            "totalAssetOfBtc": "4.33333333",
            "totalLiabilityOfBtc": "2.11111112",
            "totalNetAssetOfBtc": "2.22222221",
            "subAccountList": [
                {
                    "email": "123@test.com",
                    "totalAssetOfBtc": "2.11111111",
                    "totalLiabilityOfBtc": "1.11111111",
                    "totalNetAssetOfBtc": "1.00000000",
                },
                {
                    "email": "345@test.com",
                    "totalAssetOfBtc": "2.22222222",
                    "totalLiabilityOfBtc": "1.00000001",
                    "totalNetAssetOfBtc": "1.22222221",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_summary_of_sub_accounts_margin_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/margin/accountSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetSummaryOfSubAccountsMarginAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetSummaryOfSubAccountsMarginAccountResponse, "from_dict")
        ):
            expected = GetSummaryOfSubAccountsMarginAccountResponse.from_dict(
                expected_response
            )
        else:
            expected = GetSummaryOfSubAccountsMarginAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_summary_of_sub_accounts_margin_account_server_error(self):
        """Test that get_summary_of_sub_accounts_margin_account() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_summary_of_sub_accounts_margin_account = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_summary_of_sub_accounts_margin_account()

    @patch("binance_common.utils.get_signature")
    def test_margin_transfer_for_sub_account_success(self, mock_get_signature):
        """Test margin_transfer_for_sub_account() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_transfer_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/margin/transfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["email"] == "sub-account-email@email.com"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0
        assert normalized["type"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginTransferForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MarginTransferForSubAccountResponse, "from_dict")
        ):
            expected = MarginTransferForSubAccountResponse.from_dict(expected_response)
        else:
            expected = MarginTransferForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_margin_transfer_for_sub_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test margin_transfer_for_sub_account() successfully with optional parameters."""

        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
            "recv_window": 5000,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.margin_transfer_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/margin/transfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarginTransferForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MarginTransferForSubAccountResponse, "from_dict")
        ):
            expected = MarginTransferForSubAccountResponse.from_dict(expected_response)
        else:
            expected = MarginTransferForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_margin_transfer_for_sub_account_missing_required_param_email(self):
        """Test that margin_transfer_for_sub_account() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.margin_transfer_for_sub_account(**params)

    def test_margin_transfer_for_sub_account_missing_required_param_asset(self):
        """Test that margin_transfer_for_sub_account() raises RequiredError when 'asset' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.margin_transfer_for_sub_account(**params)

    def test_margin_transfer_for_sub_account_missing_required_param_amount(self):
        """Test that margin_transfer_for_sub_account() raises RequiredError when 'amount' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.margin_transfer_for_sub_account(**params)

    def test_margin_transfer_for_sub_account_missing_required_param_type(self):
        """Test that margin_transfer_for_sub_account() raises RequiredError when 'type' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.margin_transfer_for_sub_account(**params)

    def test_margin_transfer_for_sub_account_server_error(self):
        """Test that margin_transfer_for_sub_account() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
            "asset": "asset_example",
            "amount": 1.0,
            "type": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.margin_transfer_for_sub_account = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.margin_transfer_for_sub_account(**params)

    @patch("binance_common.utils.get_signature")
    def test_move_position_for_sub_account_success(self, mock_get_signature):
        """Test move_position_for_sub_account() successfully with required parameters only."""

        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
        }

        expected_response = {
            "movePositionOrders": [
                {
                    "fromUserEmail": "testFrom@google.com",
                    "toUserEmail": "testTo@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "priceType": "MARK_PRICE",
                    "price": "97139.00000000",
                    "quantity": "0.001",
                    "positionSide": "BOTH",
                    "side": "BUY",
                    "success": True,
                },
                {
                    "fromUserEmail": "testFrom1@google.com",
                    "toUserEmail": "1testTo@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "priceType": "MARK_PRICE",
                    "price": "97139.00000000",
                    "quantity": "0.0011",
                    "positionSide": "BOTH",
                    "side": "BUY",
                    "success": True,
                },
            ]
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.move_position_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/move-position" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["fromUserEmail"] == "from_user_email_example"
        assert normalized["toUserEmail"] == "to_user_email_example"
        assert normalized["productType"] == "product_type_example"
        assert "orderArgs" in normalized

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MovePositionForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MovePositionForSubAccountResponse, "from_dict")
        ):
            expected = MovePositionForSubAccountResponse.from_dict(expected_response)
        else:
            expected = MovePositionForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_move_position_for_sub_account_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test move_position_for_sub_account() successfully with optional parameters."""

        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
            "recv_window": 5000,
        }

        expected_response = {
            "movePositionOrders": [
                {
                    "fromUserEmail": "testFrom@google.com",
                    "toUserEmail": "testTo@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "priceType": "MARK_PRICE",
                    "price": "97139.00000000",
                    "quantity": "0.001",
                    "positionSide": "BOTH",
                    "side": "BUY",
                    "success": True,
                },
                {
                    "fromUserEmail": "testFrom1@google.com",
                    "toUserEmail": "1testTo@google.com",
                    "productType": "UM",
                    "symbol": "BTCUSDT",
                    "priceType": "MARK_PRICE",
                    "price": "97139.00000000",
                    "quantity": "0.0011",
                    "positionSide": "BOTH",
                    "side": "BUY",
                    "success": True,
                },
            ]
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.move_position_for_sub_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/move-position" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MovePositionForSubAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MovePositionForSubAccountResponse, "from_dict")
        ):
            expected = MovePositionForSubAccountResponse.from_dict(expected_response)
        else:
            expected = MovePositionForSubAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_move_position_for_sub_account_missing_required_param_from_user_email(self):
        """Test that move_position_for_sub_account() raises RequiredError when 'from_user_email' is missing."""
        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
        }
        params["from_user_email"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'from_user_email'"
        ):
            self.client.move_position_for_sub_account(**params)

    def test_move_position_for_sub_account_missing_required_param_to_user_email(self):
        """Test that move_position_for_sub_account() raises RequiredError when 'to_user_email' is missing."""
        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
        }
        params["to_user_email"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'to_user_email'"
        ):
            self.client.move_position_for_sub_account(**params)

    def test_move_position_for_sub_account_missing_required_param_product_type(self):
        """Test that move_position_for_sub_account() raises RequiredError when 'product_type' is missing."""
        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
        }
        params["product_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'product_type'"
        ):
            self.client.move_position_for_sub_account(**params)

    def test_move_position_for_sub_account_missing_required_param_order_args(self):
        """Test that move_position_for_sub_account() raises RequiredError when 'order_args' is missing."""
        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
        }
        params["order_args"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'order_args'"
        ):
            self.client.move_position_for_sub_account(**params)

    def test_move_position_for_sub_account_server_error(self):
        """Test that move_position_for_sub_account() raises an error when the server returns an error."""

        params = {
            "from_user_email": "from_user_email_example",
            "to_user_email": "to_user_email_example",
            "product_type": "product_type_example",
            "order_args": [
                MovePositionForSubAccountOrderArgsParameterInner(
                    symbol="BTCUSDT",
                    quantity=0.001,
                    position_side="BOTH",
                )
            ],
        }

        mock_error = Exception("ResponseError")
        self.client.move_position_for_sub_account = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.move_position_for_sub_account(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_assets_success(self, mock_get_signature):
        """Test query_sub_account_assets() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
        }

        expected_response = {
            "balances": [
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "ADA",
                    "free": 10000,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "BNB",
                    "free": 10003,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "BTC",
                    "free": 11467.6399,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "ETH",
                    "free": 10004.995,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "USDT",
                    "free": 11652.14213,
                    "locked": 0,
                },
            ]
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_assets(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v3/sub-account/assets" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountAssetsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QuerySubAccountAssetsResponse, "from_dict"):
            expected = QuerySubAccountAssetsResponse.from_dict(expected_response)
        else:
            expected = QuerySubAccountAssetsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_assets_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_sub_account_assets() successfully with optional parameters."""

        params = {"email": "sub-account-email@email.com", "recv_window": 5000}

        expected_response = {
            "balances": [
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "ADA",
                    "free": 10000,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "BNB",
                    "free": 10003,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "BTC",
                    "free": 11467.6399,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "ETH",
                    "free": 10004.995,
                    "locked": 0,
                },
                {
                    "freeze": 0,
                    "withdrawing": 0,
                    "asset": "USDT",
                    "free": 11652.14213,
                    "locked": 0,
                },
            ]
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_assets(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v3/sub-account/assets" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountAssetsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QuerySubAccountAssetsResponse, "from_dict"):
            expected = QuerySubAccountAssetsResponse.from_dict(expected_response)
        else:
            expected = QuerySubAccountAssetsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_sub_account_assets_missing_required_param_email(self):
        """Test that query_sub_account_assets() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.query_sub_account_assets(**params)

    def test_query_sub_account_assets_server_error(self):
        """Test that query_sub_account_assets() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
        }

        mock_error = Exception("ResponseError")
        self.client.query_sub_account_assets = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_sub_account_assets(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_assets_asset_management_success(
        self, mock_get_signature
    ):
        """Test query_sub_account_assets_asset_management() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
        }

        expected_response = {
            "balances": [
                {
                    "freeze": "0",
                    "withdrawing": "0",
                    "asset": "ADA",
                    "free": "10000",
                    "locked": "0",
                },
                {
                    "freeze": "0",
                    "withdrawing": "0",
                    "asset": "BNB",
                    "free": "10003",
                    "locked": "0",
                },
                {
                    "freeze": "0",
                    "withdrawing": "0",
                    "asset": "BTC",
                    "free": "11467.6399",
                    "locked": "0",
                },
            ]
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_assets_asset_management(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v4/sub-account/assets" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountAssetsAssetManagementResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountAssetsAssetManagementResponse, "from_dict")
        ):
            expected = QuerySubAccountAssetsAssetManagementResponse.from_dict(
                expected_response
            )
        else:
            expected = QuerySubAccountAssetsAssetManagementResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_assets_asset_management_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_sub_account_assets_asset_management() successfully with optional parameters."""

        params = {"email": "sub-account-email@email.com", "recv_window": 5000}

        expected_response = {
            "balances": [
                {
                    "freeze": "0",
                    "withdrawing": "0",
                    "asset": "ADA",
                    "free": "10000",
                    "locked": "0",
                },
                {
                    "freeze": "0",
                    "withdrawing": "0",
                    "asset": "BNB",
                    "free": "10003",
                    "locked": "0",
                },
                {
                    "freeze": "0",
                    "withdrawing": "0",
                    "asset": "BTC",
                    "free": "11467.6399",
                    "locked": "0",
                },
            ]
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_assets_asset_management(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v4/sub-account/assets" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountAssetsAssetManagementResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountAssetsAssetManagementResponse, "from_dict")
        ):
            expected = QuerySubAccountAssetsAssetManagementResponse.from_dict(
                expected_response
            )
        else:
            expected = QuerySubAccountAssetsAssetManagementResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_sub_account_assets_asset_management_missing_required_param_email(
        self,
    ):
        """Test that query_sub_account_assets_asset_management() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.query_sub_account_assets_asset_management(**params)

    def test_query_sub_account_assets_asset_management_server_error(self):
        """Test that query_sub_account_assets_asset_management() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
        }

        mock_error = Exception("ResponseError")
        self.client.query_sub_account_assets_asset_management = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_sub_account_assets_asset_management(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_futures_asset_transfer_history_success(
        self, mock_get_signature
    ):
        """Test query_sub_account_futures_asset_transfer_history() successfully with required parameters only."""

        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }

        expected_response = {
            "success": True,
            "futuresType": 2,
            "transfers": [
                {
                    "from": "aaa@test.com",
                    "to": "bbb@test.com",
                    "asset": "BTC",
                    "qty": "1",
                    "tranId": 11897001102,
                    "time": 1544433328000,
                },
                {
                    "from": "bbb@test.com",
                    "to": "ccc@test.com",
                    "asset": "ETH",
                    "qty": "2",
                    "tranId": 11631474902,
                    "time": 1544433328000,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_futures_asset_transfer_history(
            **params
        )

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/internalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["email"] == "sub-account-email@email.com"
        assert normalized["futuresType"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountFuturesAssetTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountFuturesAssetTransferHistoryResponse, "from_dict")
        ):
            expected = QuerySubAccountFuturesAssetTransferHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QuerySubAccountFuturesAssetTransferHistoryResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_futures_asset_transfer_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_sub_account_futures_asset_transfer_history() successfully with optional parameters."""

        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "page": 1,
            "limit": 1,
            "recv_window": 5000,
        }

        expected_response = {
            "success": True,
            "futuresType": 2,
            "transfers": [
                {
                    "from": "aaa@test.com",
                    "to": "bbb@test.com",
                    "asset": "BTC",
                    "qty": "1",
                    "tranId": 11897001102,
                    "time": 1544433328000,
                },
                {
                    "from": "bbb@test.com",
                    "to": "ccc@test.com",
                    "asset": "ETH",
                    "qty": "2",
                    "tranId": 11631474902,
                    "time": 1544433328000,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_futures_asset_transfer_history(
            **params
        )

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/internalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountFuturesAssetTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountFuturesAssetTransferHistoryResponse, "from_dict")
        ):
            expected = QuerySubAccountFuturesAssetTransferHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QuerySubAccountFuturesAssetTransferHistoryResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_query_sub_account_futures_asset_transfer_history_missing_required_param_email(
        self,
    ):
        """Test that query_sub_account_futures_asset_transfer_history() raises RequiredError when 'email' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }
        params["email"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'email'"):
            self.client.query_sub_account_futures_asset_transfer_history(**params)

    def test_query_sub_account_futures_asset_transfer_history_missing_required_param_futures_type(
        self,
    ):
        """Test that query_sub_account_futures_asset_transfer_history() raises RequiredError when 'futures_type' is missing."""
        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }
        params["futures_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'futures_type'"
        ):
            self.client.query_sub_account_futures_asset_transfer_history(**params)

    def test_query_sub_account_futures_asset_transfer_history_server_error(self):
        """Test that query_sub_account_futures_asset_transfer_history() raises an error when the server returns an error."""

        params = {
            "email": "sub-account-email@email.com",
            "futures_type": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.query_sub_account_futures_asset_transfer_history = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_sub_account_futures_asset_transfer_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_spot_asset_transfer_history_success(
        self, mock_get_signature
    ):
        """Test query_sub_account_spot_asset_transfer_history() successfully with required parameters only."""

        expected_response = [
            {
                "from": "aaa@test.com",
                "to": "bbb@test.com",
                "asset": "BTC",
                "qty": "10",
                "status": "SUCCESS",
                "tranId": 6489943656,
                "time": 1544433328000,
            },
            {
                "from": "bbb@test.com",
                "to": "ccc@test.com",
                "asset": "ETH",
                "qty": "2",
                "status": "SUCCESS",
                "tranId": 6489938713,
                "time": 1544433328000,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_spot_asset_transfer_history()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/sub/transfer/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountSpotAssetTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountSpotAssetTransferHistoryResponse, "from_dict")
        ):
            expected = QuerySubAccountSpotAssetTransferHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QuerySubAccountSpotAssetTransferHistoryResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_spot_asset_transfer_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_sub_account_spot_asset_transfer_history() successfully with optional parameters."""

        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "page": 1,
            "limit": 1,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "from": "aaa@test.com",
                "to": "bbb@test.com",
                "asset": "BTC",
                "qty": "10",
                "status": "SUCCESS",
                "tranId": 6489943656,
                "time": 1544433328000,
            },
            {
                "from": "bbb@test.com",
                "to": "ccc@test.com",
                "asset": "ETH",
                "qty": "2",
                "status": "SUCCESS",
                "tranId": 6489938713,
                "time": 1544433328000,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_spot_asset_transfer_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/sub/transfer/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountSpotAssetTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountSpotAssetTransferHistoryResponse, "from_dict")
        ):
            expected = QuerySubAccountSpotAssetTransferHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                QuerySubAccountSpotAssetTransferHistoryResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_query_sub_account_spot_asset_transfer_history_server_error(self):
        """Test that query_sub_account_spot_asset_transfer_history() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_sub_account_spot_asset_transfer_history = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_sub_account_spot_asset_transfer_history()

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_spot_assets_summary_success(self, mock_get_signature):
        """Test query_sub_account_spot_assets_summary() successfully with required parameters only."""

        expected_response = {
            "totalCount": 2,
            "masterAccountTotalAsset": "0.23231201",
            "spotSubUserAssetBtcVoList": [
                {"email": "sub123@test.com", "totalAsset": "9999.00000000"},
                {"email": "test456@test.com", "totalAsset": "0.00000000"},
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_spot_assets_summary()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/spotSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountSpotAssetsSummaryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountSpotAssetsSummaryResponse, "from_dict")
        ):
            expected = QuerySubAccountSpotAssetsSummaryResponse.from_dict(
                expected_response
            )
        else:
            expected = QuerySubAccountSpotAssetsSummaryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_sub_account_spot_assets_summary_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_sub_account_spot_assets_summary() successfully with optional parameters."""

        params = {"email": "email_example", "page": 1, "size": 10, "recv_window": 5000}

        expected_response = {
            "totalCount": 2,
            "masterAccountTotalAsset": "0.23231201",
            "spotSubUserAssetBtcVoList": [
                {"email": "sub123@test.com", "totalAsset": "9999.00000000"},
                {"email": "test456@test.com", "totalAsset": "0.00000000"},
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_sub_account_spot_assets_summary(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/spotSummary" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuerySubAccountSpotAssetsSummaryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuerySubAccountSpotAssetsSummaryResponse, "from_dict")
        ):
            expected = QuerySubAccountSpotAssetsSummaryResponse.from_dict(
                expected_response
            )
        else:
            expected = QuerySubAccountSpotAssetsSummaryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_sub_account_spot_assets_summary_server_error(self):
        """Test that query_sub_account_spot_assets_summary() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_sub_account_spot_assets_summary = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_sub_account_spot_assets_summary()

    @patch("binance_common.utils.get_signature")
    def test_query_universal_transfer_history_success(self, mock_get_signature):
        """Test query_universal_transfer_history() successfully with required parameters only."""

        expected_response = {
            "result": [
                {
                    "tranId": 92275823339,
                    "fromEmail": "abctest@gmail.com",
                    "toEmail": "deftest@gmail.com",
                    "asset": "BNB",
                    "amount": "0.01",
                    "createTimeStamp": 1640317374000,
                    "fromAccountType": "USDT_FUTURE",
                    "toAccountType": "SPOT",
                    "status": "SUCCESS",
                    "clientTranId": "test",
                }
            ],
            "totalCount": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_universal_transfer_history()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/universalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUniversalTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUniversalTransferHistoryResponse, "from_dict")
        ):
            expected = QueryUniversalTransferHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryUniversalTransferHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_universal_transfer_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_universal_transfer_history() successfully with optional parameters."""

        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "client_tran_id": "1",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "page": 1,
            "limit": 1,
            "recv_window": 5000,
        }

        expected_response = {
            "result": [
                {
                    "tranId": 92275823339,
                    "fromEmail": "abctest@gmail.com",
                    "toEmail": "deftest@gmail.com",
                    "asset": "BNB",
                    "amount": "0.01",
                    "createTimeStamp": 1640317374000,
                    "fromAccountType": "USDT_FUTURE",
                    "toAccountType": "SPOT",
                    "status": "SUCCESS",
                    "clientTranId": "test",
                }
            ],
            "totalCount": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_universal_transfer_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/universalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryUniversalTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryUniversalTransferHistoryResponse, "from_dict")
        ):
            expected = QueryUniversalTransferHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryUniversalTransferHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_universal_transfer_history_server_error(self):
        """Test that query_universal_transfer_history() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_universal_transfer_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_universal_transfer_history()

    @patch("binance_common.utils.get_signature")
    def test_sub_account_futures_asset_transfer_success(self, mock_get_signature):
        """Test sub_account_futures_asset_transfer() successfully with required parameters only."""

        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }

        expected_response = {"success": True, "txnId": "2934662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sub_account_futures_asset_transfer(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/internalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["fromEmail"] == "from_email_example"
        assert normalized["toEmail"] == "to_email_example"
        assert normalized["futuresType"] == 56
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubAccountFuturesAssetTransferResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(SubAccountFuturesAssetTransferResponse, "from_dict")
        ):
            expected = SubAccountFuturesAssetTransferResponse.from_dict(
                expected_response
            )
        else:
            expected = SubAccountFuturesAssetTransferResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_sub_account_futures_asset_transfer_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test sub_account_futures_asset_transfer() successfully with optional parameters."""

        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
            "recv_window": 5000,
        }

        expected_response = {"success": True, "txnId": "2934662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sub_account_futures_asset_transfer(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/futures/internalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubAccountFuturesAssetTransferResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(SubAccountFuturesAssetTransferResponse, "from_dict")
        ):
            expected = SubAccountFuturesAssetTransferResponse.from_dict(
                expected_response
            )
        else:
            expected = SubAccountFuturesAssetTransferResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_sub_account_futures_asset_transfer_missing_required_param_from_email(self):
        """Test that sub_account_futures_asset_transfer() raises RequiredError when 'from_email' is missing."""
        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["from_email"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'from_email'"
        ):
            self.client.sub_account_futures_asset_transfer(**params)

    def test_sub_account_futures_asset_transfer_missing_required_param_to_email(self):
        """Test that sub_account_futures_asset_transfer() raises RequiredError when 'to_email' is missing."""
        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["to_email"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'to_email'"
        ):
            self.client.sub_account_futures_asset_transfer(**params)

    def test_sub_account_futures_asset_transfer_missing_required_param_futures_type(
        self,
    ):
        """Test that sub_account_futures_asset_transfer() raises RequiredError when 'futures_type' is missing."""
        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["futures_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'futures_type'"
        ):
            self.client.sub_account_futures_asset_transfer(**params)

    def test_sub_account_futures_asset_transfer_missing_required_param_asset(self):
        """Test that sub_account_futures_asset_transfer() raises RequiredError when 'asset' is missing."""
        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.sub_account_futures_asset_transfer(**params)

    def test_sub_account_futures_asset_transfer_missing_required_param_amount(self):
        """Test that sub_account_futures_asset_transfer() raises RequiredError when 'amount' is missing."""
        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.sub_account_futures_asset_transfer(**params)

    def test_sub_account_futures_asset_transfer_server_error(self):
        """Test that sub_account_futures_asset_transfer() raises an error when the server returns an error."""

        params = {
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "futures_type": 56,
            "asset": "asset_example",
            "amount": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.sub_account_futures_asset_transfer = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.sub_account_futures_asset_transfer(**params)

    @patch("binance_common.utils.get_signature")
    def test_sub_account_transfer_history_success(self, mock_get_signature):
        """Test sub_account_transfer_history() successfully with required parameters only."""

        expected_response = [
            {
                "counterParty": "master",
                "email": "master@test.com",
                "type": 1,
                "asset": "BTC",
                "qty": "1",
                "fromAccountType": "SPOT",
                "toAccountType": "SPOT",
                "status": "SUCCESS",
                "tranId": 11798835829,
                "time": 1544433325000,
            },
            {
                "counterParty": "subAccount",
                "email": "sub2@test.com",
                "type": 1,
                "asset": "ETH",
                "qty": "2",
                "fromAccountType": "SPOT",
                "toAccountType": "COIN_FUTURE",
                "status": "SUCCESS",
                "tranId": 11798829519,
                "time": 1544433326000,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sub_account_transfer_history()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/transfer/subUserHistory" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubAccountTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(SubAccountTransferHistoryResponse, "from_dict")
        ):
            expected = SubAccountTransferHistoryResponse.from_dict(expected_response)
        else:
            expected = SubAccountTransferHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_sub_account_transfer_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test sub_account_transfer_history() successfully with optional parameters."""

        params = {
            "asset": "asset_example",
            "type": 56,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 1,
            "return_fail_history": False,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "counterParty": "master",
                "email": "master@test.com",
                "type": 1,
                "asset": "BTC",
                "qty": "1",
                "fromAccountType": "SPOT",
                "toAccountType": "SPOT",
                "status": "SUCCESS",
                "tranId": 11798835829,
                "time": 1544433325000,
            },
            {
                "counterParty": "subAccount",
                "email": "sub2@test.com",
                "type": 1,
                "asset": "ETH",
                "qty": "2",
                "fromAccountType": "SPOT",
                "toAccountType": "COIN_FUTURE",
                "status": "SUCCESS",
                "tranId": 11798829519,
                "time": 1544433326000,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.sub_account_transfer_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/transfer/subUserHistory" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubAccountTransferHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(SubAccountTransferHistoryResponse, "from_dict")
        ):
            expected = SubAccountTransferHistoryResponse.from_dict(expected_response)
        else:
            expected = SubAccountTransferHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_sub_account_transfer_history_server_error(self):
        """Test that sub_account_transfer_history() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.sub_account_transfer_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.sub_account_transfer_history()

    @patch("binance_common.utils.get_signature")
    def test_transfer_to_master_success(self, mock_get_signature):
        """Test transfer_to_master() successfully with required parameters only."""

        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.transfer_to_master(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/transfer/subToMaster" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TransferToMasterResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(TransferToMasterResponse, "from_dict"):
            expected = TransferToMasterResponse.from_dict(expected_response)
        else:
            expected = TransferToMasterResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_transfer_to_master_success_with_optional_params(self, mock_get_signature):
        """Test transfer_to_master() successfully with optional parameters."""

        params = {"asset": "asset_example", "amount": 1.0, "recv_window": 5000}

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.transfer_to_master(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/transfer/subToMaster" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TransferToMasterResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(TransferToMasterResponse, "from_dict"):
            expected = TransferToMasterResponse.from_dict(expected_response)
        else:
            expected = TransferToMasterResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_transfer_to_master_missing_required_param_asset(self):
        """Test that transfer_to_master() raises RequiredError when 'asset' is missing."""
        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.transfer_to_master(**params)

    def test_transfer_to_master_missing_required_param_amount(self):
        """Test that transfer_to_master() raises RequiredError when 'amount' is missing."""
        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.transfer_to_master(**params)

    def test_transfer_to_master_server_error(self):
        """Test that transfer_to_master() raises an error when the server returns an error."""

        params = {
            "asset": "asset_example",
            "amount": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.transfer_to_master = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.transfer_to_master(**params)

    @patch("binance_common.utils.get_signature")
    def test_transfer_to_sub_account_of_same_master_success(self, mock_get_signature):
        """Test transfer_to_sub_account_of_same_master() successfully with required parameters only."""

        params = {
            "to_email": "to_email_example",
            "asset": "asset_example",
            "amount": 1.0,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.transfer_to_sub_account_of_same_master(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/transfer/subToSub" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["toEmail"] == "to_email_example"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TransferToSubAccountOfSameMasterResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(TransferToSubAccountOfSameMasterResponse, "from_dict")
        ):
            expected = TransferToSubAccountOfSameMasterResponse.from_dict(
                expected_response
            )
        else:
            expected = TransferToSubAccountOfSameMasterResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_transfer_to_sub_account_of_same_master_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test transfer_to_sub_account_of_same_master() successfully with optional parameters."""

        params = {
            "to_email": "to_email_example",
            "asset": "asset_example",
            "amount": 1.0,
            "recv_window": 5000,
        }

        expected_response = {"txnId": "2966662589"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.transfer_to_sub_account_of_same_master(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/transfer/subToSub" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TransferToSubAccountOfSameMasterResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(TransferToSubAccountOfSameMasterResponse, "from_dict")
        ):
            expected = TransferToSubAccountOfSameMasterResponse.from_dict(
                expected_response
            )
        else:
            expected = TransferToSubAccountOfSameMasterResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_transfer_to_sub_account_of_same_master_missing_required_param_to_email(
        self,
    ):
        """Test that transfer_to_sub_account_of_same_master() raises RequiredError when 'to_email' is missing."""
        params = {
            "to_email": "to_email_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["to_email"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'to_email'"
        ):
            self.client.transfer_to_sub_account_of_same_master(**params)

    def test_transfer_to_sub_account_of_same_master_missing_required_param_asset(self):
        """Test that transfer_to_sub_account_of_same_master() raises RequiredError when 'asset' is missing."""
        params = {
            "to_email": "to_email_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.transfer_to_sub_account_of_same_master(**params)

    def test_transfer_to_sub_account_of_same_master_missing_required_param_amount(self):
        """Test that transfer_to_sub_account_of_same_master() raises RequiredError when 'amount' is missing."""
        params = {
            "to_email": "to_email_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.transfer_to_sub_account_of_same_master(**params)

    def test_transfer_to_sub_account_of_same_master_server_error(self):
        """Test that transfer_to_sub_account_of_same_master() raises an error when the server returns an error."""

        params = {
            "to_email": "to_email_example",
            "asset": "asset_example",
            "amount": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.transfer_to_sub_account_of_same_master = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.transfer_to_sub_account_of_same_master(**params)

    @patch("binance_common.utils.get_signature")
    def test_universal_transfer_success(self, mock_get_signature):
        """Test universal_transfer() successfully with required parameters only."""

        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
        }

        expected_response = {"tranId": 11945860693, "clientTranId": "test"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.universal_transfer(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/universalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["fromAccountType"] == "from_account_type_example"
        assert normalized["toAccountType"] == "to_account_type_example"
        assert normalized["asset"] == "asset_example"
        assert normalized["amount"] == 1.0

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UniversalTransferResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UniversalTransferResponse, "from_dict"):
            expected = UniversalTransferResponse.from_dict(expected_response)
        else:
            expected = UniversalTransferResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_universal_transfer_success_with_optional_params(self, mock_get_signature):
        """Test universal_transfer() successfully with optional parameters."""

        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
            "from_email": "from_email_example",
            "to_email": "to_email_example",
            "client_tran_id": "1",
            "symbol": "symbol_example",
            "recv_window": 5000,
        }

        expected_response = {"tranId": 11945860693, "clientTranId": "test"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.universal_transfer(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/sub-account/universalTransfer" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UniversalTransferResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UniversalTransferResponse, "from_dict"):
            expected = UniversalTransferResponse.from_dict(expected_response)
        else:
            expected = UniversalTransferResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_universal_transfer_missing_required_param_from_account_type(self):
        """Test that universal_transfer() raises RequiredError when 'from_account_type' is missing."""
        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["from_account_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'from_account_type'"
        ):
            self.client.universal_transfer(**params)

    def test_universal_transfer_missing_required_param_to_account_type(self):
        """Test that universal_transfer() raises RequiredError when 'to_account_type' is missing."""
        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["to_account_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'to_account_type'"
        ):
            self.client.universal_transfer(**params)

    def test_universal_transfer_missing_required_param_asset(self):
        """Test that universal_transfer() raises RequiredError when 'asset' is missing."""
        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["asset"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'asset'"):
            self.client.universal_transfer(**params)

    def test_universal_transfer_missing_required_param_amount(self):
        """Test that universal_transfer() raises RequiredError when 'amount' is missing."""
        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.universal_transfer(**params)

    def test_universal_transfer_server_error(self):
        """Test that universal_transfer() raises an error when the server returns an error."""

        params = {
            "from_account_type": "from_account_type_example",
            "to_account_type": "to_account_type_example",
            "asset": "asset_example",
            "amount": 1.0,
        }

        mock_error = Exception("ResponseError")
        self.client.universal_transfer = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.universal_transfer(**params)
