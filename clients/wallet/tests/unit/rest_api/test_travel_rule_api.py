"""
Binance Wallet REST API

OpenAPI Specification for the Binance Wallet REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_wallet.rest_api.api import TravelRuleApi
from binance_sdk_wallet.rest_api.models import BrokerWithdrawResponse
from binance_sdk_wallet.rest_api.models import CheckQuestionnaireRequirementsResponse
from binance_sdk_wallet.rest_api.models import DepositHistoryTravelRuleResponse
from binance_sdk_wallet.rest_api.models import DepositHistoryV2Response
from binance_sdk_wallet.rest_api.models import FetchAddressVerificationListResponse
from binance_sdk_wallet.rest_api.models import SubmitDepositQuestionnaireResponse
from binance_sdk_wallet.rest_api.models import (
    SubmitDepositQuestionnaireTravelRuleResponse,
)
from binance_sdk_wallet.rest_api.models import VaspListResponse
from binance_sdk_wallet.rest_api.models import WithdrawHistoryV1Response
from binance_sdk_wallet.rest_api.models import WithdrawHistoryV2Response
from binance_sdk_wallet.rest_api.models import WithdrawTravelRuleResponse


class TestTravelRuleApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = TravelRuleApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_broker_withdraw_success(self, mock_get_signature):
        """Test broker_withdraw() successfully with required parameters only."""

        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }

        expected_response = {
            "trId": 123456,
            "accpted": True,
            "info": "Withdraw request accepted",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.broker_withdraw(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/broker/withdraw/apply" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["address"] == "address_example"
        assert normalized["coin"] == "coin_example"
        assert normalized["amount"] == 1.0
        assert normalized["withdrawOrderId"] == "1"
        assert normalized["questionnaire"] == "questionnaire_example"
        assert normalized["originatorPii"] == "originator_pii_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(BrokerWithdrawResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = BrokerWithdrawResponse.from_dict(expected_response)
        else:
            expected = BrokerWithdrawResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_broker_withdraw_success_with_optional_params(self, mock_get_signature):
        """Test broker_withdraw() successfully with optional parameters."""

        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
            "address_tag": "address_tag_example",
            "network": "network_example",
            "address_name": "address_name_example",
            "transaction_fee_flag": False,
            "wallet_type": 0,
        }

        expected_response = {
            "trId": 123456,
            "accpted": True,
            "info": "Withdraw request accepted",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.broker_withdraw(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/broker/withdraw/apply" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(BrokerWithdrawResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = BrokerWithdrawResponse.from_dict(expected_response)
        else:
            expected = BrokerWithdrawResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_broker_withdraw_missing_required_param_address(self):
        """Test that broker_withdraw() raises RequiredError when 'address' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["address"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'address'"):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_missing_required_param_coin(self):
        """Test that broker_withdraw() raises RequiredError when 'coin' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["coin"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'coin'"):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_missing_required_param_amount(self):
        """Test that broker_withdraw() raises RequiredError when 'amount' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_missing_required_param_withdraw_order_id(self):
        """Test that broker_withdraw() raises RequiredError when 'withdraw_order_id' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["withdraw_order_id"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'withdraw_order_id'"
        ):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_missing_required_param_questionnaire(self):
        """Test that broker_withdraw() raises RequiredError when 'questionnaire' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["questionnaire"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'questionnaire'"
        ):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_missing_required_param_originator_pii(self):
        """Test that broker_withdraw() raises RequiredError when 'originator_pii' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["originator_pii"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'originator_pii'"
        ):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_missing_required_param_signature(self):
        """Test that broker_withdraw() raises RequiredError when 'signature' is missing."""
        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }
        params["signature"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'signature'"
        ):
            self.client.broker_withdraw(**params)

    def test_broker_withdraw_server_error(self):
        """Test that broker_withdraw() raises an error when the server returns an error."""

        params = {
            "address": "address_example",
            "coin": "coin_example",
            "amount": 1.0,
            "withdraw_order_id": "1",
            "questionnaire": "questionnaire_example",
            "originator_pii": "originator_pii_example",
            "signature": "signature_example",
        }

        mock_error = Exception("ResponseError")
        self.client.broker_withdraw = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.broker_withdraw(**params)

    @patch("binance_common.utils.get_signature")
    def test_check_questionnaire_requirements_success(self, mock_get_signature):
        """Test check_questionnaire_requirements() successfully with required parameters only."""

        expected_response = {"questionnaireCountryCode": "AE"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.check_questionnaire_requirements()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert (
            "/sapi/v1/localentity/questionnaire-requirements" in request_kwargs["url"]
        )
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CheckQuestionnaireRequirementsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = CheckQuestionnaireRequirementsResponse.from_dict(
                expected_response
            )
        else:
            expected = CheckQuestionnaireRequirementsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_check_questionnaire_requirements_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test check_questionnaire_requirements() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = {"questionnaireCountryCode": "AE"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.check_questionnaire_requirements(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert (
            "/sapi/v1/localentity/questionnaire-requirements" in request_kwargs["url"]
        )
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CheckQuestionnaireRequirementsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = CheckQuestionnaireRequirementsResponse.from_dict(
                expected_response
            )
        else:
            expected = CheckQuestionnaireRequirementsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_check_questionnaire_requirements_server_error(self):
        """Test that check_questionnaire_requirements() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.check_questionnaire_requirements = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.check_questionnaire_requirements()

    @patch("binance_common.utils.get_signature")
    def test_deposit_history_travel_rule_success(self, mock_get_signature):
        """Test deposit_history_travel_rule() successfully with required parameters only."""

        expected_response = [
            {
                "trId": 123451123,
                "tranId": 17644346245865,
                "amount": "0.001",
                "coin": "BNB",
                "network": "BNB",
                "depositStatus": 0,
                "travelRuleStatus": 1,
                "address": "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23",
                "addressTag": "101764890",
                "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
                "insertTime": 1661493146000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
                "requireQuestionnaire": False,
                "questionnaire": None,
            },
            {
                "trId": 2451123,
                "tranId": 4544346245865,
                "amount": "0.50000000",
                "coin": "IOTA",
                "network": "IOTA",
                "depositStatus": 0,
                "travelRuleStatus": 0,
                "address": "SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW",
                "addressTag": "",
                "txId": "ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999",
                "insertTime": 1599620082000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
                "requireQuestionnaire": False,
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.deposit_history_travel_rule()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/deposit/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DepositHistoryTravelRuleResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DepositHistoryTravelRuleResponse.from_dict(expected_response)
        else:
            expected = DepositHistoryTravelRuleResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_deposit_history_travel_rule_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test deposit_history_travel_rule() successfully with optional parameters."""

        params = {
            "tr_id": "1",
            "tx_id": "1",
            "tran_id": "1",
            "network": "network_example",
            "coin": "coin_example",
            "travel_rule_status": 56,
            "pending_questionnaire": True,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "offset": 0,
            "limit": 7,
        }

        expected_response = [
            {
                "trId": 123451123,
                "tranId": 17644346245865,
                "amount": "0.001",
                "coin": "BNB",
                "network": "BNB",
                "depositStatus": 0,
                "travelRuleStatus": 1,
                "address": "bnb136ns6lfw4zs5hg4n85vdthaad7hq5m4gtkgf23",
                "addressTag": "101764890",
                "txId": "98A3EA560C6B3336D348B6C83F0F95ECE4F1F5919E94BD006E5BF3BF264FACFC",
                "insertTime": 1661493146000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
                "requireQuestionnaire": False,
                "questionnaire": None,
            },
            {
                "trId": 2451123,
                "tranId": 4544346245865,
                "amount": "0.50000000",
                "coin": "IOTA",
                "network": "IOTA",
                "depositStatus": 0,
                "travelRuleStatus": 0,
                "address": "SIZ9VLMHWATXKV99LH99CIGFJFUMLEHGWVZVNNZXRJJVWBPHYWPPBOSDORZ9EQSHCZAMPVAPGFYQAUUV9DROOXJLNW",
                "addressTag": "",
                "txId": "ESBFVQUTPIWQNJSPXFNHNYHSQNTGKRVKPRABQWTAXCDWOAKDKYWPTVG9BGXNVNKTLEJGESAVXIKIZ9999",
                "insertTime": 1599620082000,
                "transferType": 0,
                "confirmTimes": "1/1",
                "unlockConfirm": 0,
                "walletType": 0,
                "requireQuestionnaire": False,
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.deposit_history_travel_rule(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/deposit/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DepositHistoryTravelRuleResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DepositHistoryTravelRuleResponse.from_dict(expected_response)
        else:
            expected = DepositHistoryTravelRuleResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_deposit_history_travel_rule_server_error(self):
        """Test that deposit_history_travel_rule() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.deposit_history_travel_rule = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.deposit_history_travel_rule()

    @patch("binance_common.utils.get_signature")
    def test_deposit_history_v2_success(self, mock_get_signature):
        """Test deposit_history_v2() successfully with required parameters only."""

        expected_response = [
            {
                "depositId": "4615328107052018945",
                "amount": "0.01",
                "network": "AVAXC",
                "coin": "AVAX",
                "depositStatus": 1,
                "travelRuleReqStatus": 0,
                "address": "0x0010627ab66d69232f4080d54e0f838b4dc3894a",
                "addressTag": "",
                "txId": "0xdde578983015741eed764e7ca10defb5a2caafdca3db5f92872d24a96beb1879",
                "transferType": 0,
                "confirmTimes": "12/12",
                "requireQuestionnaire": False,
                "questionnaire": {"vaspName": "BINANCE", "depositOriginator": 0},
                "insertTime": 1753053392000,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.deposit_history_v2()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/localentity/deposit/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DepositHistoryV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DepositHistoryV2Response.from_dict(expected_response)
        else:
            expected = DepositHistoryV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_deposit_history_v2_success_with_optional_params(self, mock_get_signature):
        """Test deposit_history_v2() successfully with optional parameters."""

        params = {
            "deposit_id": "1",
            "tx_id": "1",
            "network": "network_example",
            "coin": "coin_example",
            "retrieve_questionnaire": True,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "offset": 0,
            "limit": 7,
        }

        expected_response = [
            {
                "depositId": "4615328107052018945",
                "amount": "0.01",
                "network": "AVAXC",
                "coin": "AVAX",
                "depositStatus": 1,
                "travelRuleReqStatus": 0,
                "address": "0x0010627ab66d69232f4080d54e0f838b4dc3894a",
                "addressTag": "",
                "txId": "0xdde578983015741eed764e7ca10defb5a2caafdca3db5f92872d24a96beb1879",
                "transferType": 0,
                "confirmTimes": "12/12",
                "requireQuestionnaire": False,
                "questionnaire": {"vaspName": "BINANCE", "depositOriginator": 0},
                "insertTime": 1753053392000,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.deposit_history_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/localentity/deposit/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(DepositHistoryV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = DepositHistoryV2Response.from_dict(expected_response)
        else:
            expected = DepositHistoryV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_deposit_history_v2_server_error(self):
        """Test that deposit_history_v2() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.deposit_history_v2 = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.deposit_history_v2()

    @patch("binance_common.utils.get_signature")
    def test_fetch_address_verification_list_success(self, mock_get_signature):
        """Test fetch_address_verification_list() successfully with required parameters only."""

        expected_response = [
            {
                "status": "PENDING",
                "token": "AVAX",
                "network": "AVAXC",
                "walletAddress": "0xc03a6aa728a8dde7464c33828424ede7553a0021",
                "addressQuestionnaire": {
                    "sendTo": 1,
                    "satoshiToken": "AVAX",
                    "isAddressOwner": 1,
                    "verifyMethod": 1,
                },
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.fetch_address_verification_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/addressVerify/list" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(FetchAddressVerificationListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = FetchAddressVerificationListResponse.from_dict(expected_response)
        else:
            expected = FetchAddressVerificationListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_fetch_address_verification_list_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test fetch_address_verification_list() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = [
            {
                "status": "PENDING",
                "token": "AVAX",
                "network": "AVAXC",
                "walletAddress": "0xc03a6aa728a8dde7464c33828424ede7553a0021",
                "addressQuestionnaire": {
                    "sendTo": 1,
                    "satoshiToken": "AVAX",
                    "isAddressOwner": 1,
                    "verifyMethod": 1,
                },
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.fetch_address_verification_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/addressVerify/list" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(FetchAddressVerificationListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = FetchAddressVerificationListResponse.from_dict(expected_response)
        else:
            expected = FetchAddressVerificationListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_fetch_address_verification_list_server_error(self):
        """Test that fetch_address_verification_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.fetch_address_verification_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.fetch_address_verification_list()

    @patch("binance_common.utils.get_signature")
    def test_submit_deposit_questionnaire_success(self, mock_get_signature):
        """Test submit_deposit_questionnaire() successfully with required parameters only."""

        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }

        expected_response = {
            "trId": 765127651,
            "accepted": True,
            "info": "Deposit questionnaire accepted.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.submit_deposit_questionnaire(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert (
            "/sapi/v1/localentity/broker/deposit/provide-info" in request_kwargs["url"]
        )
        assert request_kwargs["method"] == "PUT"
        assert normalized["subAccountId"] == "1"
        assert normalized["depositId"] == "1"
        assert normalized["questionnaire"] == "questionnaire_example"
        assert normalized["beneficiaryPii"] == "beneficiary_pii_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubmitDepositQuestionnaireResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SubmitDepositQuestionnaireResponse.from_dict(expected_response)
        else:
            expected = SubmitDepositQuestionnaireResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_submit_deposit_questionnaire_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test submit_deposit_questionnaire() successfully with optional parameters."""

        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
            "network": "network_example",
            "coin": "coin_example",
            "amount": 1.0,
            "address": "address_example",
            "address_tag": "address_tag_example",
        }

        expected_response = {
            "trId": 765127651,
            "accepted": True,
            "info": "Deposit questionnaire accepted.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.submit_deposit_questionnaire(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert (
            "/sapi/v1/localentity/broker/deposit/provide-info" in request_kwargs["url"]
        )
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubmitDepositQuestionnaireResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SubmitDepositQuestionnaireResponse.from_dict(expected_response)
        else:
            expected = SubmitDepositQuestionnaireResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_submit_deposit_questionnaire_missing_required_param_sub_account_id(self):
        """Test that submit_deposit_questionnaire() raises RequiredError when 'sub_account_id' is missing."""
        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }
        params["sub_account_id"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'sub_account_id'"
        ):
            self.client.submit_deposit_questionnaire(**params)

    def test_submit_deposit_questionnaire_missing_required_param_deposit_id(self):
        """Test that submit_deposit_questionnaire() raises RequiredError when 'deposit_id' is missing."""
        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }
        params["deposit_id"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'deposit_id'"
        ):
            self.client.submit_deposit_questionnaire(**params)

    def test_submit_deposit_questionnaire_missing_required_param_questionnaire(self):
        """Test that submit_deposit_questionnaire() raises RequiredError when 'questionnaire' is missing."""
        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }
        params["questionnaire"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'questionnaire'"
        ):
            self.client.submit_deposit_questionnaire(**params)

    def test_submit_deposit_questionnaire_missing_required_param_beneficiary_pii(self):
        """Test that submit_deposit_questionnaire() raises RequiredError when 'beneficiary_pii' is missing."""
        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }
        params["beneficiary_pii"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'beneficiary_pii'"
        ):
            self.client.submit_deposit_questionnaire(**params)

    def test_submit_deposit_questionnaire_missing_required_param_signature(self):
        """Test that submit_deposit_questionnaire() raises RequiredError when 'signature' is missing."""
        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }
        params["signature"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'signature'"
        ):
            self.client.submit_deposit_questionnaire(**params)

    def test_submit_deposit_questionnaire_server_error(self):
        """Test that submit_deposit_questionnaire() raises an error when the server returns an error."""

        params = {
            "sub_account_id": "1",
            "deposit_id": "1",
            "questionnaire": "questionnaire_example",
            "beneficiary_pii": "beneficiary_pii_example",
            "signature": "signature_example",
        }

        mock_error = Exception("ResponseError")
        self.client.submit_deposit_questionnaire = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.submit_deposit_questionnaire(**params)

    @patch("binance_common.utils.get_signature")
    def test_submit_deposit_questionnaire_travel_rule_success(self, mock_get_signature):
        """Test submit_deposit_questionnaire_travel_rule() successfully with required parameters only."""

        params = {"tran_id": 1, "questionnaire": "questionnaire_example"}

        expected_response = {
            "trId": 765127651,
            "accepted": True,
            "info": "Deposit questionnaire accepted.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.submit_deposit_questionnaire_travel_rule(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/deposit/provide-info" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert normalized["tranId"] == 1
        assert normalized["questionnaire"] == "questionnaire_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubmitDepositQuestionnaireTravelRuleResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SubmitDepositQuestionnaireTravelRuleResponse.from_dict(
                expected_response
            )
        else:
            expected = SubmitDepositQuestionnaireTravelRuleResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_submit_deposit_questionnaire_travel_rule_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test submit_deposit_questionnaire_travel_rule() successfully with optional parameters."""

        params = {"tran_id": 1, "questionnaire": "questionnaire_example"}

        expected_response = {
            "trId": 765127651,
            "accepted": True,
            "info": "Deposit questionnaire accepted.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.submit_deposit_questionnaire_travel_rule(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/deposit/provide-info" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SubmitDepositQuestionnaireTravelRuleResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = SubmitDepositQuestionnaireTravelRuleResponse.from_dict(
                expected_response
            )
        else:
            expected = SubmitDepositQuestionnaireTravelRuleResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_submit_deposit_questionnaire_travel_rule_missing_required_param_tran_id(
        self,
    ):
        """Test that submit_deposit_questionnaire_travel_rule() raises RequiredError when 'tran_id' is missing."""
        params = {"tran_id": 1, "questionnaire": "questionnaire_example"}
        params["tran_id"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'tran_id'"):
            self.client.submit_deposit_questionnaire_travel_rule(**params)

    def test_submit_deposit_questionnaire_travel_rule_missing_required_param_questionnaire(
        self,
    ):
        """Test that submit_deposit_questionnaire_travel_rule() raises RequiredError when 'questionnaire' is missing."""
        params = {"tran_id": 1, "questionnaire": "questionnaire_example"}
        params["questionnaire"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'questionnaire'"
        ):
            self.client.submit_deposit_questionnaire_travel_rule(**params)

    def test_submit_deposit_questionnaire_travel_rule_server_error(self):
        """Test that submit_deposit_questionnaire_travel_rule() raises an error when the server returns an error."""

        params = {"tran_id": 1, "questionnaire": "questionnaire_example"}

        mock_error = Exception("ResponseError")
        self.client.submit_deposit_questionnaire_travel_rule = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.submit_deposit_questionnaire_travel_rule(**params)

    @patch("binance_common.utils.get_signature")
    def test_vasp_list_success(self, mock_get_signature):
        """Test vasp_list() successfully with required parameters only."""

        expected_response = [
            {"vaspName": "Binance", "vaspCode": "BINANCE"},
            {"vaspName": "HashKeyGlobal", "vaspCode": "NVBH3Z_nNEHjvqbUfkaL"},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.vasp_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/vasp" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(VaspListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = VaspListResponse.from_dict(expected_response)
        else:
            expected = VaspListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_vasp_list_success_with_optional_params(self, mock_get_signature):
        """Test vasp_list() successfully with optional parameters."""

        params = {"recv_window": 5000}

        expected_response = [
            {"vaspName": "Binance", "vaspCode": "BINANCE"},
            {"vaspName": "HashKeyGlobal", "vaspCode": "NVBH3Z_nNEHjvqbUfkaL"},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.vasp_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/vasp" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(VaspListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = VaspListResponse.from_dict(expected_response)
        else:
            expected = VaspListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_vasp_list_server_error(self):
        """Test that vasp_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.vasp_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.vasp_list()

    @patch("binance_common.utils.get_signature")
    def test_withdraw_history_v1_success(self, mock_get_signature):
        """Test withdraw_history_v1() successfully with required parameters only."""

        expected_response = [
            {
                "id": "b6ae22b3aa844210a7041aee7589627c",
                "trId": 1234456,
                "amount": "8.91000000",
                "transactionFee": "0.004",
                "coin": "USDT",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
                "addressTag": "1231212",
                "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268",
                "applyTime": "2019-10-12 11:12:02",
                "network": "ETH",
                "transferType": 0,
                "withdrawOrderId": "WITHDRAWtest123",
                "info": "The address is not valid. Please confirm with the recipient",
                "confirmNo": 3,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
            {
                "id": "156ec387f49b41df8724fa744fa82719",
                "trId": 2231556234,
                "amount": "0.00150000",
                "transactionFee": "0.004",
                "coin": "BTC",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB",
                "txId": "60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354",
                "applyTime": "2019-09-24 12:43:45",
                "network": "BTC",
                "transferType": 0,
                "info": "",
                "confirmNo": 2,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.withdraw_history_v1()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/withdraw/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(WithdrawHistoryV1Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = WithdrawHistoryV1Response.from_dict(expected_response)
        else:
            expected = WithdrawHistoryV1Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_withdraw_history_v1_success_with_optional_params(self, mock_get_signature):
        """Test withdraw_history_v1() successfully with optional parameters."""

        params = {
            "tr_id": "1",
            "tx_id": "1",
            "withdraw_order_id": "1",
            "network": "network_example",
            "coin": "coin_example",
            "travel_rule_status": 56,
            "offset": 0,
            "limit": 7,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "id": "b6ae22b3aa844210a7041aee7589627c",
                "trId": 1234456,
                "amount": "8.91000000",
                "transactionFee": "0.004",
                "coin": "USDT",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
                "addressTag": "1231212",
                "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268",
                "applyTime": "2019-10-12 11:12:02",
                "network": "ETH",
                "transferType": 0,
                "withdrawOrderId": "WITHDRAWtest123",
                "info": "The address is not valid. Please confirm with the recipient",
                "confirmNo": 3,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
            {
                "id": "156ec387f49b41df8724fa744fa82719",
                "trId": 2231556234,
                "amount": "0.00150000",
                "transactionFee": "0.004",
                "coin": "BTC",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB",
                "txId": "60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354",
                "applyTime": "2019-09-24 12:43:45",
                "network": "BTC",
                "transferType": 0,
                "info": "",
                "confirmNo": 2,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.withdraw_history_v1(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/withdraw/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(WithdrawHistoryV1Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = WithdrawHistoryV1Response.from_dict(expected_response)
        else:
            expected = WithdrawHistoryV1Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_withdraw_history_v1_server_error(self):
        """Test that withdraw_history_v1() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.withdraw_history_v1 = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.withdraw_history_v1()

    @patch("binance_common.utils.get_signature")
    def test_withdraw_history_v2_success(self, mock_get_signature):
        """Test withdraw_history_v2() successfully with required parameters only."""

        expected_response = [
            {
                "id": "b6ae22b3aa844210a7041aee7589627c",
                "trId": 1234456,
                "amount": "8.91000000",
                "transactionFee": "0.004",
                "coin": "USDT",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
                "addressTag": "1231212",
                "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268",
                "applyTime": "2019-10-12 11:12:02",
                "network": "ETH",
                "transferType": 0,
                "withdrawOrderId": "WITHDRAWtest123",
                "info": "The address is not valid. Please confirm with the recipient",
                "confirmNo": 3,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
            {
                "id": "156ec387f49b41df8724fa744fa82719",
                "trId": 2231556234,
                "amount": "0.00150000",
                "transactionFee": "0.004",
                "coin": "BTC",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB",
                "txId": "60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354",
                "applyTime": "2019-09-24 12:43:45",
                "network": "BTC",
                "transferType": 0,
                "info": "",
                "confirmNo": 2,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.withdraw_history_v2()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/localentity/withdraw/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(WithdrawHistoryV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = WithdrawHistoryV2Response.from_dict(expected_response)
        else:
            expected = WithdrawHistoryV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_withdraw_history_v2_success_with_optional_params(self, mock_get_signature):
        """Test withdraw_history_v2() successfully with optional parameters."""

        params = {
            "tr_id": "1",
            "tx_id": "1",
            "withdraw_order_id": "1",
            "network": "network_example",
            "coin": "coin_example",
            "travel_rule_status": 56,
            "offset": 0,
            "limit": 7,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "id": "b6ae22b3aa844210a7041aee7589627c",
                "trId": 1234456,
                "amount": "8.91000000",
                "transactionFee": "0.004",
                "coin": "USDT",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "0x94df8b352de7f46f64b01d3666bf6e936e44ce60",
                "addressTag": "1231212",
                "txId": "0xb5ef8c13b968a406cc62a93a8bd80f9e9a906ef1b3fcf20a2e48573c17659268",
                "applyTime": "2019-10-12 11:12:02",
                "network": "ETH",
                "transferType": 0,
                "withdrawOrderId": "WITHDRAWtest123",
                "info": "The address is not valid. Please confirm with the recipient",
                "confirmNo": 3,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
            {
                "id": "156ec387f49b41df8724fa744fa82719",
                "trId": 2231556234,
                "amount": "0.00150000",
                "transactionFee": "0.004",
                "coin": "BTC",
                "withdrawalStatus": 6,
                "travelRuleStatus": 0,
                "address": "1FZdVHtiBqMrWdjPyRPULCUceZPJ2WLCsB",
                "txId": "60fd9007ebfddc753455f95fafa808c4302c836e4d1eebc5a132c36c1d8ac354",
                "applyTime": "2019-09-24 12:43:45",
                "network": "BTC",
                "transferType": 0,
                "info": "",
                "confirmNo": 2,
                "walletType": 1,
                "txKey": "",
                "questionnaire": '{"question1":"answer1","question2":"answer2"}',
                "completeTime": "2023-03-23 16:52:41",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.withdraw_history_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v2/localentity/withdraw/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(WithdrawHistoryV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = WithdrawHistoryV2Response.from_dict(expected_response)
        else:
            expected = WithdrawHistoryV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_withdraw_history_v2_server_error(self):
        """Test that withdraw_history_v2() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.withdraw_history_v2 = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.withdraw_history_v2()

    @patch("binance_common.utils.get_signature")
    def test_withdraw_travel_rule_success(self, mock_get_signature):
        """Test withdraw_travel_rule() successfully with required parameters only."""

        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
        }

        expected_response = {
            "trId": 123456,
            "accpted": True,
            "info": "Withdraw request accepted",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.withdraw_travel_rule(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/withdraw/apply" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["coin"] == "coin_example"
        assert normalized["address"] == "address_example"
        assert normalized["amount"] == 1.0
        assert normalized["questionnaire"] == "questionnaire_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(WithdrawTravelRuleResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = WithdrawTravelRuleResponse.from_dict(expected_response)
        else:
            expected = WithdrawTravelRuleResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_withdraw_travel_rule_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test withdraw_travel_rule() successfully with optional parameters."""

        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
            "withdraw_order_id": "1",
            "network": "network_example",
            "address_tag": "address_tag_example",
            "transaction_fee_flag": False,
            "name": "name_example",
            "wallet_type": 0,
            "recv_window": 5000,
        }

        expected_response = {
            "trId": 123456,
            "accpted": True,
            "info": "Withdraw request accepted",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.withdraw_travel_rule(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/sapi/v1/localentity/withdraw/apply" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(WithdrawTravelRuleResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list:
            expected = WithdrawTravelRuleResponse.from_dict(expected_response)
        else:
            expected = WithdrawTravelRuleResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_withdraw_travel_rule_missing_required_param_coin(self):
        """Test that withdraw_travel_rule() raises RequiredError when 'coin' is missing."""
        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
        }
        params["coin"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'coin'"):
            self.client.withdraw_travel_rule(**params)

    def test_withdraw_travel_rule_missing_required_param_address(self):
        """Test that withdraw_travel_rule() raises RequiredError when 'address' is missing."""
        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
        }
        params["address"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'address'"):
            self.client.withdraw_travel_rule(**params)

    def test_withdraw_travel_rule_missing_required_param_amount(self):
        """Test that withdraw_travel_rule() raises RequiredError when 'amount' is missing."""
        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.withdraw_travel_rule(**params)

    def test_withdraw_travel_rule_missing_required_param_questionnaire(self):
        """Test that withdraw_travel_rule() raises RequiredError when 'questionnaire' is missing."""
        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
        }
        params["questionnaire"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'questionnaire'"
        ):
            self.client.withdraw_travel_rule(**params)

    def test_withdraw_travel_rule_server_error(self):
        """Test that withdraw_travel_rule() raises an error when the server returns an error."""

        params = {
            "coin": "coin_example",
            "address": "address_example",
            "amount": 1.0,
            "questionnaire": "questionnaire_example",
        }

        mock_error = Exception("ResponseError")
        self.client.withdraw_travel_rule = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.withdraw_travel_rule(**params)
